<!DOCTYPE html>
<html>
<head hexo-theme="https://volantis.js.org/#20200605">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人 - 大泡泡的笔记</title>
  
    <meta name="keywords" content="Java,并发">
  
  
    <meta name="description" content="Single Threaded Execution模式，即&quot;以一个线程执行&quot;。就像独木桥一样，同一时间内只允许一个人通过，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。

其实主要思想也就是：

当我们修改多个线程共享的实例时，实例就会失去安全性。所以我们找出这个不安全的范围，将...">
  

  <!-- feed -->
  

  <!-- import meta -->
  
    
      <meta name="theme-color" content="#FFFFFF">
    
      <meta name="msapplication-TileColor" content="#1BC3FB">
    
      <meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/browserconfig.xml">
    
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/wongqingbin/PicGo/favicon.ico">
  

  

  <!-- import link -->
  
  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  <link rel="icon" type="image/x-icon" sizes="32x32" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/favicon-32x32.png">
  <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/apple-touch-icon.png">
  <link rel="mask-icon" color="#1BC3FB" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/safari-pinned-tab.svg">
  <link rel="manifest" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/site.webmanifest">
  

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class="container">
  <div class="wrapper">
    <div class="nav-sub">
      <p class="title"></p>
      <ul class="switcher nav-list-h">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href="/">
          
          
          
            Bubble
          
          
        </a>
      

			<div class="menu navigation">
				<ul class="nav-list-h">
          
          
          
            
            
              <li>
                <a class="flat-box" href="/" id="home">
                  <i class="fas fa-home fa-fw fa-fw"></i>主页
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href="/categories/" id="categories">
                  <i class="fas fa-folder-open fa-fw"></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href="/tags/" id="tags">
                  <i class="fas fa-tags fa-fw"></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href="/archives/" id="archives">
                  <i class="fas fa-archive fa-fw"></i>时间轴
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box">
                  <i class="fas fa-ellipsis-v fa-fw"></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="flat-box" href="/about/" id="about">
                  <i class="fas fa-info-circle fa-fw"></i>关于小站
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="flat-box" href="https://github.com/bubblewu/hexo-blog" target="_blank" id="https:githubcombubblewuhexo-blog" rel="external nofollow noopener noreferrer">
                  <i class="fab fa-github fa-fw"></i>博客源码
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="flat-box" href="/contributors/" id="contributors">
                  <i class="fas fa-handshake fa-fw"></i>鸣谢
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search...">
        </form>
      </div>

			<ul class="switcher nav-list-h">
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href="/" id="home">
                  <i class="fas fa-home fa-fw fa-fw"></i>主页
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href="/categories/" id="categories">
                  <i class="fas fa-folder-open fa-fw"></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href="/tags/" id="tags">
                  <i class="fas fa-tags fa-fw"></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href="/archives/" id="archives">
                  <i class="fas fa-archive fa-fw"></i>时间轴
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box">
                  <i class="fas fa-ellipsis-v fa-fw"></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="flat-box" href="/about/" id="about">
                  <i class="fas fa-info-circle fa-fw"></i>关于小站
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="flat-box" href="https://github.com/bubblewu/hexo-blog" target="_blank" id="https:githubcombubblewuhexo-blog" rel="external nofollow noopener noreferrer">
                  <i class="fab fa-github fa-fw"></i>博客源码
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="flat-box" href="/contributors/" id="contributors">
                  <i class="fas fa-handshake fa-fw"></i>鸣谢
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class="body-wrapper">
      

<div class="l_main">
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class="meta">
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/ckd8g12ck0000v1yd2ymng4um/">
      并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人
    </a>
  </h1>


        
        <div class="new-meta-box">
          
            
          
            
              
<div class="new-meta-item author">
  <a href="https://bubblewu.github.io/" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/bubble.png">
    <p>大泡泡</p>
  </a>
</div>

            
          
            
              
  
  <div class="new-meta-item category">
    <a href="/categories/Java/%E5%B9%B6%E5%8F%91/" rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java/并发</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class="notlink">
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年7月30日</p>
  </a>
</div>

            
          
            
              <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-08-18T15:25:09+08:00">
  <a class="notlink">
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020年8月18日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  <div class="new-meta-item wordcount">
    <a class="notlink">
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：5.1k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class="notlink">
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：19分钟</p>
    </a>
  </div>


            
          
            
              
  
    <div class="new-meta-item browse busuanzi">
      <a class="notlink">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv"></span>
        </p>
      </a>
    </div>
  


            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <p>Single Threaded Execution模式，即&quot;以一个线程执行&quot;。<br>就像独木桥一样，同一时间内只允许一个人通过，<strong>该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。</strong></p>
<ul>
<li>其实<code>主要思想</code>也就是：</li>
</ul>
<p><strong>当我们修改多个线程共享的实例时，实例就会失去安全性。所以我们找出这个不安全的范围，将这个范围设置为临界区，并对临界区进行保护（使用synchronized），使其只允许一个线程同时执行</strong>。</p>
<a id="more"></a>

<h2 id="Single-Threaded-Execution模式"><a href="#Single-Threaded-Execution模式" class="headerlink" title="Single Threaded Execution模式"></a>Single Threaded Execution模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Single Threaded Execution模式中会有一个发挥<code>SharedResource（共享资源）</code>作用的类。如下面案例中的门Gate这个类。</p>
<p><strong>SharedResource角色是可以被多个线程访问的类</strong>，包含很多方法，主要分类下面两类：</p>
<ul>
<li><code>safeMethod</code>：线程安全方法。多线程下不会发生问题。</li>
<li><code>unsafeMethod</code>：非线程安全方法。多个线程调用会出现问题，需进行保护，使其不被多个线程同时访问。</li>
</ul>
<p><strong>Single Threaded Execution模式会保护unsafeMethod，使其只能由一个线程访问</strong>，Java可以使用<code>synchronized关键字</code>。我们将<strong>允许单个线程执行的程序范围</strong>称为<code>临界区</code>。<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/concurrent/single-thread-execution.png" alt="Single Threaded Execution模式下的Timethreads图"></p>
<h3 id="什么时候使用？"><a href="#什么时候使用？" class="headerlink" title="什么时候使用？"></a>什么时候使用？</h3><ul>
<li><p><code>多线程时</code>：<br>单线程时不需要，使用的前提是多线程环境下。</p>
</li>
<li><p><code>多个线程访问时</code>：</p>
</li>
</ul>
<p><strong>当SharedResource角色的实例有可能被多个线程同时访问时</strong>，就需要使用Single Threaded Execution模式。</p>
<p>即使是多线程程序，如果所有线程都是完全独立操作的，那么就不需要使用该模式，当前状态为<code>线程互不干涉（interfere）</code>。<br>在某些多线程框架中，有时线程的独立性是由框架保证的，这时也不需使用该模式。</p>
<ul>
<li><code>状态有可能发生变化时</code>：<br>如果SharedResource角色的状态会发生变化时，就需使用该模式。</li>
</ul>
<p>如果创建实例后，实例的状态再也不会发生变化，则不需使用。如<code>只读不写</code>的情况。如<code>Immutable模式</code>时，实例的状态不会发生改变，也就不需要。</p>
<ul>
<li><code>需要确保安全性时</code>：<br>只有在需要确保安全性时，才需要使用该模式。<br>如：Java的集合类大多为非线程安全的，在使用时，这是为了在不需要考虑安全性的时候提高程序的运行速度。</li>
</ul>
<blockquote>
<p>线程安全的方法：<br>Java提供了下列方法，可以确保集合类是线程安全的。</p>
<ul>
<li>synchronizedCollection方法；</li>
<li>synchronizedList方法；</li>
<li>synchronizedMap方法；</li>
<li>synchronizedSet方法；</li>
<li>synchronizedSortedMap方法；</li>
<li>synchronizedSortedSet方法；</li>
</ul>
</blockquote>
<h3 id="安全性和synchronized"><a href="#安全性和synchronized" class="headerlink" title="安全性和synchronized"></a>安全性和synchronized</h3><p>Java使用关键字synchronized来实现执行线程的互斥处理。<br>同步方法（synchronized方法）： <strong>在方法前加synchronized关键字，每次只允许一个线程处理该方法。</strong></p>
<blockquote>
<p>synchronized实例方法、synchronized静态方法和synchronized代码块：</p>
<ul>
<li>synchronized代码块可以精确的控制互斥处理的执行范围。</li>
<li><strong>synchronized静态方法和synchronized实例方法使用的锁是不一样的。<code>synchronized静态方法是使用该类的类对象的锁来执行线程的互斥处理的</code></strong>，和synchronized代码块锁类时是等效的。</li>
</ul>
</blockquote>
<blockquote>
<p>需注意：</p>
<ul>
<li>某个线程在运行synchronized方法时，只会停止想要获取当前同一个实例的锁的线程；</li>
<li>非synchronized方法可以在任意时间被多个线程执行，即使存在正在运行其他的synchronized方法的线程，非synchronized方法也仍然可以由多个线程运行。</li>
<li>同一个实例的synchronized实例方法同时只能有一个线程运行，如实例不同，锁也就不同，所有就算是synchronized实例方法，也可以由多个线程同时运行。</li>
<li>同一个类下的多个synchronized静态方法不可以由多个线程同时运行，因为锁的是当前类对象。</li>
<li>synchronized方法通常会降低生存性，如容易引起死锁；添加不必要的synchronized，性能会降低，如吞吐量；</li>
</ul>
</blockquote>
<p>synchronized保护哪个对象的实例，就需对哪个对象加锁。<br>synchronized方法执行的操作，是不可分割的，能够防止多个线程交错的执行赋值操作，是<code>原子操作（Atomic）</code>。</p>
<blockquote>
<p>注意：如在一个bean实体中，分别对两个字段的set方法加锁也是不安全的，因为线程会单独赋值，<strong>需要将字段合在一起保护</strong>。</p>
</blockquote>
<ul>
<li><code>synchronized和lock/unlock</code></li>
</ul>
<p><strong>如果在lock和unlock之间出现return语句或异常处理，会导致unlock不会被调用</strong>。<br>而<strong>synchronized方法和代码块，无论是执行return还是抛出异常，都一定能释放锁</strong>。</p>
<p>不过lock和unlock操作，可以使用<code>finally块来执行unlock</code>。这样调用lock方法后，无论执行什么操作，都会调用unlock方法解锁。</p>
<ul>
<li><code>synchronized和volatile和juc包下的AtomicXXX</code><br>不使用synchronized，而<code>在声明该字段的时候加上volatile关键字，对该字段的操作也是原子的了</code>。<br><code>juc包下的AtomicXXX等类也是通过封装volatile功能而得到的类库</code>。</li>
</ul>
<p>所以：</p>
<ul>
<li>基本类型、引用类型的赋值和引用是原子操作；</li>
<li>但long和double在线程间共享时，需要加synchronized或声明为volatile。将其变为原子操作。</li>
</ul>
<h3 id="生存性和死锁"><a href="#生存性和死锁" class="headerlink" title="生存性和死锁"></a>生存性和死锁</h3><p>生存性是指无论什么时候，必要的处理都一定能够被执行。是程序正常运行的必要条件之一。<br>有时候安全性和生存性会互相制约。有时只重视安全性，生存性就会下降。典型代表就是<code>死锁（deadlook）</code>，即<strong>多个线程互相等待对方释放锁的情形</strong>。</p>
<p><strong>发生死锁的线程都无法再继续运行，程序也就失去了生存性</strong>。</p>
<blockquote>
<p>如：仅有勺子和叉子各一把，A和B都要吃意大利面，勺子和叉子缺一不可。A拿走了勺子，B拿走了叉子，两人互相僵持，最终谁也吃不了。</p>
</blockquote>
<p>在Single Threaded Execution模式中，满足下列条件时，死锁就会发生：</p>
<ul>
<li><p>存在多个SharedResource角色；</p>
<blockquote>
<p>多个SharedResource角色相当于勺子和叉子</p>
</blockquote>
</li>
<li><p>线程在持有着某个SharedResource角色的锁的同时，还想获取其他SharedResource角色的锁；</p>
<blockquote>
<p>相当于A拿着勺子同时还想拿叉子，B则相反。</p>
</blockquote>
</li>
<li><p>获取SharedResource角色的锁的顺序并不固定。（SharedResource角色是对称的）</p>
<blockquote>
<p>SharedResource角色是对称的，相当于“拿勺子-&gt;拿叉子”和“拿叉子-&gt;拿勺子”这两种操作。也就是说勺子和叉子二者并不分优先顺序。</p>
</blockquote>
</li>
</ul>
<p>只要破坏上面任何一个条件，就可以防止死锁的情况发生。<br>如：</p>
<ul>
<li><strong>多个线程按照相同的顺序去获取实例资源</strong>；</li>
<li><strong>将多个实例资源封装起来一齐拿，对整体做同步，如new Pair(A, B); 直接对pair做同步处理</strong>。</li>
</ul>
<h3 id="可复用性和继承反常"><a href="#可复用性和继承反常" class="headerlink" title="可复用性和继承反常"></a>可复用性和继承反常</h3><p>如果编写一个SharedResource角色的子类，如子类能访问SharedResource角色的字段，那么子类编写时，就容易出现unsafeMethod。<br>如果不将子类在内的所有unsafeMethod都声明为synchronized方法，那就无法确保SharedResource角色的安全性。</p>
<p>对于多线程来说，继承会引起一些麻烦的问题，称为<code>继承反常（inheritance anomaly）</code></p>
<h3 id="临界区的大小和性能"><a href="#临界区的大小和性能" class="headerlink" title="临界区的大小和性能"></a>临界区的大小和性能</h3><p>我们将<strong>允许单个线程执行的程序范围</strong>称为<code>临界区</code>。</p>
<blockquote>
<p>延长临界区的大小，可以使线程的安全性异常更早的暴露出来。如可以使用Thread.sleep()方法来提高检查出错误的可能性。<br>在临界区也可以调用Thread类等yield方法，加快线程的切换。</p>
<blockquote>
<p><code>Thread.yield()</code>方法作用是：<strong>暂停当前正在执行的线程对象，并执行其他线程</strong>。<br>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。<br>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p>
</blockquote>
</blockquote>
<p>一般情况下Single Threaded Execution模式会降低程序的性能。</p>
<ul>
<li><p><code>获取锁耗费时间</code>：<br>进入synchronized方法时，线程需要获取锁的对象，会耗费一定时间。<br>如果SharedResource角色的数量少了，那么要获取锁的数量也会减少，从而能够抑制性能的下降。</p>
</li>
<li><p><code>线程冲突引起的等待</code>：<br>当线程A进入临界区内处理时，其他想要进临界区的线程会阻塞。这种状况称为<code>线程冲突（conflict）</code>。<br>发生冲突时，程序的整体性能会随线程等待时间的增加而下降。</p>
</li>
</ul>
<blockquote>
<p>不容易发生线程冲突的<code>ConcurrentHashMap</code>：<br><strong>ConcurrentHashMap将内部数据结构分成多段，针对各段操作的线程互不干涉，因此无需针对其他线程执行互斥处理</strong>。</p>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>模拟三个人频繁地通过一个门，且该门一次只允许一个人经过的场景。<br>当人从该门通过时，统计人数会增加，同时还会记录通行者的姓名和出生地。</p>
<h3 id="不使用Single-Threaded-Execution模式"><a href="#不使用Single-Threaded-Execution模式" class="headerlink" title="不使用Single Threaded Execution模式"></a>不使用Single Threaded Execution模式</h3><p>面对该需求，如果不使用Single Thread Execution模式，在多线程环境下无法正确执行的程序会引发什么现象？<br>将该程序设计为三个类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>创建门，并让三个人不断通过的类</td>
</tr>
<tr>
<td>Gate</td>
<td>表示门的类。会记录通行者的姓名和出生地</td>
</tr>
<tr>
<td>UserThread</td>
<td>表示人的类。将不断有人通过门</td>
</tr>
</tbody></table>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.demo.single_thread_execution;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建门，并让三个人不断通过的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 15:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于Gate是非线程安全的，所以输出结果是混乱的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试开始，按[Ctrl + C]键退出"</span>);</span><br><span class="line">        <span class="comment">// 创建一个门，让三个人不断地通过</span></span><br><span class="line">        Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">        <span class="keyword">new</span> UserThread(gate,<span class="string">"A小王"</span>, <span class="string">"A北京"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> UserThread(gate,<span class="string">"B小李"</span>, <span class="string">"B上海"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> UserThread(gate,<span class="string">"C小苏"</span>, <span class="string">"C南京"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Gate类"><a href="#Gate类" class="headerlink" title="Gate类"></a>Gate类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示门的类。会记录通行者的姓名和出生地</span></span><br><span class="line"><span class="comment"> * 非线程安全/pass/toString方法加synchronized为线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 15:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示到目前为止已经通过这道门的人数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的姓名</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"NoBody"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的出生地</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"NoWhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示通过门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 在name和address赋值之间调用sleep，延长临界区，可以提高检查出错误的可能性，不需等数万次执行才发现。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查门的最后一个通行者的记录数据是否正确。</span></span><br><span class="line"><span class="comment">     * 注意：不需要添加synchronized。</span></span><br><span class="line"><span class="comment">     * 因为check方法只有pass方法会调用。且时私有的，也就是不会被其他类调用，所以是安全的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如姓名和首字母不同，说明数据异常</span></span><br><span class="line">        <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*** 异常 *** :"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": name='"</span> + name + <span class="string">", address="</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UserThread类"><a href="#UserThread类" class="headerlink" title="UserThread类"></a>UserThread类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.demo.single_thread_execution;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示人的类。将不断有人通过门</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 16:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserThread</span><span class="params">(Gate gate, String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gate = gate;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" BEGIN"</span>);</span><br><span class="line">        <span class="comment">// 反复调pass方法，表示这个人在门里不断地穿梭通过</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gate.pass(<span class="keyword">this</span>.name, <span class="keyword">this</span>.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>由于Gate是非线程安全的，pass方法会被多个线程执行。</p>
<ul>
<li>线程改写共享的实例字段时，并未考虑其他线程的操作。</li>
<li>对于name字段，互相竞争的线程获取的一方会先写入值，对于address同样如此，线程会再次竞争，获胜的一方先写入值。也就是所谓的<code>数据竞争</code>（Data Race）。</li>
</ul>
<p>所以输出结果是混乱的。<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** 异常 *** :No.88434: name&#x3D;&#39;A小王, address&#x3D;B上海</span><br><span class="line">*** 异常 *** :No.88657: name&#x3D;&#39;A小王, address&#x3D;C南京</span><br><span class="line">*** 异常 *** :No.88828: name&#x3D;&#39;C小苏, address&#x3D;C南京</span><br></pre></td></tr></table></figure>

<p>由上面执行日志可知：</p>
<ul>
<li>Gate类是非线程安全的。</li>
<li>测试无法证明安全性。<br>执行了上万次才发现异常，如仅执行几次就可能发现不了。</li>
<li>调试信息不可靠。<br>如：<code>*** 异常 *** :No.88828: name=&#39;C小苏, address=C南京</code>，输出了异常日志，但check验证的toString内容是正确的，好像并没有错误。</li>
</ul>
<p><strong>因为某个线程在执行check方法时，其他线程不断地执行pass方法，改写了name和address的值。</strong></p>
<h3 id="使用Single-Threaded-Execution模式"><a href="#使用Single-Threaded-Execution模式" class="headerlink" title="使用Single Threaded Execution模式"></a>使用Single Threaded Execution模式</h3><p>该案例在不使用Single Threaded Execution模式时，即Gate是非线程安全的类时，会出现数据竞争的情况，导致不符合程序执行的安全性标准。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>将Gate类修改为线程安全的类，只需要分别在pass方法和toString方法前添加synchronized关键字，这样Gate类就变成了线程安全的类。<br>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示门的类。会记录通行者的姓名和出生地</span></span><br><span class="line"><span class="comment"> * 非线程安全/pass/toString方法加synchronized为线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 15:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示到目前为止已经通过这道门的人数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的姓名</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"NoBody"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的出生地</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"NoWhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示通过门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 在name和address赋值之间调用sleep，延长临界区，可以提高检查出错误的可能性，不需等数万次执行才发现。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查门的最后一个通行者的记录数据是否正确。</span></span><br><span class="line"><span class="comment">     * 注意：不需要添加synchronized。</span></span><br><span class="line"><span class="comment">     * 因为check方法只有pass方法会调用。且时私有的，也就是不会被其他类调用，所以是安全的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如姓名和首字母不同，说明数据异常</span></span><br><span class="line">        <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*** 异常 *** :"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一般来说，多个线程共享的字段必须使用synchronized或者volatile来保护。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设当线程A正在执行pass方法时，其他线程B调用了toString方法。</span></span><br><span class="line"><span class="comment">     * 在线程B引用了name字段的值，但尚未引用address期间，线程A可能会修改address的值。</span></span><br><span class="line"><span class="comment">     * 这样，toString方法对线程B创建时使用name和address对首字母就可能会不一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": name='"</span> + name + <span class="string">", address="</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，无论等待多久，都不会出现异常情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试开始，按[Ctrl + C]键退出</span><br><span class="line">A小王 BEGIN</span><br><span class="line">B小李 BEGIN</span><br><span class="line">C小苏 BEGIN</span><br></pre></td></tr></table></figure>

<p>因为：<br>Java使用关键字synchronized来实现执行线程的互斥处理。 <strong>在方法前加synchronized关键字，每次只允许一个线程处理该方法。</strong></p>
<p>针对该案例添加了synchronized方法：在线程A执行pass方法时，线程B就无法再执行pass方法，会阻塞在pass方法的入口处，直到线程A执行释放了pass方法的锁，线程B才可以去获取pass方法的锁，获得锁后再执行。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="相关的设计模型"><a href="#相关的设计模型" class="headerlink" title="相关的设计模型"></a>相关的设计模型</h3><p>许多与多线程、并发性相关的模式都跟Single Threaded Execution模式有关联。</p>
<h4 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h4><p>Guarded Suspension模式：<strong>如果执行现在的处理会造成问题，就让执行处理的线程等待</strong>。这种模式通过让线程等待来保证实例的安全性。</p>
<p>在Single Threaded Execution模式中，是否发生线程等待取决于<strong>是否有其他线程正在执行受保护的unsafeMethod</strong>。<br>而在Guarded Suspension模式中，取决于<strong>对象的状态是否合适</strong>。在检查对象状态的部分就使用了STE模式。</p>
<h4 id="Read-Write-Lock模式"><a href="#Read-Write-Lock模式" class="headerlink" title="Read-Write Lock模式"></a>Read-Write Lock模式</h4><p>在Read-Write Lock模式中，<code>读取操作和写入操作是分开考虑的。在执行读取操作之前，线程必须获取用于读取的锁；在执行写入操作之前，线程必须获取用于写入的锁</code>。所以：</p>
<ul>
<li><strong>当一个线程在读取时，其他线程可以读取，但是不可以写入</strong>。</li>
<li><strong>当一个线程正在写入时，其他线程不可以读取或写入</strong>。<br>因为执行互斥处理会降低程序的性能，但是如果把写入的互斥处理和读取的互斥处理分开来考虑，就可以提高系统性能。</li>
</ul>
<p>在STE模式中，如受保护的unsafeMethod正在被一个线程执行，那么想要执行该方法的其他线程必须等待该线程执行结束。</p>
<p>而Read-Write Lock模式中，多个线程可以同时执行read方法，这时需要等待的只有想要执行的write方法的线程。<br>在Read-Write Lock模式中，检查线程种类和个数部分，就使用了STE模式。</p>
<h4 id="Immutable模式"><a href="#Immutable模式" class="headerlink" title="Immutable模式"></a>Immutable模式</h4><p><strong>一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变模式。</strong><br>在STE模式中，unsafeMethod必须要加以保护，确保只允许一个线程执行。<br>而在Immutable不变模式中，其对象的状态不会发生变化，所以所有方法都不需要进行保护，也就是<code>Immutable模式中的所有方法都是safeMethod</code>。</p>
<h4 id="Thread-Specific-Storage模式"><a href="#Thread-Specific-Storage模式" class="headerlink" title="Thread-Specific Storage模式"></a>Thread-Specific Storage模式</h4><p>在STE模式中，会有多个线程访问SharedResource角色，所以需要保护方法，对线程进行交通管制。<br>而<code>Thread-Specific Storage模式会确保每个线程都有其固有的区域，且这块固有区域仅由一个线程访问</code>。所以也无需保护方法。<br>如:<code>ThreadLocal类</code> 一个线程会有自己独立的储物柜。</p>
<h3 id="信号量：Semaphore"><a href="#信号量：Semaphore" class="headerlink" title="信号量：Semaphore"></a>信号量：Semaphore</h3><p>STE模式用于确保某个区域只能由一个线程来执行。<br>如果保证某个区域<strong>最多只能由N个线程执行</strong>，那就需要使用juc包下的计数信号量Semaphore来控制线程数量。</p>
<ul>
<li><code>资源的许可个数permits</code>通过Semaphore的构造函数来制定：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>acquire方法</code>：用于确保存在可用资源。<br>在存在可用资源时，程序会立即从acquire方法返回，同时信号量内部的资源个数会减1.<br>如无可用资源，线程则阻塞在acquire方法内，直到有可用资源。</li>
<li><code>release方法</code>：用于释放资源。<br>释放资源后，信号量内部的资源个数会加1。<br>同时，如果acquire中存在等待的线程，那么其中一个线程会被唤醒，并从acquire方法返回。</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>10个线程交替使用资源，但同时使用的资源最多只能是3个。</p>
<ul>
<li>Main类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置3个资源</span></span><br><span class="line">        BoundedResource resource = <span class="keyword">new</span> BoundedResource(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 10个线程交替使用资源，但同时使用的资源最多只能是3个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> UserThread(resource).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: -&gt; Begin: used &#x3D; NO.1</span><br><span class="line">Thread-1: -&gt; Begin: used &#x3D; NO.2</span><br><span class="line">Thread-2: -&gt; Begin: used &#x3D; NO.3</span><br><span class="line">Thread-2: &lt;--- End: used &#x3D; NO.3</span><br><span class="line">Thread-3: -&gt; Begin: used &#x3D; NO.3</span><br><span class="line">Thread-0: &lt;--- End: used &#x3D; NO.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UserThread用户线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BoundedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserThread</span><span class="params">(BoundedResource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.resource.use();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">3000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BoundedResource使用资源类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> permits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedResource</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(permits);</span><br><span class="line">        <span class="keyword">this</span>.permits = permits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Log.println(<span class="string">"-&gt; Begin: used = NO."</span> + (<span class="keyword">this</span>.permits - <span class="keyword">this</span>.semaphore.availablePermits()));</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">        Log.println(<span class="string">"&lt;--- End: used = NO."</span> + (<span class="keyword">this</span>.permits - <span class="keyword">this</span>.semaphore.availablePermits()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Log日志类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
            <div class="article_footer">
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class="content article-entry">
    
      
        <div class="fancybox"><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/pay.jpeg" height="300px"></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class="meta" id="footer-meta">
    <div class="new-meta-box">
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-08-18T15:25:09+08:00">
  <a class="notlink">
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020年8月18日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item category">
    <a href="/categories/Java/%E5%B9%B6%E5%8F%91/" rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java/并发</p>
    </a>
  </div>


        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%B9%B6%E5%8F%91/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>并发</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bubblewu.github.io/ckd8g12ck0000v1yd2ymng4um/&title=并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人 - 大泡泡的笔记&summary=Single Threaded Execution模式，即&quot;以一个线程执行&quot;。就像独木桥一样，同一时间内只允许一个人通过，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。

其实主要思想也就是：

当我们修改多个线程共享的实例时，实例就会失去安全性。所以我们找出这个不安全的范围，将这个范围设置为临界区，并对临界区进行保护（使用synchronized），使其只允许一个线程同时执行。" target="_blank">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://bubblewu.github.io/ckd8g12ck0000v1yd2ymng4um/&title=并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人 - 大泡泡的笔记&summary=Single Threaded Execution模式，即&quot;以一个线程执行&quot;。就像独木桥一样，同一时间内只允许一个人通过，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。

其实主要思想也就是：

当我们修改多个线程共享的实例时，实例就会失去安全性。所以我们找出这个不安全的范围，将这个范围设置为临界区，并对临界区进行保护（使用synchronized），使其只允许一个线程同时执行。" target="_blank">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=https://bubblewu.github.io/ckd8g12ck0000v1yd2ymng4um/&title=并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人 - 大泡泡的笔记&summary=Single Threaded Execution模式，即&quot;以一个线程执行&quot;。就像独木桥一样，同一时间内只允许一个人通过，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。

其实主要思想也就是：

当我们修改多个线程共享的实例时，实例就会失去安全性。所以我们找出这个不安全的范围，将这个范围设置为临界区，并对临界区进行保护（使用synchronized），使其只允许一个线程同时执行。" target="_blank">
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
      
        
        <div class="hoverbox">
          <a><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/wechat.png"></a>
          <div class="target">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATgAAAE4CAAAAADqFLC2AAADt0lEQVR42u3aQXLCMAwFUO5/abpvh4m+5BTBPO8ISW0/s/iV8ngarfFAAA4cOHAGOHBL4B7N8er539dfff6zoIt5qvdX19HeLzhw4MCBAwcO3DK4cgAMN1R9PoWeHlB3v+DAgQMHDhw4cFvhTgfKu8BPB/Py/eDAgQMHDhw4cF8CVw2Q1Q2mhcXqPsCBAwcOHDhw4MDNguyphvK00AoOHDhw4MCBA/dtcN0GcPX6tMF9FYCn8P/WyQcHDhw4cODAgTsE1y0kfurn9n7BgQMHDhw4cOCWwN01po3kbvBOA3i8L3DgwIEDBw4cuCVw72o4T4N293r3gMCBAwcOHDhw4LbCnXqRsAoxDcDdhnj34MGBAwcOHDhw4D4FrtrInQbP7sZOFT7jgwUHDhw4cODAgVsGd1fjNz2AbuBODyqdFxw4cODAgQMHbjtcOkEaVO8KttPCZxkeHDhw4MCBAwduCVx3A3c1kO8qiKbB+7IhDQ4cOHDgwIEDtwyuuuFqgJwWSFOI6fougcGBAwcOHDhw4JbBdSdOXzjsvsg4LUR2X5R82ZAGBw4cOHDgwIFbCndqId3C5TTgng7G4MCBAwcOHDhwW+G6Dd9TgfVUAbUbrMvPgwMHDhw4cODALYO7grm6Hjd2w0b0dB0pbPyfAzhw4MCBAwcO3D/DnQqu3YDcDbBpcE+BLhvS4MCBAwcOHDhwb4ZLRwqdNobTAJx+P4UEBw4cOHDgwIHbBtct8HUbzlPoKVz6QwEHDhw4cODAgdsGNw2c1ftToGlQrh5oHIzBgQMHDhw4cOA+BC4NjKca0tPr0wO6LGSCAwcOHDhw4MAtgUuD7bTweCrwdguo6cGDAwcOHDhw4MBtg0sfTAuB3aA8nXdaeC138sGBAwcOHDhw4N4E131BcBp00wDdDeDd/YEDBw4cOHDgwG2H6wbaNHB2C5GnDi4Ouq/uAwcOHDhw4MCBWwJ3aiHlhm4YsJ/DcSoYgwMHDhw4cODAbYM7tbA0OKcHlIKkB1VeJzhw4MCBAwcO3BK4aUO3W7hMgbsBtrre8g8DHDhw4MCBAwduGVw38E7vSwuf3WA8nRccOHDgwIEDB2473LQBPQ3OpwqVp4JzOQCDAwcOHDhw4MB9OFw3WJ4KtFWA9oGDAwcOHDhw4MB9Cdw0kFYb2d1gfOp7cODAgQMHDhy47XCnGsenGtrdg+oWTC/XBQ4cOHDgwIEDtwyu28C9u9CZwlT/Xns94MCBAwcOHDhwS+CMbIADBw4cOAMcuDePH+3cfcRsK600AAAAAElFTkSuQmCC">
          </div>
        </div>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class="prev" href="/ckde6cvxs0000a5yd0wtz6h6h/">
                <p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>并发模式-2：Immutable不变模式</p>
                <p class="content">Immutable不变模式就是指：确保实例的内部状态不会发生改变，这样在访问这些实例时就不需要增加耗时的互斥处理（如Single Threaded Execution模式中的对临界区进行互斥保护...</p>
              </a>
            
            
              <a class="next" href="/ckd70wo7j0017qlydgj2w1nq3/">
                <p class="title">并发：多线程程序的评价标准<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class="content">针对多线程程序，我们不能单纯的来指出是好还是坏，需要遵循一定的评价标准来规范的指出好在哪里、差在哪里？
其实也就是：

安全性和生存性：程序的必要条件；
可复用性和性能：提高程序质量条件；


...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    
  
    
    
  

  <section class="widget related_posts shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-bookmark fa-fw" aria-hidden="true"></i><span class="name">相关文章</span>
    
  </header>


    <div class="content">
      <ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/ckd70wo7j0017qlydgj2w1nq3/" title="并发：多线程程序的评价标准" rel="bookmark">并发：多线程程序的评价标准</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/ckde6cvxs0000a5yd0wtz6h6h/" title="并发模式-2：Immutable不变模式" rel="bookmark">并发模式-2：Immutable不变模式</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/ckdzm6t9500009eyd7mgih05q/" title="并发模式-3：Guarded Suspension模式：保护暂停" rel="bookmark">并发模式-3：Guarded Suspension模式：保护暂停</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/ckdzpgvtp0000e7ydh7rl9onx/" title="并发模式-5：Producer-Consumer模式：生产者消费者" rel="bookmark">并发模式-5：Producer-Consumer模式：生产者消费者</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/ckdzpgvu20005e7yd6yeper0b/" title="并发模式-4：Balking模式：停止并返回" rel="bookmark">并发模式-4：Balking模式：停止并返回</a></h3></div></li></ul>
    </div>
  </section>


  


  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class="fas fa-comments"></i> 评论</p>
      
      
      
      
        <section id="comments">
          <div id="gitalk-container"></div>
        </section>
      
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人',
      tools: true
    }
  </script>


</div>
<aside class="l_side">
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class="content">
    
      
        <a class="avatar flat-box" href="/about/">
          <img no-lazy src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/bubble.png">
        </a>
      
    
    
      <div class="text">
        
        
        
          <p><span id="jinrishici-sentence">大泡泡的笔记</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:752820344@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/bubblewu" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span>
    
  </header>


    <div class="content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Single-Threaded-Execution模式"><span class="toc-number">1.</span> <span class="toc-text">Single Threaded Execution模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候使用？"><span class="toc-number">1.2.</span> <span class="toc-text">什么时候使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全性和synchronized"><span class="toc-number">1.3.</span> <span class="toc-text">安全性和synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生存性和死锁"><span class="toc-number">1.4.</span> <span class="toc-text">生存性和死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可复用性和继承反常"><span class="toc-number">1.5.</span> <span class="toc-text">可复用性和继承反常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区的大小和性能"><span class="toc-number">1.6.</span> <span class="toc-text">临界区的大小和性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#案例"><span class="toc-number">2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不使用Single-Threaded-Execution模式"><span class="toc-number">2.1.</span> <span class="toc-text">不使用Single Threaded Execution模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-number">2.1.1.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Main类"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Main类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Gate类"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Gate类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UserThread类"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">UserThread类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结果"><span class="toc-number">2.1.2.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Single-Threaded-Execution模式"><span class="toc-number">2.2.</span> <span class="toc-text">使用Single Threaded Execution模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">3.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关的设计模型"><span class="toc-number">3.1.</span> <span class="toc-text">相关的设计模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Guarded-Suspension模式"><span class="toc-number">3.1.1.</span> <span class="toc-text">Guarded Suspension模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-Write-Lock模式"><span class="toc-number">3.1.2.</span> <span class="toc-text">Read-Write Lock模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Immutable模式"><span class="toc-number">3.1.3.</span> <span class="toc-text">Immutable模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-Specific-Storage模式"><span class="toc-number">3.1.4.</span> <span class="toc-text">Thread-Specific Storage模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量：Semaphore"><span class="toc-number">3.2.</span> <span class="toc-text">信号量：Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#案例-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="mailto:752820344@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/bubblewu" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        本站使用
        <a href="https://volantis.js.org/" target="_blank" class="codename">Bubble</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class="copyright">
        <p><a href="https://bubblewu.github.io/">Copyright © 2020-2222 Bubble</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('false' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('') {
          $('').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  








  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: "9c3ba30f68564e88ff5a",
      clientSecret: "96fdc1643060dc0b177fa05627e83eaba08781d8",
      repo: "hexo-blog",
      owner: "bubblewu",
      admin: "bubblewu",
      
        id: location.pathname,      // Ensure uniqueness and length less than 50
      
      distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
  </script>







  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>
