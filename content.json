{"meta":{"title":"大泡泡的笔记","subtitle":"记录平时工作过程中的学习点滴","description":"Java、Python、机器学习、深度学习、推荐系统、自然语言处理","author":"Bubble","url":"https://bubblewu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-06-08T06:59:37.716Z","updated":"2020-06-08T03:32:03.119Z","comments":true,"path":"404.html","permalink":"https://bubblewu.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 向博主反馈问题"},{"title":"个人简介","date":"2020-06-08T09:17:17.877Z","updated":"2020-06-08T09:17:17.868Z","comments":true,"path":"about/index.html","permalink":"https://bubblewu.github.io/about/index.html","excerpt":"记录工作过程中的点滴！","text":"记录工作过程中的点滴！ 本Blog主要用来记录工作过程中的点滴！ 联系博主"},{"title":"我的朋友们","date":"2020-06-08T06:59:37.720Z","updated":"2020-06-08T03:32:03.130Z","comments":false,"path":"friends/index.html","permalink":"https://bubblewu.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"Android SDK","date":"2020-06-08T09:11:17.985Z","updated":"2020-06-08T03:32:03.128Z","comments":true,"path":"adb/index.html","permalink":"https://bubblewu.github.io/adb/index.html","excerpt":"","text":"Android SDK SDK:(software development kit) &nbsp;&nbsp;&nbsp;&nbsp;被软件开发工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。因此，Android SDK 指的是Android专属的软件开发工具包。 Start Learning"},{"title":"","date":"2020-06-08T06:59:37.715Z","updated":"2020-06-08T03:32:03.130Z","comments":true,"path":"list/index.html","permalink":"https://bubblewu.github.io/list/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-08T06:59:37.709Z","updated":"2020-06-08T03:32:03.131Z","comments":true,"path":"tags/index.html","permalink":"https://bubblewu.github.io/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-05-20T15:25:38.000Z","updated":"2020-06-08T03:32:03.131Z","comments":true,"path":"msgboard/index.html","permalink":"https://bubblewu.github.io/msgboard/index.html","excerpt":"","text":""},{"title":"Contributors「鸣谢」","date":"2020-06-09T02:16:51.775Z","updated":"2020-06-08T03:32:03.130Z","comments":true,"path":"contributors/index.html","permalink":"https://bubblewu.github.io/contributors/index.html","excerpt":"","text":"特别鸣谢 hexo 开发者和 volantis 开发者！ Hexo volantis"},{"title":"所有分类","date":"2020-06-09T02:28:09.039Z","updated":"2020-06-08T03:32:03.130Z","comments":true,"path":"categories/index.html","permalink":"https://bubblewu.github.io/categories/index.html","excerpt":"","text":""},{"title":"2. 连接调试","date":"2020-05-17T08:02:45.000Z","updated":"2020-06-08T03:32:03.128Z","comments":true,"path":"adb/debug/index.html","permalink":"https://bubblewu.github.io/adb/debug/index.html","excerpt":"","text":"win12345678910# 什么进程占用了 5037netstat -ano | findstr \"5037\"# 结果显示进程PID 21152（示例）# 查看进程是哪个程序启动的这个进程（21152为进程PID）tasklist | findstr \"21152\"#结果显示 某个服务# 杀进程taskkill /f /pid 21152 mac1234567891011# 什么进程占用了 5037netstat -an|grep 5037# 查看进程是哪个程序启动的这个进程（21152为进程PID）lsof -i :5037# 杀进程(PID为53067的进程)kill -9 53067# psps -ef | grep 5037"},{"title":"4. 玩转pm命令","date":"2020-05-17T13:05:23.000Z","updated":"2020-06-08T03:32:03.129Z","comments":true,"path":"adb/pm/index.html","permalink":"https://bubblewu.github.io/adb/pm/index.html","excerpt":"","text":"获取设备app包名称列表1adb shell pm list package # 列出安装在设备上应用的包名 获取设备app包名称列表, 只显示系统应用1adb shell pm list package -s # 列出安装在设备上应用的包名 获取设备app包名称列表, 只显示三方应用1adb shell pm list package -3 # 列出安装在设备上应用的包名 列出应用包名及对应的apk名及存放位置1adb shell pm list package -f # 列出安装在设备上应用的包名 列出应用包名及其安装来源1adb shell pm list package -i 查看APP详细信息1adb shell pm dump &lt;package_name&gt; # 例如：com.jd.xxxx 安装apk1adb shell pm install &lt;apk_path&gt; # 目标 apk 存放于 Android 设备上(，请用 pm install 安装) 卸载apk1adb shell pm uninstall &lt;package_name&gt; 清除APP数据和缓存1adb shell pm clear &lt;package_name&gt; 重置所有APP权限1adb shell pm reset 查看帮助文档1adb shell pm"},{"title":"3. apk安装&卸载","date":"2020-05-17T12:35:53.000Z","updated":"2020-06-08T03:32:03.129Z","comments":true,"path":"adb/installapk/index.html","permalink":"https://bubblewu.github.io/adb/installapk/index.html","excerpt":"","text":"安装(adb install)1234567891011121314# 普通安装adb install &lt;apk_path&gt;# 覆盖安装adb install -r &lt;apk_path&gt;# 安装debug包adb install -t &lt;apk_path&gt;# 降级安装adb install -d &lt;apk_path&gt; # 只针对debug包，对release包无效# 针对特定设备安装(多设备同时连接电脑时)adb -s &lt;devices_id&gt; install &lt;apk_path&gt; 卸载(adb uninstall)12345# 普通卸载adb uninstall &lt;package_name&gt; # 例如: com.jd.xxx# 针对特定设备卸载(多设备同时连接电脑时)adb -s &lt;devices_id&gt; uninstall &lt;package_name&gt; # 例如: com.jd.xxx 自动化下的安装卸载(pm命令)12345# 安装apkpm install &lt;device_apk_path&gt; # device_apk_path为手机路径 /sdcard# 卸载apkpm install &lt;package_name&gt; # 例如: com.jd.xxx pm 更多用法"},{"title":"1. SDK下载安装","date":"2020-05-17T06:59:42.000Z","updated":"2020-06-08T03:32:03.129Z","comments":true,"path":"adb/sdk/index.html","permalink":"https://bubblewu.github.io/adb/sdk/index.html","excerpt":"","text":"下载Android SDK下载地址：https://www.androiddevtools.cn官方地址：http://developer.android.com/sdk点击Android SDK工具，选择SDK，按不同系统下载对应版本 安装Android SDK打开Android SDK文件夹，点击SDK Manager，只勾选platform-tools、build-tools、tools三个工具安装即可 环境变量配置1234567# win 编辑环境变量ANDROID_HOME=&lt;android-sdk的path目录路径&gt; # 新增ANDROID_HOMEPATH=$ANDROID_HOME/bin;$ANDROID_HOME/platform-tools;$ANDROID_HOME/build-tools;$ANDROID_HOME/tools# mac 修改.bashrc或.zshrc(zsh使用者)export ANDROID_HOME=&lt;android-sdk的path目录路径&gt;export CLASSPATH=.:$ANDROID_HOME/bin;$ANDROID_HOME/platform-tools;$ANDROID_HOME/build-tools;$ANDROID_HOME/tools"}],"posts":[{"title":"基于Neo4j的时光网电影数据可视化【附源码】","slug":"Neo4j/基于Neo4j的时光网电影数据可视化【附源码】","date":"2020-06-11T12:32:19.000Z","updated":"2020-06-11T12:51:42.655Z","comments":true,"path":"ckbarwdyc0000z5yd8tl0cjqn/","link":"","permalink":"https://bubblewu.github.io/ckbarwdyc0000z5yd8tl0cjqn/","excerpt":"基于Neo4j的电影数据可视化本文主要内容为： 基于requests + BeautifulSoup抓取时光网电影数据； 基于电影数据构建电影和关系实体信息； 数据导入neo4j进行存储分析； 基于Bottle框架的对neo4j数据进行查询可视化展示。 效果展示：","text":"基于Neo4j的电影数据可视化本文主要内容为： 基于requests + BeautifulSoup抓取时光网电影数据； 基于电影数据构建电影和关系实体信息； 数据导入neo4j进行存储分析； 基于Bottle框架的对neo4j数据进行查询可视化展示。 效果展示： 环境配置新建虚拟环境并安装所需包 新建虚拟环境：12345678# 查看本机已经安装的python虚拟环境conda env list# 新建graph-37环境conda create -n graph-37 python&#x3D;3.7# 生效新建的虚拟环境conda activate graph-37## 退出#conda deactivate 安装所需包：根据requirements.txt文件来安装：1pip install -r requirements.txt requirements.txt文件：12345678910111213141516171819202122232425beautifulsoup4&#x3D;&#x3D;4.9.1bs4&#x3D;&#x3D;0.0.1certifi&#x3D;&#x3D;2020.4.5.1chardet&#x3D;&#x3D;3.0.4Click&#x3D;&#x3D;7.0colorama&#x3D;&#x3D;0.4.3et-xmlfile&#x3D;&#x3D;1.0.1idna&#x3D;&#x3D;2.9jdcal&#x3D;&#x3D;1.4.1lxml&#x3D;&#x3D;4.5.1neobolt&#x3D;&#x3D;1.7.17neotime&#x3D;&#x3D;1.7.4numpy&#x3D;&#x3D;1.18.5openpyxl&#x3D;&#x3D;3.0.3pandas&#x3D;&#x3D;1.0.4prompt-toolkit&#x3D;&#x3D;2.0.10py2neo&#x3D;&#x3D;4.3.0Pygments&#x3D;&#x3D;2.3.1python-dateutil&#x3D;&#x3D;2.8.1pytz&#x3D;&#x3D;2020.1requests&#x3D;&#x3D;2.23.0six&#x3D;&#x3D;1.15.0soupsieve&#x3D;&#x3D;2.0.1urllib3&#x3D;&#x3D;1.24.3wcwidth&#x3D;&#x3D;0.2.4 数据获取本文数据来自时光网电影Top100。基于python对该源进行数据抓取，并将数据生成相应的实体和关系：可参考：GitHub：时光网数据抓取处理 实体和关系如下：： 电影： 1234index:ID,rank,src,name,movie_en,year,image,:LABEL10000,1,http:&#x2F;&#x2F;movie.mtime.com&#x2F;12231&#x2F;,肖申克的救赎,The Shawshank Redemption,1994,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;03&#x2F;07&#x2F;123549.37376649_96X128.jpg,电影表10001,2,http:&#x2F;&#x2F;movie.mtime.com&#x2F;99547&#x2F;,盗梦空间,Inception,2010,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;01&#x2F;06&#x2F;105446.89493583_96X128.jpg,电影表... 演员： 123456index:ID,actor,:LABEL30000,杰伊·巴鲁切尔,演员表30001,维果·莫腾森,演员表30002,布拉德·皮特,演员表30003,李·科布,演员表... 导演： 123456index:ID,director,:LABEL20000,彼得·索恩,导演表20001,克里斯托弗·诺兰,导演表20002,朴赞郁,导演表20003,赛尔乔·莱昂内,导演表... 关系： 电影与导演关系： 12345:START_ID,:END_ID,relation,:TYPE20069,10000,导演,导演20001,10001,导演,导演20010,10002,导演,导演... 电影与主演关系： 123456:START_ID,:END_ID,relation,:TYPE30156,10000,主演,主演30026,10000,主演,主演30063,10001,主演,主演30031,10001,主演,主演... 导演和演员关系： 12345:START_ID,:END_ID,relation,:TYPE20069,30156,相关,相关20069,30026,相关,相关20001,30063,相关,相关... Neo4j存储数据导入必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。 通过下面的命令导入定义好的实体和关系数据： 123456789101112131415161718192021222324252627282930313233#!&#x2F;bin&#x2F;sh# 脚本来执行将csv文件（节点和关系）导入neo4j# 注意：必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。db_name&#x3D;MovieMTime.dbneo4j_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4base_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;code&#x2F;python&#x2F;moive-kg&#x2F;data&#x2F;mtimeimport() &#123; cd $&#123;neo4j_path&#125; .&#x2F;bin&#x2F;neo4j stop rm -rf &#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4&#x2F;data&#x2F;databases&#x2F;$&#123;db_name&#125; .&#x2F;bin&#x2F;neo4j-admin import --verbose \\ --database $&#123;db_name&#125; \\ --id-type STRING \\ --input-encoding&#x3D;UTF-8 \\ --ignore-extra-columns&#x3D;false \\ --trim-strings&#x3D;true \\ --delimiter&#x3D;, \\ --array-delimiter&#x3D;&#39;;&#39; \\ --processors&#x3D;4 \\ --nodes $&#123;base_path&#125;&#x2F;mtime_movie_entity.csv \\ --nodes $&#123;base_path&#125;&#x2F;mtime_actor_entity.csv \\ --nodes $&#123;base_path&#125;&#x2F;mtime_director_entity.csv \\ --relationships $&#123;base_path&#125;&#x2F;mtime_director_actor_relationship.csv \\ --relationships $&#123;base_path&#125;&#x2F;mtime_movie_actor_relationship.csv \\ --relationships $&#123;base_path&#125;&#x2F;mtime_movie_director_relationship.csv # 需要修改neo4j.conf配置文件中的默认db才能展示新建的db，否则还是默认的。（只能指定一个db）# .&#x2F;bin&#x2F;neo4j start# .&#x2F;bin&#x2F;neo4j stop&#125;import 数据查看修改配置将默认db改为刚才新建的电影的db，否则还是默认的库。vim conf/neo4j.conf 1dbms.active_database&#x3D;MovieMTime.db 启动neo4j服务（neo4j版本为4.0.3）: 1.&#x2F;bin&#x2F;neo4j start 进入管理界面：http://127.0.0.1:7474 查看实体数据： 查看关系数据： 数据查询可视化查询可视化基于Bottle框架的Web服务。参考：GitHub: 可视化 效果如下图： 源码地址 movie-neo4j","categories":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/categories/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/categories/Python/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/tags/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/tags/Python/"}]},{"title":"001 运行时数据区域和OutOfMemoryError异常","slug":"Java/JVM/001 运行时数据区域和OutOfMemoryError异常","date":"2020-06-09T02:52:19.000Z","updated":"2020-06-09T06:21:37.368Z","comments":true,"path":"ckbarvw2z0045yayd50uf5v6u/","link":"","permalink":"https://bubblewu.github.io/ckbarvw2z0045yayd50uf5v6u/","excerpt":"本文主要讲解JVM运行时数据区域，并通过简单的案例来实现说明各个区域中的常见OOM异常。","text":"本文主要讲解JVM运行时数据区域，并通过简单的案例来实现说明各个区域中的常见OOM异常。 运行时数据区域运行时数据区域图： Java内存区域：JVM内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法栈】、线程共享区域【Java堆、方法区】、直接内存。 线程私有区域：线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM内,每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 线程共享区域：线程共享区域随虚拟机的启动/关闭而创建/销毁。 JVM主要区域溢出异常在Java虚拟机规范中规定，除了程序计数器外，虚拟机的其他几个运行时区域都有发生OOM异常的可能，如：方法区（运行时常量池）、Java堆、虚拟机栈（局部变量表）、本地方法栈和直接内存。 下面将通过案例来验证各个运行时区域的溢出异常，并分析我们来如何解决和避免这些异常。 注：下面的代码基于JDK8进行开发测试； 线程独占区程序计数器（无OOM）程序计数器（Program Counter Register）是一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为线程私有的内存。 正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。 如果是Native方法，则为空（undefined）。 这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError 情况的区域。 虚拟机栈和本地方法栈溢出虚拟机栈虚拟机栈描述的是Java方法执行的线程内存模型。 栈帧（Stack Frame）：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：局部变量表存放了编译期可知的： 各种Java虚拟机基本数据类型：boolean、byte、char、short、int、 float、long、double； 对象引用 ：reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置； returnAddress类型：指向了一条字节码指令的地址。 这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示。其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。 两种异常：栈/堆溢出 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 虚拟机栈&amp;本地方法栈Java虚拟机栈（Java Virtual Machine Stack）和本地方法栈（Native Method Stacks）非常相似，都属于线程独占区，区别是： 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务； 本地方法栈为虚拟机使用到的本地方法（Native方法）服务； Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 虚拟机栈和本地方法栈溢出案例栈容量参数：-XssHotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。 栈/堆溢出的场景《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展。所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。 测试案例将实验范围限制在单线程中操作，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常： 使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 定义大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 单线程下：使用-Xss参数减少栈内存容量（SOF异常）12345678910111213141516171819202122232425262728/** * Java虚拟机栈和本地方法机栈异常（单线程操作下） * VM Args: -Xss160k（Mac 64Bit要求最低栈内存为160K） * 使用-Xss参数减少栈内存容量。 * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 * * @author wugang * date: 2020-06-04 15:23 **/public class VMStackSOF &#123; private int stackLength = 1; private void stackLeak() &#123; stackLength++; stackLeak(); &#125; public static void main(String[] args) &#123; VMStackSOF stackSOF = new VMStackSOF(); try &#123; stackSOF.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println(\"stack length: \" + stackSOF.stackLength); throw e; &#125; &#125;&#125; 输出： 1234stack length: 773Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.bubble.jvm.error.VMStackSOF.stackLeak(VMStackSOF.java:16)... 单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）1234567891011121314151617181920212223242526272829303132333435363738/** * Java虚拟机栈和本地方法机栈异常（单线程操作下） * 定义大量的本地变量，增大此方法帧中本地变量表的长度 * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 * * @author wugang * date: 2020-06-04 15:23 **/public class VMStackSOF02 &#123; private static int stackLength = 1; public static void test() &#123; long unused1, unused2, unused3, unused4, unused5, unused6, unused7, unused8, unused9, unused10, unused11, unused12, unused13, unused14, unused15, unused16, unused17, unused18, unused19, unused20, unused21, unused22, unused23, unused24, unused25, unused26, unused27, unused28, unused29, unused30, unused31, unused32, unused33, unused34, unused35, unused36, unused37, unused38, unused39, unused40, unused41, unused42, unused43, unused44, unused45, unused46, unused47, unused48, unused49, unused50, unused51, unused52, unused53, unused54, unused55, unused56, unused57, unused58, unused59, unused60, unused61, unused62, unused63, unused64, unused65, unused66, unused67, unused68, unused69, unused70, unused71, unused72, unused73, unused74, unused75, unused76, unused77, unused78, unused79, unused80, unused81, unused82, unused83, unused84, unused85, unused86, unused87, unused88, unused89, unused90, unused91, unused92, unused93, unused94, unused95, unused96, unused97, unused98, unused99, unused100; stackLength++; test(); unused1 = unused2 = unused3 = unused4 = unused5 = unused6 = unused7 = unused8 = unused9 = unused10 = unused11 = unused12 = unused13 = unused14 = unused15 = unused16 = unused17 = unused18 = unused19 = unused20 = unused21 = unused22 = unused23 = unused24 = unused25 = unused26 = unused27 = unused28 = unused29 = unused30 = unused31 = unused32 = unused33 = unused34 = unused35 = unused36 = unused37 = unused38 = unused39 = unused40 = unused41 = unused42 = unused43 = unused44 = unused45 = unused46 = unused47 = unused48 = unused49 = unused50 = unused51 = unused52 = unused53 = unused54 = unused55 = unused56 = unused57 = unused58 = unused59 = unused60 = unused61 = unused62 = unused63 = unused64 = unused65 = unused66 = unused67 = unused68 = unused69 = unused70 = unused71 = unused72 = unused73 = unused74 = unused75 = unused76 = unused77 = unused78 = unused79 = unused80 = unused81 = unused82 = unused83 = unused84 = unused85 = unused86 = unused87 = unused88 = unused89 = unused90 = unused91 = unused92 = unused93 = unused94 = unused95 = unused96 = unused97 = unused98 = unused99 = unused100 = 0; &#125; public static void main(String[] args) &#123; try &#123; test(); &#125; catch (Throwable e) &#123; System.out.println(\"stack length: \" + stackLength); throw e; &#125; &#125;&#125; 输出： 1234stack length: 8121Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.bubble.jvm.error.VMStackSOF02.test(VMStackSOF02.java:26)... 多线程下：OOM异常12345678910111213141516171819202122232425262728/** * 多线程下，Java虚拟机栈和本地方法栈OOM异常 * VM Args:-Xss2M * * @author wugang * date: 2020-06-04 16:38 **/public class VMStackOOM &#123; private void dontStop() &#123; while (true) &#123; &#125; &#125; public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(() -&gt; dontStop()); thread.start(); &#125; &#125; public static void main(String[] args) &#123; VMStackOOM vmStackOOM = new VMStackOOM(); vmStackOOM.stackLeakByThread(); &#125;&#125; 输出： 1Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create native thread 结论实验结果表明： 单线程下： 无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。如果在允许动态扩展栈容量大小的虚拟机上，相同代码则会导致不一样的情况，如第二个代码（定义大量的本地变量，增大此方法帧中本地变量表的长度）示例就会抛出OutOfMemoryError异常。 多线程下：如果通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的，如第三个代码。但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态。甚至可以说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 因为：操作系统分配给每个进程的内存是有限制的。如32位Windows的单个进程最大内存限制为2GB。HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，那剩余的内存（由虚拟机栈和本地方法栈来分配的内存）为2GB(操作系统限制)减去最大堆容量，再减去最大方法区容量。 注意：由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话。 因此为每个线程分配到的栈内存越大，可以建立的线程数量自 然就越少，建立线程时就越容易把剩下的内存耗尽。 通过减少内存的手段来解决内存溢出的方式：如果是建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，就只通过减少最大堆和减少栈容量来换取更多的线程。 线程共享区Java堆溢出概念Java堆（Java Heap）是虚拟机管理的内存中的最大一块区域，也是垃圾回收的主要区域，它属于线程共享区，用于存储对象实例。 Java堆时垃圾收集器管理的内存区域Java堆也被称为GC堆（Garbage Collected Heap）。 从回收内存角度来看：垃圾收集器大部分都是基于分代收集理论设计的，会有 新生代、老年代、永久代（JDK8改为元空间）、Eden空间、From Survivor空间、To Survivor空间等名词。这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。 从分配内存角度来看：所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB, Thread Local Allocation Buffer），可以提升对象分配时的效率。不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。 物理存储空间Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。 注意：但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。 配置参数Java堆可以设置为固定大小，也可以为可动态扩展的。通过参数-Xmx和-Xms来设定堆的最大和最小内存容量。将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展。 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 为什么会堆溢出？当我们不断地创建新对象时，并且使GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，这时候，对象数量不断增加，总容量超过最大堆的容量限制后，就会发生内存溢出异常。 OMM的两种情况可以通过内存映像分析工具对dump出的堆存储快照进行分析。首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。 内存泄露（Memory Leak）如果是内存泄漏（内存中的对象不是必须存活的，垃圾收集器未收集），可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。 内存溢出（Memory Overflow）如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当： 检查Java虚拟机的堆参数(-Xmx与-Xms)设置，与机器的内存对比，看看是否还有向上调整的空间。 再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。 溢出案例和dump快照分析使用虚拟机参数： 1VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError 限制Java堆的大小为20M B，不可扩展。通过参数-XX:+HeapDumpOnOutOf-MemoryError可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照，以便进行事后分析。(文件存储在该项目父目录下，如：java_pid80802.hprof) 12345678910111213141516/** * Java堆内存异常测试 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError **/public class JavaHeapOOM &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = Lists.newArrayList(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 输出： 1234567891011java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid80802.hprof ...Heap dump file created [27964242 bytes in 0.193 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:265) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231) at java.util.ArrayList.add(ArrayList.java:462) at com.bubble.jvm.error.JavaHeapOOM.main(JavaHeapOOM.java:23) 可以在目录/Users/wugang/code/java/multi-dev下看到java_pid80802.hprof文件。 分析dump文件：可以通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出来的堆转储快照进行分析，也可以通过JDK自带的工具jvisualvm来可视化分析。12# 控制行执行命令jvisualvm 会打开下面的窗口，打开对应的堆dump文件： 主要内容为：由上图可知：导致 OutOfMemoryError 异常错误的线程是 main 查看dump的类信息：由上图可知：dump文件记录的堆中的实例总大小约19M，指定的堆的固定大小为20M。 用第一行的实例大小除以百分比就能算出来：堆中实例大小：12965216B/1024/1024=12.36M，占了总大小的65%。堆中实例总大小：12.36M/0.65=19.02M 说明：dump文件中的实例列表其实是反映了使用的堆的情况，而使用的堆内存并没有达到预先设置的最大堆内存，只是在申请堆内存的过程中超出了预先设置的最大堆内存，然后内存溢出。 方法区和运行时常量池溢出方法区（Method Area）方法区与Java堆一样，属于线程共享区，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。 注意： 关于方法区和永久代（元空间）：在JDK8以前，很多人把方法区称呼为永久代（Permanent Generation，或将两者混为一谈。本质上这两者并不是等价的，仅因为HotSpot使用永久代来实现方法区而已，使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；而到了JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Metaspace)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。 参数JDK8之前：老年代（Permanent Gennration） 如：-XX:PermSize=10M 指定老年代的初始空间大小（10M），以字节为单位。 如：-XX:MaxPermSize=10M 设置老年代最大值，默认是-1，即不限制，或者说只受限于本地内存大小。 JDK8始：元空间（Metaspace）Metaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。 -XX:MetaspaceSize：指定元空间的初始空间大小，以字节为单位。 达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下，适当提高该值。 该值越大触发Metaspace GC的时机就越晚。随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加上限也可能降低。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:Metaspacesize为21810376B（大约20.8M） 。 -XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。 防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。 -XX:MinMetaspaceFreeRatio：作用是在Metaspace GC收集之后，控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比。如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。在本机该参数的默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。 -XX:MaxMetaspaceFreeRatio：用于控制大的元空间剩余容量的百分比。 当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。在本机该参数的默认值为70，也就是70%。 -XX:MaxMetaspaceExpansion： Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。 -XX:MinMetaspaceExpansion： Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。 运行时常量池（Runtime Constant Pool）运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，在运行期间也可以将新的常量放入池中，如使用String类的intern()方法。 OOM异常运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 案例HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8中完全使用元空间来代替永久代。 方法区12345678910111213141516171819202122232425262728293031323334353637383940/** * 方法区的OOM异常： * - JDK8之前：指定老年代（方法区的大小固定为10M，不能进行自动扩展） * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M * * - JDK8：完全废除了老年代，用元空间代替。 * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M * * @author wugang * date: 2020-06-04 18:44 **/public class JavaMethodAreaOOM &#123; static class OOMObject &#123;&#125; /** * 借助CGLib使得方法区出现内存溢出异常： * 方法区的主要职责是用于存放类型的相关信息：如类名、访问修饰符、常量池、字段描述、方法描述等。 * 对于这部分区域的测试，基本的思路是：运行时产生大量的类去填满方法区，直到溢出为止。 * 所以：可以借助CGLib直接操作字节码，运行时生成了大量的动态类。 * 注意： * 当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到 CGLib这类字节码技术， * 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。 */ public static void main(String[] args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o, args); &#125; &#125;); enhancer.create(); &#125; &#125;&#125; 输出： 12345678910111213141516171819Exception in thread &quot;main&quot; net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348) at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492) at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305) at com.bubble.jvm.error.JavaMethodAreaOOM.main(JavaMethodAreaOOM.java:39)Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459) at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:339) ... 6 moreCaused by: java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ... 11 more 运行时常量池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.HashSet;import java.util.Set;/** * 方法区（运行时常量池）的OOM异常，（方法区在JDK8后开始废除，之前也被称为永久代） * - 在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中， * 我们可以通过-XX:PermSize和-XX:M axPermSize限制永久代的大小，即可间接限制其中常量池的容量。 * 如：VM Args:-XX:PermSize=6M -XX:MaxPermSize=6M * * @author wugang * date: 2020-06-04 17:36 **/public class RuntimeConstantPoolOOM &#123; /** * JDK6来运行代码，抛出异常： * Exception in thread \"main\" java.lang.OutOfMemoryError: PermGen space * at java.lang.String.intern(Native Method) * 说明运行时常量池是属于方法区(即JDK 6的HotSpot虚拟机中的永久代)的一部分。 * * 注意： * 无论是在JDK7中继续使用-XX:MaxPermSize参数或者在JDK8及以上版本使用-XX:MaxMeta-spaceSize参数 * 把方法区容量同样限制在6MB，也都不会重现JDK6中的溢出异常，循环将一直进行下去，永不停歇。 * * 因为自JDK7起，原本存放在永久代的字符串常量池被移至Java堆之中， * 所以在JDK7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。 * * 但使用-Xmx参数限制最大堆到6MB就能够看到下面两种运行结果之一，具体取决于哪里的对象分配时产生了溢出： * - OOM异常一： * Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space * at java.base/java.lang.Integer.toString(Integer.java:440) * at java.base/java.lang.String.valueOf(String.java:3058) * - OOM异常二： * Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space * at java.base/java.util.HashMap.resize(HashMap.java:699) * at java.base/java.util.HashMap.putVal(HashMap.java:658) * at java.base/java.util.HashMap.put(HashMap.java:607) * at java.base/java.util.HashSet.add(HashSet.java:220) * */ private static void runByJDK6() &#123; // 使用Set保持着常量池引用，避免Full GC回收常量池行为 Set&lt;String&gt; set = new HashSet&lt;&gt;(); // 在short范围内足以让6MB的PermSize产生OOM了 short i = 0; while (true) &#123; set.add(String.valueOf(i++).intern()); &#125; &#125; public static void main(String[] args) &#123; runByJDK6(); &#125;&#125; String::intern()方法String::intern()是一个Native方法，返回该对象在常量池中的引用。 1public native String intern(); 作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * - 在JDK 6中运行，会得到三个false； * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储， * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上， * 所以必然不可能是同一个引用，结果将返回false。 * * - 而在JDK 7后中运行，会得到一个true、一个false和一个true； * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中， * 那只需要在常量池里记录一下首次出现的实例引用即可。 * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。 * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的) * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。 * 而str3和str1一样，\"JDKJVM\"这个字符串则是首次出现。 * */private static void compare() &#123; String str1 = new StringBuilder().append(\"JVM\").append(\"调优\").toString(); System.out.println(str1.intern() == str1); // java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。 /* * 参考：https://www.zhihu.com/question/51102308/answer/124441115 * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化， * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化， * 此时被 sun.misc.Version.launcher 静态常量字段所引用的\"java\"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。 */ String str2 = new StringBuilder().append(\"ja\").append(\"va\").toString(); System.out.println(str2.intern() == str2); // 而JDKJVM这个字符串则是首次出现 String str3 = new StringBuilder().append(\"JDK\").append(\"JVM\").toString(); System.out.println(str3.intern() == str3);&#125;/** * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。 * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。 * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的\"JVM\"。 * - b：先将字符串\"JVM\"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的\"JVM\"，最后将b指向heap中创建的这个对象。 * * 也就是说，a和b存储的内容是一样的，都是\"JVM\"，但地址不一样：a中保存的是常量池中\"JVM\"的地址，b保存的是heap中那个对象的地址， * * 双等于号\"==\"比较的是地址，equals()比较的是内容。 */private static void compareStr() &#123; String a = \"JVM\"; // new一个对象 String b = new String(\"JVM\"); // == 比较地址是否相等 // 都在运行时常量池中 System.out.println(\"JVM\" == a); // true System.out.println(a.intern() == a); // true // a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。 System.out.println(a == b); // false System.out.println(a.intern() == b); // false System.out.println(a.equals(b)); // true&#125; 其他（不受JVM GC管理区域）本机直接内存溢出直接内存（Direct Memory）直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 容量大小可通过-XX:MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致。 NIO(New Input/Output)类NIO引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 OOM异常当各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。 1234567891011121314151617181920212223242526272829303132333435import sun.misc.Unsafe;import java.lang.reflect.Field;/** * 直接内存OOM异常：使用unsafe分配本机内存 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M * * @author wugang * date: 2020-06-04 19:43 **/public class DirectMemoryOOM &#123; private static final int _1MB = 1024 * 1024; /** * 越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配。 * （Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用） * 因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存， * 而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory ()。 * * 抛出异常： * Exception in thread \"main\" java.lang.OutOfMemoryError * at sun.misc.Unsafe.allocateMemory(Native Method) */ public static void main(String[] args) throws IllegalAccessException &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况。如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory(典型的间接使用就是NIO)，那就可以考虑重点检查一下直接内存方面的原因了。","categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://bubblewu.github.io/categories/Java/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://bubblewu.github.io/tags/JVM/"}]},{"title":"生产者-消费者案例","slug":"Java/生产者-消费者案例","date":"2020-06-05T06:52:19.000Z","updated":"2020-06-08T11:11:15.588Z","comments":true,"path":"ckbarvw0y000fyayd2z9y58tz/","link":"","permalink":"https://bubblewu.github.io/ckbarvw0y000fyayd2z9y58tz/","excerpt":"基于Java的生产者-消费者模式代码实现，可以此为Demo来用于具体的实际业务。","text":"基于Java的生产者-消费者模式代码实现，可以此为Demo来用于具体的实际业务。 生产者-消费者demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.time.Duration;import java.time.Instant;import java.util.*;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;&#x2F;** * 推荐服务：生产者-消费者模式 * * @author bubble * date: 2018-10-22 15:03 **&#x2F;@Deprecatedpublic class RecService &#123; private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(RecService.class); &#x2F;&#x2F; 日志打印间隔 private static int DEFAULT_LOG_INTERVAL &#x3D; 1000 * 10; &#x2F;&#x2F; 队列默认处理容量，为避免队列扩容造成额外性能损耗，默认不扩容，达到当前大小，进入等待，消费者处理一部分数据之后，生产者继续生产 private static int DEFAULT_QUEUE_DISPOSE_SIZE &#x3D; 1000 * 10; &#x2F;&#x2F; 队列默认容量 private static int DEFAULT_QUEUE_SIZE &#x3D; DEFAULT_QUEUE_DISPOSE_SIZE + 200; &#x2F;&#x2F; 每个队列满时默认休眠时间 private static int DEFAULT_SLEEP_TIME &#x3D; 1000; &#x2F;&#x2F; 线程池默认消费者数量 private static int DEFAULT_CONSUMER_NUM &#x3D; 2; &#x2F;&#x2F; 用户的phoneId队列 private LinkedBlockingQueue&lt;Long&gt; phoneIdQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(DEFAULT_QUEUE_SIZE); private Long STOP_FLAG &#x3D; -1L; private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap; &#x2F;&#x2F; 用户航班信息 private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; getFlightInfoMap() &#123; return flightInfoMap; &#125; private void setFlightInfoMap(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap) &#123; this.flightInfoMap &#x3D; flightInfoMap; &#125; private RecJobBean recJob; private TipRecService tipRecService; private CarRecService carRecService; private HotelRecService hotelRecService; public RecService(RecJobBean recJob) &#123; this.recJob &#x3D; recJob; switch (recJob) &#123; case TIP: tipRecService &#x3D; Optional.ofNullable(tipRecService).orElse(new TipRecService()); break; case CAR: carRecService &#x3D; Optional.ofNullable(carRecService).orElse(new CarRecService()); break; case HOTEL: hotelRecService &#x3D; Optional.ofNullable(hotelRecService).orElse(new HotelRecService()); break; default: LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType()); System.exit(0); break; &#125; &#125; public void rec(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; userFlightMap, int top) &#123; LOGGER.info(&quot;start &#123;&#125; rec job.&quot;, recJob.getType()); if (userFlightMap &#x3D;&#x3D; null || userFlightMap.isEmpty()) &#123; LOGGER.error(&quot;user flight is empty, rec job for &#123;&#125; exit.&quot;, recJob.getType()); System.exit(0); &#125; setFlightInfoMap(userFlightMap); UserProducer userProducer &#x3D; new UserProducer(); userProducer.setName(&quot;producer&quot;); userProducer.start(); UserConsumer userConsumer &#x3D; new UserConsumer(recJob, top); ThreadPoolExecutor poolExecutor &#x3D; userConsumer.consumerAndRec(); threadMonitor(poolExecutor); &#125; &#x2F;** * 监控ThreadPoolExecutor线程池，无活动线程就关闭线程池连接； *&#x2F; private void threadMonitor(ThreadPoolExecutor executor) &#123; Runnable runnable &#x3D; () -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(2); while (executor.getActiveCount() &gt; 0) &#123; TimeUnit.SECONDS.sleep(1); &#125; executor.shutdown(); &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;thread monitor error.&quot;, e); &#125; &#125;; new Thread(runnable).start(); &#125; &#x2F;** * 生产者: 可用phoneId集合 *&#x2F; class UserProducer extends Thread &#123; int i &#x3D; 0; @Override public void run() &#123; addUser(); try &#123; &#x2F;&#x2F; 给每个线程都在队列（FIFO）末尾添加标识 phoneIdQueue.put(STOP_FLAG); &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;save phoneId error.&quot;, e); &#125; LOGGER.info(&quot;[&#123;&#125;] thread altogether produces &#123;&#125; data&quot;, this.getName(), i); LOGGER.info(&quot;[&#123;&#125;] thread produces done.&quot;, this.getName()); &#125; private void addUser() &#123; try &#123; int step &#x3D; 0; LOGGER.info(&quot;add &#123;&#125; user in producer queue.&quot;, getFlightInfoMap().size()); Iterator iter &#x3D; getFlightInfoMap().entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry &#x3D; (Map.Entry) iter.next(); long uid &#x3D; (long) entry.getKey(); phoneIdQueue.put(uid); step++; while (phoneIdQueue.size() &gt; DEFAULT_QUEUE_DISPOSE_SIZE) &#123; Thread.sleep(DEFAULT_SLEEP_TIME); &#125; if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123; i +&#x3D; step; step &#x3D; 0; LOGGER.info(&quot;[&#123;&#125;] thread has produced &#123;&#125; pieces of data&quot;, this.getName(), i); &#125; &#125; i +&#x3D; step; &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;save phoneId error.&quot;, e); &#125; &#125; &#125; &#x2F;** * 消费者：取phoneId并进行推荐 *&#x2F; class UserConsumer &#123; private int top; private RecJobBean recJob; public UserConsumer(RecJobBean recJob, int top) &#123; this.recJob &#x3D; recJob; this.top &#x3D; top; &#125; public ThreadPoolExecutor consumerAndRec() &#123; ThreadPoolExecutor poolExecutor &#x3D; new ThreadPoolExecutor(DEFAULT_CONSUMER_NUM, DEFAULT_CONSUMER_NUM &lt;&lt; 1, 60 * 60 * 4, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(50), new ThreadPoolExecutor.CallerRunsPolicy()); LOGGER.info(&quot;Consumer start.&quot;); for (int i &#x3D; 0; i &lt; DEFAULT_CONSUMER_NUM; i++) &#123; Thread t &#x3D; new Thread() &#123; int step &#x3D; 0; int consumerNum &#x3D; 0; @Override public void run() &#123; while (!this.isInterrupted()) &#123; Long phoneId; try &#123; phoneId &#x3D; phoneIdQueue.take(); if (phoneId.equals(STOP_FLAG)) &#123; &#x2F;&#x2F; 该线程取到-1，说明产品队列中已无产品，可以结束线程，但是可能还有其他线程存活，需要通知其他线程已无数据 &#x2F;&#x2F; 因此，插入-1，同时跳出循环，线程归还线程池，等待监控线程发现其处于非活动状态，将其销毁，最终销毁线程池 phoneIdQueue.put(STOP_FLAG); LOGGER.info(&quot;[&#123;&#125;] thread consumes done.&quot;, this.getName()); break; &#125; recOneUser(recJob, phoneId, top); consumerNum++; step++; if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123; step &#x3D; 0; LOGGER.info(&quot;[&#123;&#125;] thread has consumed &#123;&#125; pieces of data&quot;, this.getName(), consumerNum); &#125; &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;read data from phoneIdQueue error.&quot;, e); &#125; &#125; LOGGER.info(&quot;[&#123;&#125;] thread altogether consumes &#123;&#125; user data&quot;, this.getName(), consumerNum); LOGGER.info(&quot;RecConsumer end.&quot;); &#125; &#125;; t.setName(&quot;RecConsumer-&quot; + i); poolExecutor.execute(t); &#125; return poolExecutor; &#125; &#125; private void recOneUser(RecJobBean recJob, long uid, int top) &#123; Instant begin &#x3D; Instant.now(); List&lt;FlightInfoBean&gt; userFlightInfoList &#x3D; getFlightInfoMap().get(uid); if (userFlightInfoList !&#x3D; null &amp;&amp; !userFlightInfoList.isEmpty()) &#123; List&lt;TipsUserLinkBean&gt; recItems &#x3D; new ArrayList&lt;&gt;(); switch (recJob) &#123; case TIP: recItems &#x3D; tipRecService.rec(uid, userFlightInfoList, top); break; case CAR: recItems &#x3D; carRecService.rec(uid, userFlightInfoList); break; case HOTEL: recItems &#x3D; hotelRecService.rec(uid, userFlightInfoList, top); break; default: LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType()); break; &#125; LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(begin, Instant.now()).toMillis()); Instant saveStart &#x3D; Instant.now(); try &#123; DataService.saveTipsUserLink(recItems, recJob); &#125; catch (java.lang.NullPointerException np) &#123; LOGGER.error(&quot;user [&#123;&#125;] saveTipsUserLink error.&quot;, uid, np); &#125; LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, save costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(saveStart, Instant.now()).toMillis()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"}]},{"title":"celery和redis交互全流程解析","slug":"Python/celery","date":"2020-06-03T15:51:04.000Z","updated":"2020-06-08T03:32:03.126Z","comments":true,"path":"ckbarvw1l001kyaydh0a4fqt9/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1l001kyaydh0a4fqt9/","excerpt":"celery 和 redis 之间交互的基本原理","text":"celery 和 redis 之间交互的基本原理 123456789101112131415161718 celery 和 redis 之间交互的基本原理：1、当发起一个 task 时，会向 redis 的 celery key 中插入一条记录。2、如果这时有正在待命的空闲 worker，这个 task 会立即被 worker 领取。3、如果这时没有空闲的 worker，这个 task 的记录会保留在 celery key 中。4、这时会将这个 task 的记录从 key celery 中移除，并添加相关信息到 unacked 和 unacked_index 中。5、worker 根据 task 设定的期望执行时间执行任务，如果接到的不是延时任务或者已经超过了期望时间，则立刻执行。6、worker 开始执行任务时，通知 redis。（如果设置了 CELERY_ACKS_LATE &#x3D; True 那么会在任务执行结束时再通知）7、redis 接到通知后，将 unacked 和 unacked_index 中相关记录移除。8、如果在接到通知前，worker 中断了，这时 redis 中的 unacked 和 unacked_index 记录会重新回到 celery key 中。(这个回写的操作是由 worker 在 “临死” 前自己完成的，所以在关闭 worker 时为防止任务丢失，请务必使用正确的方法停止它，如: celery multi stop w1 -A proj1)9、在 celery key 中的 task 可以再次重复上述 2 以下的流程。10、celery 只是利用 redis 的 list 类型，当作个简单的 Queue，并没有使用消息订阅等功能--------------1、需要配置celery的backend，backend的作用就是存储任务执行结果。2、当celery key中的任务成功被worker认领并且执行成功，celery会向配置好的bachend中，写入以task_id为key。3、所以，可以通过查看bachend中是否有以task_id为key的对象来判断task是否执行成功。 向博主反馈问题","categories":[{"name":"python","slug":"python","permalink":"https://bubblewu.github.io/categories/python/"}],"tags":[{"name":"celery","slug":"celery","permalink":"https://bubblewu.github.io/tags/celery/"}]},{"title":"copy","slug":"Linux/copy","date":"2020-06-03T15:47:59.000Z","updated":"2020-06-08T03:32:03.121Z","comments":true,"path":"ckbarvw15000vyayd2sf94mhq/","link":"","permalink":"https://bubblewu.github.io/ckbarvw15000vyayd2sf94mhq/","excerpt":"图片增加容量大小使用方法","text":"图片增加容量大小使用方法 123copy 1M.jpg /b + 5M.file /b 6M.jpg# orcopy /b 1M.jpg + 5M.file 6M.jpg 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"copy","slug":"copy","permalink":"https://bubblewu.github.io/tags/copy/"}]},{"title":"git修改用户名密码","slug":"git/git","date":"2020-05-26T14:57:23.000Z","updated":"2020-06-08T03:32:03.124Z","comments":true,"path":"ckbarvw1m001oyaydhe6xdj9h/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1m001oyaydhe6xdj9h/","excerpt":"用户使用git时的使用免密拉取和上传，修改免密设置，取消免密设置","text":"用户使用git时的使用免密拉取和上传，修改免密设置，取消免密设置 第一次输入密码之后自动免密1# git 默认即支持首次输入用户名密码，后续自动记忆，使用免密设置 取消免密设置12git config --global --unset credential.helper store# 使用 --global 参数则全局生效，不适用则针对当前目录下的.git生效 设置免密12git config --global credential.helper store# 使用 --global 参数则全局生效，不适用则针对当前目录下的.git生效 适用场景12345678# 大多公司的账户密码考虑到安全性，隔段时间便会失效，需更改密码# 这个时候大多git默认已经记忆上次用户名和密码，且不用跳出输入用户和密码的弹窗# 1. 取消免密功能，使它能正确弹出用户名和密码框git config --global --unset credential.helper store# 2. 使用git拉取或提交代码，相当于首次提交 会自动弹出用户名密码弹窗，输入即可# 3. 再次打开免密功能，记忆第二步的用户名和密码git config --global credential.helper store win图形化修改git提交密码12# 设置路径# 控制面板 --&gt; 用户账号 --&gt; 凭据管理器 --&gt; windows凭据 --&gt; 修改对应的git地址的用户名和密码后保存即可 向博主反馈问题","categories":[{"name":"Git","slug":"Git","permalink":"https://bubblewu.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bubblewu.github.io/tags/git/"}]},{"title":"Charles","slug":"Charles/licenses","date":"2020-05-23T17:28:23.000Z","updated":"2020-06-08T03:32:03.120Z","comments":true,"path":"ckbarvw0w000eyayd63i6aore/","link":"","permalink":"https://bubblewu.github.io/ckbarvw0w000eyayd63i6aore/","excerpt":"Charles 注册码","text":"Charles 注册码 Charles 注册码12CCF4cfbb2ea5c75c77858 向博主反馈问题","categories":[{"name":"Charles","slug":"Charles","permalink":"https://bubblewu.github.io/categories/Charles/"}],"tags":[{"name":"licenses","slug":"licenses","permalink":"https://bubblewu.github.io/tags/licenses/"}]},{"title":"Mac安装并配置Jenkins","slug":"Jenkins/install","date":"2020-05-23T17:00:05.000Z","updated":"2020-06-08T03:32:03.120Z","comments":true,"path":"ckbarvw10000jyaydaxnw43ky/","link":"","permalink":"https://bubblewu.github.io/ckbarvw10000jyaydaxnw43ky/","excerpt":"Mac使用Homebrew包管理器安装并配置管理Jenkins","text":"Mac使用Homebrew包管理器安装并配置管理Jenkins mac安装Jenkins12345678910111213141516# 1. Mac安装JDK并配置环境变量# 2.安装Jenkinsbrew install jenkinsbrew services start jenkins # 命令会自动设置为开机启动brew services stop jenkinsbrew services restart jenkins# 局域网访问:# 使用brew安装jenkins会避免很多其他安装方式产生的用户权限问题，但是会将httpListenAddress默认设置为127.0.0.1，这样我们虽然可以在本地用localhost:8080访问，但是本机和局域网均无法用ip访问。解决办法为修改两个路径下的plist配置。并重启# ～/Library/LaunchAgents/homebrew.mxcl.jenkins.plist# /usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist# 将上面两个plist中的httpListenAddress后的ip地址，修改为本机IP或者0.0.0.0即可。# 取消开机启动sudo launchctl unload -w /Library/LaunchDaemons/org.jenkins-ci.plist # 设置开机启动sudo launchctl load -w /Library/LaunchDaemons/org.jenkins-ci.plist 向博主反馈问题","categories":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://bubblewu.github.io/categories/Jenkins/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://bubblewu.github.io/tags/jenkins/"}]},{"title":"interview","slug":"Interview/interview","date":"2020-05-23T16:41:05.000Z","updated":"2020-06-08T03:32:03.120Z","comments":true,"path":"ckbarvw0z000iyaydhl5afzxr/","link":"","permalink":"https://bubblewu.github.io/ckbarvw0z000iyaydhl5afzxr/","excerpt":"Interview","text":"Interview 基础篇123456789101112# 1. 冒泡排序def bubble_sort(data): for i in range(len(data)-1, -1, -1): flag = False for j in range(i): if data[j] &gt; data[j + 1]: data[j], data[j + 1] = data[j + 1], data[j] flag = True if not flag: break print('第&#123;0&#125;次排序: &#123;1&#125;'.format(len(data)-i, data)) return data 12345678# 2. 装饰器单例def singleton(cls, *args, **kwargs): _instance = &#123;&#125; def get_instance(): if cls not in _instance: _instance.setdefault(cls, cls(*args, **kwargs)) return _instance.get(cls) return get_instance 123456789101112################ sql# 添加insert into tablename(id,name) values(1,w)insert into tablename values(1,w)# 更新update tablename set 字段名='newvalue' where# 删除delete from tablename where# 查找select * from tablename where# 分组group by 字段名 having avg() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899############# Linux# 查看进程ps -ef | grep 'kafka' # 显示PID# 杀死进程kill -9 PID# 实时查看日志后十行file.logtail -n 10 -f file.log # tail -f == tailf# 复制cp -a oldfile newfolder# 检查端口号是否被占用netstat -anp | grep 8080# mkdir 创建目录mkdir amkdir -p a/b/c # 创建多级目录时使用 -p 命令# rm 删除目录、文件rm -rf a/b/c f # 不提醒确认则删除 shell脚本中常用 r是目录也删除，递归删除rm -r a/b/c # 提醒用户是否确认删除 命令行使用# cat 查看文件# cat -n [文件名] -n 显示行号# cp 拷贝文件cp A.txt b.txtcp a b# echo $PATH# grepcat -n A.txt | grep filter # 只显示filter内容cat -n A.txt | grep -v filter # -v不显示filter内容# findfine /root -name A.txt# ps 查看进程PIDps -ef | grep mongo# kill -9 结束进程(根据PID)kill -9 [PID]# mvmv a.txt /a/b# netstat 检查端口是否被占用netstat -anp | grep 8080# yum search package# yum install package# yum uninstall package# sed 修改文本sed -e 's/oldstr/newstr/g' A.txt # 's'字符串 'g'全局替换# tartar -zcvf a.tar.gz /root/a #归档打包tar -zxvf a.tar.gz /root/a #解压缩# awk 处理带格式文件文本kill -9 `ps | grep bash | awk ' ' '&#123;print $1&#125;'` # === kill -9 PID# awk ' ' 空格分割字符串# awk '&#123;print $1&#125;' 打印或取值第一个# ` ` 代表执行代码块获取执行结果，优先执行# nohub 不挂起进行 命令行保护进程启动程序# head 从头开始查看文件前10行head -n 10 a.log# tailtail -n 10 a.log # 从末尾开始查看文件最后10行tail -f a.log # 实时查看末尾# less# more# touch、vi 创建文件touch a.txtvi a.sh# history 查看命令行的历史命令# chmod 赋权限chmod 777 A.txtchmod -x A.txt# x可执行权限 r只读 w写# rz 上传 yum install lrzsz# sz 下载# scp 文件传输# wcwc -l a/b/A.txt # 统计文件行数# dudu -sh A.txt # 查看文件大小du -sh /a/b # 查看目录大小 123456789 测试用例八大要素用例编号操作步骤测试标题重要级别前置条件测试输入所属模块预期结果 12345黑盒测试用例设计方法包括等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景图法等。白盒子测试方法：（强度由低到高）语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖。测试人员经常用到的有等价类，边界值，场景法，因果图法。 向博主反馈问题","categories":[{"name":"Interview","slug":"Interview","permalink":"https://bubblewu.github.io/categories/Interview/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://bubblewu.github.io/tags/interview/"}]},{"title":"Jenkins部署Python","slug":"Jenkins/xargs","date":"2020-05-23T16:30:19.000Z","updated":"2020-06-08T03:32:03.121Z","comments":true,"path":"ckbarvw10000kyaydbdqx5vt4/","link":"","permalink":"https://bubblewu.github.io/ckbarvw10000kyaydbdqx5vt4/","excerpt":"Jenkins部署 - 使用shell脚本后台守护进程运行","text":"Jenkins部署 - 使用shell脚本后台守护进程运行 示例1234567891011121314151617181920212223242526272829303132333435#!/bin/bash# 保证程序后台运行不杀死 和 nohub、&amp; 一同使用BUILD_ID=dontKillMe# source /root/.bash_profile# 停止服务(先杀死Python当前运行的进程)# ps -ef | grep python3 | grep -v grep | awk -F ' ' '&#123;print $2&#125;' | xargs kill -9pid=`ps -ef | grep python3 | grep -v grep | awk -F ' ' '&#123;print $2&#125;'`for p in $&#123;pid[@]&#125;;do kill -9 $pdone# 删除目录if [ -d /root/Jenkins/production ];then rm -rf /root/Jenkins/productionfi# 创建新部署目录mkdir -p /root/Jenkins/production# 进入部署目录cd /root/Jenkins/production# 拉取代码git clone &lt;url&gt;# 进入cd &lt;proj_path&gt;# 启动 BUILD_ID=dontKillMe 保证程序后台运行不杀死 和 nohub、&amp; 一同使用nohup python3 app.py &amp; 向博主反馈问题","categories":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://bubblewu.github.io/categories/Jenkins/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://bubblewu.github.io/tags/shell/"}]},{"title":"CentOS 7 firewalld","slug":"Linux/firewalld","date":"2020-05-20T14:56:02.000Z","updated":"2020-06-08T03:32:03.122Z","comments":true,"path":"ckbarvw14000tyaydgnk51yty/","link":"","permalink":"https://bubblewu.github.io/ckbarvw14000tyaydgnk51yty/","excerpt":"CentOS 7 通过防火墙开放指定端口","text":"CentOS 7 通过防火墙开放指定端口 firewall-cmd12345678910111213141516# 查看开通端口列表firewall-cmd --list-ports# 开放80端口firewall-cmd --permanent --zone=public --add-port=80/tcp# 关闭80端口firewall-cmd --zone=public --remove-port=80/tcp --permanent# 重启防火墙生效systemctl restart firewalld# PS: # firewalld配置的防火墙策略也分为两种模式# 1、runtime，当前生效，重启后失效# 2、permanent，当前失效，重启后生效，为了让permanet生效，一般会执行friewall-cmd --reload，使其立即生效 说明 Linux上新的防火墙软件，和iptables差不多的工具。firewalld是centos7的一大特性，两大优点：支持动态更新，不用重启服务；加入了防火墙的“zone”概念。 firewalld能动态修改单条规则，不像iptables，修改规则后必须全部刷新才能生效。 firewalld在使用上要比iptables人性化很多。firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter。 rpm -qa | grep firewalld | 查看是否安装 yum install firewalld 安装 rpm -qa | grep firewall-config 查看是否安装图形界面 yum install firewall-config 如果需要图形界面的话，需要安装 systemctl start firewalld 启动 systemctl restart firewalld 重启 systemctl disable firewalld 停止 systemctl stop firewalld 禁用 systemctl status firewalld | - firewall-cmd --state 查看状态 firewall-cmd --list-ports 查看开通端口列表 firewall-cmd --zone=public --remove-port=80/tcp --permanent 关闭端口 firewall-cmd --permanent --zone=public --add-port=80/tcp 开通端口 firewall-cmd --get-default-zone 查看default zone firewall-cmd --get-active-zones 查看active zone 备注：--zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效firewall防火墙默认的几个zone（由firewalld 提供的区域按照从不信任到信任的顺序排序） 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"firewalld","slug":"firewalld","permalink":"https://bubblewu.github.io/tags/firewalld/"}]},{"title":"CentOS 7 安装 network","slug":"Linux/network","date":"2020-05-20T14:49:51.000Z","updated":"2020-06-08T03:32:03.123Z","comments":true,"path":"ckbarvw1h001ayayd3yvicofd/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1h001ayayd3yvicofd/","excerpt":"CentOS 7网络配置(Mac虚拟机下的共享配置)","text":"CentOS 7网络配置(Mac虚拟机下的共享配置) 编辑网络配置文件123456789101112131415# 编辑配置文件ifcfg-eth0 ifcfg-eth1 ...vi /etc/sysconfig/network-scripts/ifcfg-eth0# 复制以下项DEVICE=eth0BOOTPROTO=staticNOBOOT=yesIPADDR=192.168.10.192NETMASK=255.255.252.0GATEWAY=192.168.10.254DNS1=192.168.10.3DNS2=223.6.6.6NM_CONTROLLED=no# 重启网络CentOS7网络后生效systemctl restart network 参数解读1234567891011121314151617181920212223# 注：这里面的IP地址，子网掩码，GATE ，DNS都按照主机的配置。# 之后，重启一下虚拟机应该就可以。# 之后，ping下主机IP地址，ping 下局域网其他主机IP地址，再ping下外网ip地址，可以的话就算成功##################################### 从dhcp改成staticBOOTPROTO=static# 从no改成yes。系统将在启动时自动开启该接口。ONBOOT=yes# 设置IP地址IPADDR=# 设置子网掩码NETMASK=# 设置网关GATEWAY=# 设置DNSDNS1=DNS2=# 表示该接口将通过该配置文件进行设置，而不是通过网络管理器进行管理NM_CONTROLLED=no#################################### 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"network","slug":"network","permalink":"https://bubblewu.github.io/tags/network/"}]},{"title":"CentOS 7 时间时区调整","slug":"Linux/time","date":"2020-05-20T14:42:07.000Z","updated":"2020-06-08T03:32:03.124Z","comments":true,"path":"ckbarvw1p0021yayd9ze9hvwu/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1p0021yayd9ze9hvwu/","excerpt":"CentOS 7 调整时间为中国时区时间","text":"CentOS 7 调整时间为中国时区时间 启用NTP同步123456789101112# 安装ntp服务yum install ntp# 开机启动服务systemctl enable ntpd# 启动服务systemctl start ntpd# 更改时区timedatectl set-timezone Asia/Shanghai# 启用ntp同步timedatectl set-ntp yes# 同步时间ntpq -p timedatectl 命令同步时区123456789101112131415161718192021222324# 读取时间 等同于 timedatectl statustimedatectl# 设置时间timedatectl set-time \"YYYY-MM-DD HH:MM:SS\"# 列出所有时区timedatectl list-timezones# 更改时区timedatectl set-timezone Asia/Shanghai# 或 ln -sf /usr/share/zoneinfor/Asia/Shanghai /etc/localtime 设置是否与NTP服务器同步 //yes或者notimedatectl set-ntp yes# 将硬件时钟调整为与本地时钟一致hwclock --systohc --localtime 或 timedatectl set-local-rtc 1# 注，硬件时钟默认使用UTC时间，因为硬件时钟不能保存时区和夏令时调整，修改后就无法从硬件时钟中读取出准确标准时间，因此不建议修改。修改后系统会出现警告。# 将硬件时间设置成 UTChwclock --systohc --utc 或 timedatectl set-local-rtc 1# 显示硬件时间：hwclock --show# 设置硬件时间：hwclock --set --date ‘08/02/2012 12:00:00’# 将硬件时间同步到系统时间：hwclock --hctosys# 强制把系统时间写入CMOS：# clock -w 时钟概念 在CentOS 6版本，时间设置有date、hwclock命令，从CentOS 7开始，使用了一个新的命令timedatectl。 （1）UTC整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。 （2）GMT格林威治标准时间 (Greenwich Mean Time)指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。(UTC与GMT时间基本相同，本文中不做区分) （3）CST中国标准时间 (China Standard Time)【GMT + 8 = UTC + 8 = CST】 （4）DST夏令时(Daylight Saving Time) 指在夏天太阳升起的比较早时，将时钟拨快一小时，以提早日光的使用。（中国不使用） 硬件时钟：RTC(Real-Time Clock)或CMOS时钟，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。 系统时钟：一般在服务器启动时复制RTC时间，之后独立运行，保存了时间、时区和夏令时设置。 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"timedatectl","slug":"timedatectl","permalink":"https://bubblewu.github.io/tags/timedatectl/"}]},{"title":"CentOS 7 安装 nginx","slug":"Linux/nginx","date":"2020-05-20T14:37:41.000Z","updated":"2020-06-08T03:32:03.123Z","comments":true,"path":"ckbarvw1f0017yayd4jkqaz8q/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1f0017yayd4jkqaz8q/","excerpt":"CentOS 7 安装 nginx","text":"CentOS 7 安装 nginx 安装1234567891011121314151617# 安装依赖包 c编译gcc依赖yum install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel# 下载安装包wget -c https://nginx.org/download/nginx-1.12.0.tar.gz# 解压安装包tar -zxvf nginx-1.12.0.tar.gz# 进入安装包cd nginx-1.12.0# 编译预处理./configure# 编译并安装make &amp;&amp; make install# 进入nginx目录cd /usr/local/nginx/sbin/# 启动nginx ./nginx [-s stop|reload]./nginx -s reload -t 配置文件路径说明12345678# ./configure \\# --prefix=/etc/nginx \\# --sbin-path=/usr/sbin/nginx \\# --conf-path=/etc/nginx/nginx.conf \\# --error-log-path=/var/log/nginx/error.log \\# --http-log-path=/var/log/nginx/access.log \\# --pid-path=/var/run/nginx.pid \\# --lock-path=/var/run/nginx.lock 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://bubblewu.github.io/tags/nginx/"}]},{"title":"CentOS 7 安装 mongodb","slug":"Linux/mongodb","date":"2020-05-20T14:32:33.000Z","updated":"2020-06-08T03:32:03.122Z","comments":true,"path":"ckbarvw1a0011yayd5ev06lmm/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1a0011yayd5ev06lmm/","excerpt":"CentOS 7 安装 mongodb","text":"CentOS 7 安装 mongodb 安装12345678910111213141516# 创建 repo文件touch /etc/yum.repos.d/mongodb-org-4.0.repo# 配置 repo文件(复制以下内容到.repo文件)[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb- org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc# 安装sudo yum install -y mongodb-org# 编辑配置文件: 修改绑定地址为0.0.0.0 vim /etc/mongod.conf# 启动、停止、重启service mongod start/stop/restart 配置12345678910111213141516171819202122# 1.修改数据和日志的存储位置# bin目录下增加mongodb.conf文件# 内容：port=27017dbpath=/usr/local/mongodb/data/logpath=/usr/local/mongodb/log/mongodb.logfork = true# 释义：# port: 数据库服务使用端口# dbpath: 数据存放的文件位置# logpath: 日志文件的存放位置# fork: 后台守护进程运行# 启动命令：./mongod -f mongodb.conf# 关闭方式：./mongo# &gt;# &gt;use admin# &gt;db.shutdownServer() 卸载1234# 卸载yum erase $(rpm -qa | grep mongodb-org)rm -r /var/log/mongodbrm -r /var/lib/mongo 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://bubblewu.github.io/tags/mongodb/"}]},{"title":"CentOS 7 安装 kafka","slug":"Linux/kafka","date":"2020-05-20T14:27:38.000Z","updated":"2020-06-08T03:32:03.122Z","comments":true,"path":"ckbarvw1b0015yayd76q40mpr/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1b0015yayd76q40mpr/","excerpt":"CentOS 7 安装 kafka，简单配置使用kafka","text":"CentOS 7 安装 kafka，简单配置使用kafka 安装1234# 下载安装包wget http://mirror.bit.edu.cn/apache/kafka/2.2.0/kafka_2.12-2.2.0.tgz# 解压安装包tar -xzf kafka_2.12-2.2.0.tgz 启动1234# 启动zookeeperbin/zookeeper-server-start.sh config/zookeeper.properties# 启动kafkabin/kafka-server-start.sh config/server.properties 测试12345678# 创建topicbin/kafka-topics.sh --create --bootstrap-server localhost:9092 -- replication-factor 1 --partitions 1 --topic test# 列出topicbin/kafka-topics.sh --list --bootstrap-server localhost:9092# 发送消息bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test# 接收消息bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 -- topic test --from-beginning 启动zookeeper1234# 1bin/zookeeper-server-start.sh config/zookeeper.properties# 2 守护进程启动方式 防止挂掉bin/zookeeper-server-start.sh -daemon config/zookeeper.properties 启动kafka1234# 1bin/kafka-server-start.sh config/server.properties# 2 守护进程启动方式 防止挂掉bin/kafka-server-start.sh -daemon config/server.properties 查看topic列表1bin/kafka-topics.sh --list --zookeeper localhost:2181 创建topic1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 生产者1bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test 消费者1bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning 关闭kafka1bin/kafka-server-stop.sh 关闭zookeeper1bin/zookeeper-server-stop.sh 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://bubblewu.github.io/tags/kafka/"}]},{"title":"CentOS 7  c 编译依赖安装","slug":"Linux/c","date":"2020-05-20T14:24:04.000Z","updated":"2020-06-08T03:32:03.121Z","comments":true,"path":"ckbarvw12000oyayda65nanbm/","link":"","permalink":"https://bubblewu.github.io/ckbarvw12000oyayda65nanbm/","excerpt":"Linux使用源码安装软件时，需要c编译时，首先安装c编译依赖","text":"Linux使用源码安装软件时，需要c编译时，首先安装c编译依赖 安装123456yum install gccyum install pcre-develyum install zlib zlib-develyum install openssl openssl-develyum install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"gcc","slug":"gcc","permalink":"https://bubblewu.github.io/tags/gcc/"}]},{"title":"CentOS 7 安装 python","slug":"Linux/python","date":"2020-05-20T14:16:46.000Z","updated":"2020-06-08T03:32:03.123Z","comments":true,"path":"ckbarvw1i001dyaydbagicfj8/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1i001dyaydbagicfj8/","excerpt":"CentOS 7 yum安装 python3.6","text":"CentOS 7 yum安装 python3.6 安装123456789101112# 安装依赖包yum install -y openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel# 下载安装包 wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz# 解压安装包 tar -xzvf Python-3.6.5.tgz# 进入安装目录 cd Python-3.6.5# 编译预处理 ./configure --prefix=/usr/local/python# 编译并安装 make &amp;&amp; make install 修改Linux的Python版本默认为Python3123# Linux默认Python为2.7# 建立新安装的python3.6.5的软连接$ ln -s /usr/python/bin/python3 /usr/bin/python3 python3添加环境变量12345vim ~/.bash_profile## PATH=$PATH:$HOME/bin:/opt/python3.6.5/bin # opt需修改为自己安装的Python所在目录# export PATHsource ~/.bash_profile 验证123python3 --versionpython --version 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bubblewu.github.io/tags/python/"}]},{"title":"CentOS 7 安装 JDK","slug":"Linux/jdk","date":"2020-05-20T14:12:16.000Z","updated":"2020-06-08T03:32:03.122Z","comments":true,"path":"ckbarvw13000pyaydd3rd8po3/","link":"","permalink":"https://bubblewu.github.io/ckbarvw13000pyaydd3rd8po3/","excerpt":"CentOS 7 安装 JDK1.8 并配置环境变量","text":"CentOS 7 安装 JDK1.8 并配置环境变量 yum安装jdk1yum install java-1.8.0-openjdk* 配置环境变量123456789vim ~/.bash_profile# set java environment# JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-3.b13.el7_5.x86_64# PATH=$PATH:$JAVA_HOME/bin# CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# export JAVA_HOME CLASSPATH PATHsource ~/.bash_profile 验证1java --version 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"jdk","slug":"jdk","permalink":"https://bubblewu.github.io/tags/jdk/"}]},{"title":"curl发送HTTP请求","slug":"Linux/curl","date":"2020-05-20T13:58:19.000Z","updated":"2020-06-08T03:32:03.121Z","comments":true,"path":"ckbarvw19000zyayd9sw493um/","link":"","permalink":"https://bubblewu.github.io/ckbarvw19000zyayd9sw493um/","excerpt":"使用curl发送HTTP请求，用于简单验证接口连接性。","text":"使用curl发送HTTP请求，用于简单验证接口连接性。 GET 请求示例123456789101112131415# GET请求 -icurl -i &lt;url&gt;# 返回示例：# HTTP/1.0 200 OK# Content-Type: application/json# Content-Length: 151# Server: Werkzeug/0.8.3 Python/2.7.3# Date: Mon, 20 May 2013 05:21:50 GMT## &#123;# \"data\": &#123;# \"description\": \"Need to find a good Python tutorial on the web\",# &#125;,# \"code\": 200# &#125; POST 请求示例1234567891011121314# POST请求示例 -icurl -i -H \"Content-Type: application/json\" -X POST -d '&#123;\"data\":\"data\"&#125;' &lt;url&gt;# HTTP/1.0 201 Created# Content-Type: application/json# Content-Length: 104# Server: Werkzeug/0.8.3 Python/2.7.3# Date: Mon, 20 May 2013 05:56:21 GMT## &#123;# \"data\": &#123;# \"description\": \"Need to find a good Python tutorial on the web\",# &#125;,# \"code\": 200# &#125; curl 带密码请求123456789101112131415# -u username:password -i urlcurl -u miguel:python -i &lt;url&gt;# HTTP/1.0 200 OK# Content-Type: application/json# Content-Length: 316# Server: Werkzeug/0.8.3 Python/2.7.3# Date: Mon, 20 May 2013 06:46:45 GMT## &#123;# \"data\": &#123;# \"description\": \"Need to find a good Python tutorial on the web\",# &#125;,# \"code\": 200# &#125; 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"curl","slug":"curl","permalink":"https://bubblewu.github.io/tags/curl/"}]},{"title":"ssh-keygen","slug":"Linux/ssh-keygen","date":"2020-05-20T00:05:10.000Z","updated":"2020-06-08T03:32:03.123Z","comments":true,"path":"ckbarvw1j001fyayd90y791oh/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1j001fyayd90y791oh/","excerpt":"ssh-keygen简单用法本文主要针对ssh-keygen配置GitHub Pages使用ssh免密部署ssh秘钥登录特点：1.安全；2.免输密码。","text":"ssh-keygen简单用法本文主要针对ssh-keygen配置GitHub Pages使用ssh免密部署ssh秘钥登录特点：1.安全；2.免输密码。 安装1# ssh-keygen为ssh自带命令，Mac、Linux、Ubuntu等都自带 检查是否配置过ssh服务12345# mac、linux、ubuntucd ~/.sshls# id_rsa id_rsa.pub known_hosts# 如果有id_rsa id_rsa.pub，证明以前曾经配置过，如果忘记曾经配置过，请删除此两项 配置ssh12ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"# 后面全部enter，不选择任何选项，最后生成的秘钥为无密码密钥 查看公钥和私钥12345# 查看公钥cat ~/.ssh/id_rsa.pub# 查看私钥cat ~/.ssh/id_rsa 服务器配置公钥12345# 以github为例# 配置路径：Setting -&gt; SSH and GPG keys -&gt; New SSH key or Add SSH key# title可以随便起（尽量和自己的私钥所在电脑相关联）# Key: # 复制id_rsa.pub文件的全部内容# 最后保存即可 测试是否连通12# 以github为例ssh -T git@github.com 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"ssh-keygen","slug":"ssh-keygen","permalink":"https://bubblewu.github.io/tags/ssh-keygen/"}]},{"title":"scp","slug":"Linux/scp","date":"2020-05-19T23:34:10.000Z","updated":"2020-06-08T03:32:03.123Z","comments":true,"path":"ckbarvw1k001iyaydh269beic/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1k001iyaydh269beic/","excerpt":"Linux scp 命令用于 Linux 之间复制文件和目录。scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。scp [可选参数] file_source file_target","text":"Linux scp 命令用于 Linux 之间复制文件和目录。scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。scp [可选参数] file_source file_target 从本地复制到远程Linux12345# 复制文件1 (自动重命名)scp local_file remote_username@remote_ip:remote_file# 复制文件2 (无重命名)scp local_file remote_username@remote_ip:remote_folder# PS: 需要输入远程ssh登录的密码；如果未指定用户名，则需要输入用户名和密码 从远程Linux复制到本地12345# 复制文件1 (自动重命名)scp remote_username@remote_ip:remote_file local_file# 复制文件2 (无重命名)scp remote_username@remote_ip:remote_folder local_folder# PS: 需要输入远程ssh登录的密码；如果未指定用户名，则需要输入用户名和密码 复制文件夹12345678910111213141516171819202122# scp命令后加 -r 参数即可scp -rscp [可选参数] file_source file_target# 参数说明：# -1： 强制scp命令使用协议ssh1# -2： 强制scp命令使用协议ssh2# -4： 强制scp命令只使用IPv4寻址# -6： 强制scp命令只使用IPv6寻址# -B： 使用批处理模式（传输过程中不询问传输口令或短语）# -C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）# -p：保留原文件的修改时间，访问时间和访问权限。# -q： 不显示传输进度条。# -r： 递归复制整个目录。# -v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。# -c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。# -F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。# -i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。# -l limit： 限定用户所能使用的带宽，以Kbit/s为单位。# -o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，# -P port：注意是大写的P, port是指定数据传输用到的端口号# -S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 向博主反馈问题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"}],"tags":[{"name":"scp","slug":"scp","permalink":"https://bubblewu.github.io/tags/scp/"}]},{"title":"terminal","slug":"mac/terminal","date":"2020-05-16T18:27:16.000Z","updated":"2020-06-08T03:32:03.126Z","comments":true,"path":"ckbarvw1r0028yayddfkf91wh/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1r0028yayddfkf91wh/","excerpt":"Mac终端terminal自动补全之忽略大小写","text":"Mac终端terminal自动补全之忽略大小写 自动补全忽略大小写（terminal）12345678# 终端中输入以下命令：$ nano .inputrc# 在里面粘贴一下语句后, Control+O 保存set completion-ignore-case onset show-all-if-ambiguous onTAB: menu-complete# PS: 需重启终端生效 向博主反馈问题","categories":[{"name":"Mac","slug":"Mac","permalink":"https://bubblewu.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubblewu.github.io/tags/mac/"}]},{"title":"ipv6","slug":"mac/ipv6","date":"2020-05-16T18:23:52.000Z","updated":"2020-06-08T03:32:03.126Z","comments":true,"path":"ckbarvw1s002ayayd468jbz3m/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1s002ayayd468jbz3m/","excerpt":"Mac系统关闭ipv6","text":"Mac系统关闭ipv6 Mac修改网络时遇到无法修改，需先关闭ipv612# commandnetworksetup -listallnetworkservices | sed 1d | xargs -I &#123;&#125; networksetup -setv6off &#123;&#125; 向博主反馈问题","categories":[{"name":"Mac","slug":"Mac","permalink":"https://bubblewu.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubblewu.github.io/tags/mac/"}]},{"title":"Homebrew","slug":"mac/Homebrew","date":"2020-05-16T18:18:30.000Z","updated":"2020-06-08T03:32:03.126Z","comments":true,"path":"ckbarvw1q0025yaydh4m4daue/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1q0025yaydh4m4daue/","excerpt":"mac提供包管理器的安装和使用(类似Ubuntu的apt，Linux的yum、pkg)","text":"mac提供包管理器的安装和使用(类似Ubuntu的apt，Linux的yum、pkg) Homebrew安装1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 简单使用123brew list packagebrew install &lt;package_name&gt;brew uninstall &lt;package_name&gt; 其他软件1234# 安装Cakebrew和LaunchRocketbrew cask install cakebrewbrew cask install launchrocket# PS：注意 launchrocket 只能管理Homebrew安装的服务，不支持源码下载安装的服务 向博主反馈问题","categories":[{"name":"Mac","slug":"Mac","permalink":"https://bubblewu.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubblewu.github.io/tags/mac/"}]},{"title":"Finder","slug":"mac/Finder","date":"2020-05-16T18:04:43.000Z","updated":"2020-06-08T03:32:03.125Z","comments":true,"path":"ckbarvw1o001vyayd1e0k3qlq/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1o001vyayd1e0k3qlq/","excerpt":"Finder 显示与隐藏 隐藏文件(.文件)","text":"Finder 显示与隐藏 隐藏文件(.文件) 命令行永久改变显示方式12345# 显示defaults write com.apple.finder AppleShowAllFiles -bool true; killall Finder# 隐藏defaults write com.apple.finder AppleShowAllFiles -bool false; killall Finder# PS: 输入完命令回车后，需重启Finder：左上角的苹果标志--&gt;强制退出--&gt;Finder--&gt;重新启动 临时显示/隐藏快捷键1command + shift + . 向博主反馈问题","categories":[{"name":"Mac","slug":"Mac","permalink":"https://bubblewu.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubblewu.github.io/tags/mac/"}]},{"title":"Mac开启任何来源","slug":"mac/Mac开启任何来源","date":"2020-05-14T16:20:07.000Z","updated":"2020-06-08T03:32:03.126Z","comments":true,"path":"ckbarvw1o001yyaydfxrge9yq/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1o001yyaydfxrge9yq/","excerpt":"Mac在macOS系统下，系统偏好设置中的“安全与隐私”默认已经去除了允许“任何来源”App的选项，如果不开启会直接影响到无法运行一些第三方应用。","text":"Mac在macOS系统下，系统偏好设置中的“安全与隐私”默认已经去除了允许“任何来源”App的选项，如果不开启会直接影响到无法运行一些第三方应用。 开启权限命令1234# 显示sudo spctl --status --master-disable# 隐藏sudo spctl --status --master-enable 向博主反馈问题","categories":[{"name":"Mac","slug":"Mac","permalink":"https://bubblewu.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://bubblewu.github.io/tags/mac/"}]},{"title":"Bubble Sort","slug":"Python/冒泡排序","date":"2020-05-11T15:08:10.000Z","updated":"2020-06-08T03:32:03.126Z","comments":true,"path":"ckbarvw1m001ryayd2tq6599d/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1m001ryayd2tq6599d/","excerpt":"经典面试题---进阶版冒泡排序","text":"经典面试题---进阶版冒泡排序 常规版1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-def foo(data): \"\"\"常规版\"\"\" for i in range(len(data)): for j in range(len(data)-i-1): if data[j] &gt; data[j+1]: data[j], data[j + 1] = data[j + 1], data[j] return dataif __name__ == '__main__': data = [3, 0, 5, 4, 2, 6, 8, 1, 9, 7] print(data) print(foo(data)) 进阶版1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# -*- coding: utf-8 -*-def bubble_sort(data): \"\"\" 进阶版 最坏情况 时间复杂度 O(n**2) 最好情况 时间复杂度 O(n) 稳定排序法 空间复杂度最佳 只需要一个额外空间 适用于数据量小或有部分数据已经排过序的情况 :param data: :return: \"\"\" # i 倒序循环列表排序 for i in range(len(data)-1, -1, -1): flag = False # flag判断是否执行了交换操作 for j in range(i): # i 为倒序循环，所以j的最大值即是i 0～i if data[j] &gt; data[j + 1]: data[j], data[j + 1] = data[j + 1], data[j] flag = True # 执行过交换操作，把flag置为True if not flag: # 执行完一次扫描后，判断是否执行过交换操作，如果没有交换过数据，就表示此时数组已完成排序，故直接跳出循环 break print('第&#123;0&#125;次排序: &#123;1&#125;'.format(len(data)-i, data)) return dataif __name__ == '__main__': data = [3, 0, 5, 4, 2, 6, 8, 1, 9, 7] print(data) print(bubble_sort(data)) 向博主反馈问题","categories":[{"name":"python","slug":"python","permalink":"https://bubblewu.github.io/categories/python/"}],"tags":[{"name":"interviewer","slug":"interviewer","permalink":"https://bubblewu.github.io/tags/interviewer/"}]},{"title":"antdvp.vue-cli","slug":"vue/antdvp-vue-cli","date":"2020-05-06T17:32:13.000Z","updated":"2020-06-08T03:32:03.127Z","comments":true,"path":"ckbarvw2u003wyayd09jnel42/","link":"","permalink":"https://bubblewu.github.io/ckbarvw2u003wyayd09jnel42/","excerpt":"ant-design-vue-pro 使用脚手架 vue-cli 创建项目","text":"ant-design-vue-pro 使用脚手架 vue-cli 创建项目 vue create 12345678910111213#npm install -g @vue/cli vue --version @vue/cli 4.3.1vue create &lt;my-project-name&gt;# Vue CLI v4.3.1# ? Please pick a preset: Manually select features# ? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter# ? Use history mode for router? (Requires proper server setup for index fallback in production) Yes# ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less# ? Pick a linter / formatter config: Prettier# ? Pick additional lint features: Lint on save# ? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files# ? Save this as a preset for future projects? Yes# ? Save preset as: a-d-v-p Less、history123# Less: css加载器使用less，方便之后做主题颜色修改配置# history: 最终路由中不带#号，漂亮的url路由# In dedicated config files: 配置文件不堆积在package.json中；使用单独的配置文件vue.confi.js需手动新建 npm run serve123456# 验证第一步是否创建成功cd &lt;my-project-name&gt;npm run serve# 第二步 安装插件ant-design-vue 和 momentnpm i ant-design-vue moment vue.config.js12345678910111213141516171819202122232425262728# webpack配置之less-load引入mkdir vue.config.js# 修改vue.config.js文件，添加css内容module.exports = &#123; // less-load css: &#123; loaderOptions: &#123; less: &#123; // 这里的选项会传递给 less-loader javascriptEnabled: true &#125; &#125; &#125;# 组件和样式按需加载，优化减小前端加载流量# babel.config.js 文件配置module.exports = &#123; presets: [\"@vue/cli-plugin-babel/preset\"], plugins: [ [ \"import\", &#123; libraryName: \"ant-design-vue\", libraryDirectory: \"es\", style: true &#125; ] // `style: true` 会加载 less 文件 ]&#125;;# 安装插件 babel-plugin-importnpm i --save-dev babel-plugin-import 向博主反馈问题","categories":[{"name":"vue","slug":"vue","permalink":"https://bubblewu.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://bubblewu.github.io/tags/vue/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-30T17:32:13.000Z","updated":"2020-06-08T03:32:03.124Z","comments":true,"path":"ckbarvvzk0001yayd5fpg370n/","link":"","permalink":"https://bubblewu.github.io/ckbarvvzk0001yayd5fpg370n/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://bubblewu.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://bubblewu.github.io/tags/hexo/"}]}],"categories":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/categories/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/categories/Python/"},{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://bubblewu.github.io/categories/Java/JVM/"},{"name":"python","slug":"python","permalink":"https://bubblewu.github.io/categories/python/"},{"name":"Linux","slug":"Linux","permalink":"https://bubblewu.github.io/categories/Linux/"},{"name":"Git","slug":"Git","permalink":"https://bubblewu.github.io/categories/Git/"},{"name":"Charles","slug":"Charles","permalink":"https://bubblewu.github.io/categories/Charles/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://bubblewu.github.io/categories/Jenkins/"},{"name":"Interview","slug":"Interview","permalink":"https://bubblewu.github.io/categories/Interview/"},{"name":"Mac","slug":"Mac","permalink":"https://bubblewu.github.io/categories/Mac/"},{"name":"vue","slug":"vue","permalink":"https://bubblewu.github.io/categories/vue/"},{"name":"hexo","slug":"hexo","permalink":"https://bubblewu.github.io/categories/hexo/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/tags/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://bubblewu.github.io/tags/JVM/"},{"name":"celery","slug":"celery","permalink":"https://bubblewu.github.io/tags/celery/"},{"name":"copy","slug":"copy","permalink":"https://bubblewu.github.io/tags/copy/"},{"name":"git","slug":"git","permalink":"https://bubblewu.github.io/tags/git/"},{"name":"licenses","slug":"licenses","permalink":"https://bubblewu.github.io/tags/licenses/"},{"name":"jenkins","slug":"jenkins","permalink":"https://bubblewu.github.io/tags/jenkins/"},{"name":"interview","slug":"interview","permalink":"https://bubblewu.github.io/tags/interview/"},{"name":"shell","slug":"shell","permalink":"https://bubblewu.github.io/tags/shell/"},{"name":"firewalld","slug":"firewalld","permalink":"https://bubblewu.github.io/tags/firewalld/"},{"name":"network","slug":"network","permalink":"https://bubblewu.github.io/tags/network/"},{"name":"timedatectl","slug":"timedatectl","permalink":"https://bubblewu.github.io/tags/timedatectl/"},{"name":"nginx","slug":"nginx","permalink":"https://bubblewu.github.io/tags/nginx/"},{"name":"mongodb","slug":"mongodb","permalink":"https://bubblewu.github.io/tags/mongodb/"},{"name":"kafka","slug":"kafka","permalink":"https://bubblewu.github.io/tags/kafka/"},{"name":"gcc","slug":"gcc","permalink":"https://bubblewu.github.io/tags/gcc/"},{"name":"python","slug":"python","permalink":"https://bubblewu.github.io/tags/python/"},{"name":"jdk","slug":"jdk","permalink":"https://bubblewu.github.io/tags/jdk/"},{"name":"curl","slug":"curl","permalink":"https://bubblewu.github.io/tags/curl/"},{"name":"ssh-keygen","slug":"ssh-keygen","permalink":"https://bubblewu.github.io/tags/ssh-keygen/"},{"name":"scp","slug":"scp","permalink":"https://bubblewu.github.io/tags/scp/"},{"name":"mac","slug":"mac","permalink":"https://bubblewu.github.io/tags/mac/"},{"name":"interviewer","slug":"interviewer","permalink":"https://bubblewu.github.io/tags/interviewer/"},{"name":"vue","slug":"vue","permalink":"https://bubblewu.github.io/tags/vue/"},{"name":"hexo","slug":"hexo","permalink":"https://bubblewu.github.io/tags/hexo/"}]}