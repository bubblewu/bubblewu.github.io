<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发模式-1：Single Threaded Execution模式：能通过这座桥的只能有一个人</title>
      <link href="/ckd8g12ck0000v1yd2ymng4um/"/>
      <url>/ckd8g12ck0000v1yd2ymng4um/</url>
      
        <content type="html"><![CDATA[<p>Single Threaded Execution模式，即&quot;以一个线程执行&quot;。<br>就像独木桥一样，同一时间内只允许一个人通过，<strong>该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。</strong></p><ul><li>其实<code>主要思想</code>也就是：</li></ul><p><strong>当我们修改多个线程共享的实例时，实例就会失去安全性。所以我们找出这个不安全的范围，将这个范围设置为临界区，并对临界区进行保护（使用synchronized），使其只允许一个线程同时执行</strong>。</p><a id="more"></a><h2 id="Single-Threaded-Execution模式"><a href="#Single-Threaded-Execution模式" class="headerlink" title="Single Threaded Execution模式"></a>Single Threaded Execution模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Single Threaded Execution模式中会有一个发挥<code>SharedResource（共享资源）</code>作用的类。如下面案例中的门Gate这个类。</p><p><strong>SharedResource角色是可以被多个线程访问的类</strong>，包含很多方法，主要分类下面两类：</p><ul><li><code>safeMethod</code>：线程安全方法。多线程下不会发生问题。</li><li><code>unsafeMethod</code>：非线程安全方法。多个线程调用会出现问题，需进行保护，使其不被多个线程同时访问。</li></ul><p><strong>Single Threaded Execution模式会保护unsafeMethod，使其只能由一个线程访问</strong>，Java可以使用<code>synchronized关键字</code>。我们将<strong>允许单个线程执行的程序范围</strong>称为<code>临界区</code>。<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/concurrent/single-thread-execution.png" alt="Single Threaded Execution模式下的Timethreads图"></p><h3 id="什么时候使用？"><a href="#什么时候使用？" class="headerlink" title="什么时候使用？"></a>什么时候使用？</h3><ul><li><p><code>多线程时</code>：<br>单线程时不需要，使用的前提是多线程环境下。</p></li><li><p><code>多个线程访问时</code>：</p></li></ul><p><strong>当SharedResource角色的实例有可能被多个线程同时访问时</strong>，就需要使用Single Threaded Execution模式。</p><p>即使是多线程程序，如果所有线程都是完全独立操作的，那么就不需要使用该模式，当前状态为<code>线程互不干涉（interfere）</code>。<br>在某些多线程框架中，有时线程的独立性是由框架保证的，这时也不需使用该模式。</p><ul><li><code>状态有可能发生变化时</code>：<br>如果SharedResource角色的状态会发生变化时，就需使用该模式。</li></ul><p>如果创建实例后，实例的状态再也不会发生变化，则不需使用。如<code>只读不写</code>的情况。如<code>Immutable模式</code>时，实例的状态不会发生改变，也就不需要。</p><ul><li><code>需要确保安全性时</code>：<br>只有在需要确保安全性时，才需要使用该模式。<br>如：Java的集合类大多为非线程安全的，在使用时，这是为了在不需要考虑安全性的时候提高程序的运行速度。</li></ul><blockquote><p>线程安全的方法：<br>Java提供了下列方法，可以确保集合类是线程安全的。</p><ul><li>synchronizedCollection方法；</li><li>synchronizedList方法；</li><li>synchronizedMap方法；</li><li>synchronizedSet方法；</li><li>synchronizedSortedMap方法；</li><li>synchronizedSortedSet方法；</li></ul></blockquote><h3 id="安全性和synchronized"><a href="#安全性和synchronized" class="headerlink" title="安全性和synchronized"></a>安全性和synchronized</h3><p>Java使用关键字synchronized来实现执行线程的互斥处理。<br>同步方法（synchronized方法）： <strong>在方法前加synchronized关键字，每次只允许一个线程处理该方法。</strong></p><blockquote><p>synchronized实例方法、synchronized静态方法和synchronized代码块：</p><ul><li>synchronized代码块可以精确的控制互斥处理的执行范围。</li><li><strong>synchronized静态方法和synchronized实例方法使用的锁是不一样的。<code>synchronized静态方法是使用该类的类对象的锁来执行线程的互斥处理的</code></strong>，和synchronized代码块锁类时是等效的。</li></ul></blockquote><blockquote><p>需注意：</p><ul><li>某个线程在运行synchronized方法时，只会停止想要获取当前同一个实例的锁的线程；</li><li>非synchronized方法可以在任意时间被多个线程执行，即使存在正在运行其他的synchronized方法的线程，非synchronized方法也仍然可以由多个线程运行。</li><li>同一个实例的synchronized实例方法同时只能有一个线程运行，如实例不同，锁也就不同，所有就算是synchronized实例方法，也可以由多个线程同时运行。</li><li>同一个类下的多个synchronized静态方法不可以由多个线程同时运行，因为锁的是当前类对象。</li><li>synchronized方法通常会降低生存性，如容易引起死锁；添加不必要的synchronized，性能会降低，如吞吐量；</li></ul></blockquote><p>synchronized保护哪个对象的实例，就需对哪个对象加锁。<br>synchronized方法执行的操作，是不可分割的，能够防止多个线程交错的执行赋值操作，是<code>原子操作（Atomic）</code>。</p><blockquote><p>注意：如在一个bean实体中，分别对两个字段的set方法加锁也是不安全的，因为线程会单独赋值，<strong>需要将字段合在一起保护</strong>。</p></blockquote><ul><li><code>synchronized和lock/unlock</code></li></ul><p><strong>如果在lock和unlock之间出现return语句或异常处理，会导致unlock不会被调用</strong>。<br>而<strong>synchronized方法和代码块，无论是执行return还是抛出异常，都一定能释放锁</strong>。</p><p>不过lock和unlock操作，可以使用<code>finally块来执行unlock</code>。这样调用lock方法后，无论执行什么操作，都会调用unlock方法解锁。</p><ul><li><code>synchronized和volatile和juc包下的AtomicXXX</code><br>不使用synchronized，而<code>在声明该字段的时候加上volatile关键字，对该字段的操作也是原子的了</code>。<br><code>juc包下的AtomicXXX等类也是通过封装volatile功能而得到的类库</code>。</li></ul><p>所以：</p><ul><li>基本类型、引用类型的赋值和引用是原子操作；</li><li>但long和double在线程间共享时，需要加synchronized或声明为volatile。将其变为原子操作。</li></ul><h3 id="生存性和死锁"><a href="#生存性和死锁" class="headerlink" title="生存性和死锁"></a>生存性和死锁</h3><p>生存性是指无论什么时候，必要的处理都一定能够被执行。是程序正常运行的必要条件之一。<br>有时候安全性和生存性会互相制约。有时只重视安全性，生存性就会下降。典型代表就是<code>死锁（deadlook）</code>，即<strong>多个线程互相等待对方释放锁的情形</strong>。</p><p><strong>发生死锁的线程都无法再继续运行，程序也就失去了生存性</strong>。</p><blockquote><p>如：仅有勺子和叉子各一把，A和B都要吃意大利面，勺子和叉子缺一不可。A拿走了勺子，B拿走了叉子，两人互相僵持，最终谁也吃不了。</p></blockquote><p>在Single Threaded Execution模式中，满足下列条件时，死锁就会发生：</p><ul><li><p>存在多个SharedResource角色；</p><blockquote><p>多个SharedResource角色相当于勺子和叉子</p></blockquote></li><li><p>线程在持有着某个SharedResource角色的锁的同时，还想获取其他SharedResource角色的锁；</p><blockquote><p>相当于A拿着勺子同时还想拿叉子，B则相反。</p></blockquote></li><li><p>获取SharedResource角色的锁的顺序并不固定。（SharedResource角色是对称的）</p><blockquote><p>SharedResource角色是对称的，相当于“拿勺子-&gt;拿叉子”和“拿叉子-&gt;拿勺子”这两种操作。也就是说勺子和叉子二者并不分优先顺序。</p></blockquote></li></ul><p>只要破坏上面任何一个条件，就可以防止死锁的情况发生。<br>如：</p><ul><li><strong>多个线程按照相同的顺序去获取实例资源</strong>；</li><li><strong>将多个实例资源封装起来一齐拿，对整体做同步，如new Pair(A, B); 直接对pair做同步处理</strong>。</li></ul><h3 id="可复用性和继承反常"><a href="#可复用性和继承反常" class="headerlink" title="可复用性和继承反常"></a>可复用性和继承反常</h3><p>如果编写一个SharedResource角色的子类，如子类能访问SharedResource角色的字段，那么子类编写时，就容易出现unsafeMethod。<br>如果不将子类在内的所有unsafeMethod都声明为synchronized方法，那就无法确保SharedResource角色的安全性。</p><p>对于多线程来说，继承会引起一些麻烦的问题，称为<code>继承反常（inheritance anomaly）</code></p><h3 id="临界区的大小和性能"><a href="#临界区的大小和性能" class="headerlink" title="临界区的大小和性能"></a>临界区的大小和性能</h3><p>我们将<strong>允许单个线程执行的程序范围</strong>称为<code>临界区</code>。</p><blockquote><p>延长临界区的大小，可以使线程的安全性异常更早的暴露出来。如可以使用Thread.sleep()方法来提高检查出错误的可能性。<br>在临界区也可以调用Thread类等yield方法，加快线程的切换。</p><blockquote><p><code>Thread.yield()</code>方法作用是：<strong>暂停当前正在执行的线程对象，并执行其他线程</strong>。<br>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。<br>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p></blockquote></blockquote><p>一般情况下Single Threaded Execution模式会降低程序的性能。</p><ul><li><p><code>获取锁耗费时间</code>：<br>进入synchronized方法时，线程需要获取锁的对象，会耗费一定时间。<br>如果SharedResource角色的数量少了，那么要获取锁的数量也会减少，从而能够抑制性能的下降。</p></li><li><p><code>线程冲突引起的等待</code>：<br>当线程A进入临界区内处理时，其他想要进临界区的线程会阻塞。这种状况称为<code>线程冲突（conflict）</code>。<br>发生冲突时，程序的整体性能会随线程等待时间的增加而下降。</p></li></ul><blockquote><p>不容易发生线程冲突的<code>ConcurrentHashMap</code>：<br><strong>ConcurrentHashMap将内部数据结构分成多段，针对各段操作的线程互不干涉，因此无需针对其他线程执行互斥处理</strong>。</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>模拟三个人频繁地通过一个门，且该门一次只允许一个人经过的场景。<br>当人从该门通过时，统计人数会增加，同时还会记录通行者的姓名和出生地。</p><h3 id="不使用Single-Threaded-Execution模式"><a href="#不使用Single-Threaded-Execution模式" class="headerlink" title="不使用Single Threaded Execution模式"></a>不使用Single Threaded Execution模式</h3><p>面对该需求，如果不使用Single Thread Execution模式，在多线程环境下无法正确执行的程序会引发什么现象？<br>将该程序设计为三个类：</p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>Main</td><td>创建门，并让三个人不断通过的类</td></tr><tr><td>Gate</td><td>表示门的类。会记录通行者的姓名和出生地</td></tr><tr><td>UserThread</td><td>表示人的类。将不断有人通过门</td></tr></tbody></table><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.demo.single_thread_execution;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建门，并让三个人不断通过的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 15:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于Gate是非线程安全的，所以输出结果是混乱的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试开始，按[Ctrl + C]键退出"</span>);</span><br><span class="line">        <span class="comment">// 创建一个门，让三个人不断地通过</span></span><br><span class="line">        Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">        <span class="keyword">new</span> UserThread(gate,<span class="string">"A小王"</span>, <span class="string">"A北京"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> UserThread(gate,<span class="string">"B小李"</span>, <span class="string">"B上海"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> UserThread(gate,<span class="string">"C小苏"</span>, <span class="string">"C南京"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Gate类"><a href="#Gate类" class="headerlink" title="Gate类"></a>Gate类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示门的类。会记录通行者的姓名和出生地</span></span><br><span class="line"><span class="comment"> * 非线程安全/pass/toString方法加synchronized为线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 15:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示到目前为止已经通过这道门的人数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的姓名</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"NoBody"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的出生地</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"NoWhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示通过门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 在name和address赋值之间调用sleep，延长临界区，可以提高检查出错误的可能性，不需等数万次执行才发现。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查门的最后一个通行者的记录数据是否正确。</span></span><br><span class="line"><span class="comment">     * 注意：不需要添加synchronized。</span></span><br><span class="line"><span class="comment">     * 因为check方法只有pass方法会调用。且时私有的，也就是不会被其他类调用，所以是安全的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如姓名和首字母不同，说明数据异常</span></span><br><span class="line">        <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*** 异常 *** :"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": name='"</span> + name + <span class="string">", address="</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UserThread类"><a href="#UserThread类" class="headerlink" title="UserThread类"></a>UserThread类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.demo.single_thread_execution;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示人的类。将不断有人通过门</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 16:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserThread</span><span class="params">(Gate gate, String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gate = gate;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" BEGIN"</span>);</span><br><span class="line">        <span class="comment">// 反复调pass方法，表示这个人在门里不断地穿梭通过</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gate.pass(<span class="keyword">this</span>.name, <span class="keyword">this</span>.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>由于Gate是非线程安全的，pass方法会被多个线程执行。</p><ul><li>线程改写共享的实例字段时，并未考虑其他线程的操作。</li><li>对于name字段，互相竞争的线程获取的一方会先写入值，对于address同样如此，线程会再次竞争，获胜的一方先写入值。也就是所谓的<code>数据竞争</code>（Data Race）。</li></ul><p>所以输出结果是混乱的。<br>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** 异常 *** :No.88434: name&#x3D;&#39;A小王, address&#x3D;B上海</span><br><span class="line">*** 异常 *** :No.88657: name&#x3D;&#39;A小王, address&#x3D;C南京</span><br><span class="line">*** 异常 *** :No.88828: name&#x3D;&#39;C小苏, address&#x3D;C南京</span><br></pre></td></tr></table></figure><p>由上面执行日志可知：</p><ul><li>Gate类是非线程安全的。</li><li>测试无法证明安全性。<br>执行了上万次才发现异常，如仅执行几次就可能发现不了。</li><li>调试信息不可靠。<br>如：<code>*** 异常 *** :No.88828: name=&#39;C小苏, address=C南京</code>，输出了异常日志，但check验证的toString内容是正确的，好像并没有错误。</li></ul><p><strong>因为某个线程在执行check方法时，其他线程不断地执行pass方法，改写了name和address的值。</strong></p><h3 id="使用Single-Threaded-Execution模式"><a href="#使用Single-Threaded-Execution模式" class="headerlink" title="使用Single Threaded Execution模式"></a>使用Single Threaded Execution模式</h3><p>该案例在不使用Single Threaded Execution模式时，即Gate是非线程安全的类时，会出现数据竞争的情况，导致不符合程序执行的安全性标准。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>将Gate类修改为线程安全的类，只需要分别在pass方法和toString方法前添加synchronized关键字，这样Gate类就变成了线程安全的类。<br>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示门的类。会记录通行者的姓名和出生地</span></span><br><span class="line"><span class="comment"> * 非线程安全/pass/toString方法加synchronized为线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-29 15:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示到目前为止已经通过这道门的人数</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的姓名</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"NoBody"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示最后一个通行者的出生地</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"NoWhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示通过门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 在name和address赋值之间调用sleep，延长临界区，可以提高检查出错误的可能性，不需等数万次执行才发现。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查门的最后一个通行者的记录数据是否正确。</span></span><br><span class="line"><span class="comment">     * 注意：不需要添加synchronized。</span></span><br><span class="line"><span class="comment">     * 因为check方法只有pass方法会调用。且时私有的，也就是不会被其他类调用，所以是安全的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如姓名和首字母不同，说明数据异常</span></span><br><span class="line">        <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*** 异常 *** :"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一般来说，多个线程共享的字段必须使用synchronized或者volatile来保护。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设当线程A正在执行pass方法时，其他线程B调用了toString方法。</span></span><br><span class="line"><span class="comment">     * 在线程B引用了name字段的值，但尚未引用address期间，线程A可能会修改address的值。</span></span><br><span class="line"><span class="comment">     * 这样，toString方法对线程B创建时使用name和address对首字母就可能会不一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": name='"</span> + name + <span class="string">", address="</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，无论等待多久，都不会出现异常情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试开始，按[Ctrl + C]键退出</span><br><span class="line">A小王 BEGIN</span><br><span class="line">B小李 BEGIN</span><br><span class="line">C小苏 BEGIN</span><br></pre></td></tr></table></figure><p>因为：<br>Java使用关键字synchronized来实现执行线程的互斥处理。 <strong>在方法前加synchronized关键字，每次只允许一个线程处理该方法。</strong></p><p>针对该案例添加了synchronized方法：在线程A执行pass方法时，线程B就无法再执行pass方法，会阻塞在pass方法的入口处，直到线程A执行释放了pass方法的锁，线程B才可以去获取pass方法的锁，获得锁后再执行。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="相关的设计模型"><a href="#相关的设计模型" class="headerlink" title="相关的设计模型"></a>相关的设计模型</h3><p>许多与多线程、并发性相关的模式都跟Single Threaded Execution模式有关联。</p><h4 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h4><p>Guarded Suspension模式：<strong>如果执行现在的处理会造成问题，就让执行处理的线程等待</strong>。这种模式通过让线程等待来保证实例的安全性。</p><p>在Single Threaded Execution模式中，是否发生线程等待取决于<strong>是否有其他线程正在执行受保护的unsafeMethod</strong>。<br>而在Guarded Suspension模式中，取决于<strong>对象的状态是否合适</strong>。在检查对象状态的部分就使用了STE模式。</p><h4 id="Read-Write-Lock模式"><a href="#Read-Write-Lock模式" class="headerlink" title="Read-Write Lock模式"></a>Read-Write Lock模式</h4><p>在Read-Write Lock模式中，<code>读取操作和写入操作是分开考虑的。在执行读取操作之前，线程必须获取用于读取的锁；在执行写入操作之前，线程必须获取用于写入的锁</code>。所以：</p><ul><li><strong>当一个线程在读取时，其他线程可以读取，但是不可以写入</strong>。</li><li><strong>当一个线程正在写入时，其他线程不可以读取或写入</strong>。<br>因为执行互斥处理会降低程序的性能，但是如果把写入的互斥处理和读取的互斥处理分开来考虑，就可以提高系统性能。</li></ul><p>在STE模式中，如受保护的unsafeMethod正在被一个线程执行，那么想要执行该方法的其他线程必须等待该线程执行结束。</p><p>而Read-Write Lock模式中，多个线程可以同时执行read方法，这时需要等待的只有想要执行的write方法的线程。<br>在Read-Write Lock模式中，检查线程种类和个数部分，就使用了STE模式。</p><h4 id="Immutable模式"><a href="#Immutable模式" class="headerlink" title="Immutable模式"></a>Immutable模式</h4><p><strong>一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变模式。</strong><br>在STE模式中，unsafeMethod必须要加以保护，确保只允许一个线程执行。<br>而在Immutable不变模式中，其对象的状态不会发生变化，所以所有方法都不需要进行保护，也就是<code>Immutable模式中的所有方法都是safeMethod</code>。</p><h4 id="Thread-Specific-Storage模式"><a href="#Thread-Specific-Storage模式" class="headerlink" title="Thread-Specific Storage模式"></a>Thread-Specific Storage模式</h4><p>在STE模式中，会有多个线程访问SharedResource角色，所以需要保护方法，对线程进行交通管制。<br>而<code>Thread-Specific Storage模式会确保每个线程都有其固有的区域，且这块固有区域仅由一个线程访问</code>。所以也无需保护方法。<br>如:<code>ThreadLocal类</code> 一个线程会有自己独立的储物柜。</p><h3 id="信号量：Semaphore"><a href="#信号量：Semaphore" class="headerlink" title="信号量：Semaphore"></a>信号量：Semaphore</h3><p>STE模式用于确保某个区域只能由一个线程来执行。<br>如果保证某个区域<strong>最多只能由N个线程执行</strong>，那就需要使用juc包下的计数信号量Semaphore来控制线程数量。</p><ul><li><code>资源的许可个数permits</code>通过Semaphore的构造函数来制定：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><code>acquire方法</code>：用于确保存在可用资源。<br>在存在可用资源时，程序会立即从acquire方法返回，同时信号量内部的资源个数会减1.<br>如无可用资源，线程则阻塞在acquire方法内，直到有可用资源。</li><li><code>release方法</code>：用于释放资源。<br>释放资源后，信号量内部的资源个数会加1。<br>同时，如果acquire中存在等待的线程，那么其中一个线程会被唤醒，并从acquire方法返回。</li></ul><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>10个线程交替使用资源，但同时使用的资源最多只能是3个。</p><ul><li>Main类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置3个资源</span></span><br><span class="line">        BoundedResource resource = <span class="keyword">new</span> BoundedResource(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 10个线程交替使用资源，但同时使用的资源最多只能是3个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> UserThread(resource).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: -&gt; Begin: used &#x3D; NO.1</span><br><span class="line">Thread-1: -&gt; Begin: used &#x3D; NO.2</span><br><span class="line">Thread-2: -&gt; Begin: used &#x3D; NO.3</span><br><span class="line">Thread-2: &lt;--- End: used &#x3D; NO.3</span><br><span class="line">Thread-3: -&gt; Begin: used &#x3D; NO.3</span><br><span class="line">Thread-0: &lt;--- End: used &#x3D; NO.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>UserThread用户线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BoundedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserThread</span><span class="params">(BoundedResource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.resource.use();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">3000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BoundedResource使用资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> permits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedResource</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(permits);</span><br><span class="line">        <span class="keyword">this</span>.permits = permits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Log.println(<span class="string">"-&gt; Begin: used = NO."</span> + (<span class="keyword">this</span>.permits - <span class="keyword">this</span>.semaphore.availablePermits()));</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">        Log.println(<span class="string">"&lt;--- End: used = NO."</span> + (<span class="keyword">this</span>.permits - <span class="keyword">this</span>.semaphore.availablePermits()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Log日志类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发模式-2：Immutable不变模式</title>
      <link href="/ckde6cvxs0000a5yd0wtz6h6h/"/>
      <url>/ckde6cvxs0000a5yd0wtz6h6h/</url>
      
        <content type="html"><![CDATA[<p>Immutable不变模式就是指：<strong>确保实例的内部状态不会发生改变，这样在访问这些实例时就不需要增加耗时的互斥处理</strong>（如Single Threaded Execution模式中的对临界区进行互斥保护）。</p><p>如<code>String类</code>就是一个Immutable类。因为<strong>String类中使用final关键字修饰字符串数组<code>private final char value[];</code>来保存字符串</strong>，并没有修改字符串内容的方法。所以，String的实例所表示的字符串的内容不会发生变化。</p><a id="more"></a><h2 id="Immutable不变模式"><a href="#Immutable不变模式" class="headerlink" title="Immutable不变模式"></a>Immutable不变模式</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>Immutable角色是一个类，在这个角色中，<strong>字段的值是不可以修改的，也不存在修改字段内容的方法。</strong> <code>Immutable角色的实例被创建后，状态就不会再发生变化，也就不需要使用Single Threaded Execution模式使用synchronized去保护临界区</code>。</p><h3 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h3><p>Immutable模式该在哪些情况下使用呢？</p><ul><li><code>实例创建后，状态不再发生变化时</code>：</li></ul><p><strong>实例创建后，状态不再发生变化</strong>是必要条件。实例的状态是由字段的值决定的，所以<strong>将字段声明为<code>final字段</code>，且<code>不存在setter方法</code>是重点所在</strong>。<br>但即使这样，也有可能是可变的，因为<strong>即使字段的值不发生变化，但字段引用的实例有可能会发生变化</strong>。</p><ul><li><code>实例是共享的，且被频繁访问时</code>：<br>Immutable模式的优点是<strong>不使用synchronized来保护临界区</strong>。就意味着<strong>能够在不失去安全性和生存性的前提下提高性能</strong>。所以在当实例被多个线程共享时，且有可能被频繁访问时，Immutable模式的优点就会极大的凸显出来。</li></ul><h3 id="成对的mutable可变类和immutable不可变类"><a href="#成对的mutable可变类和immutable不可变类" class="headerlink" title="成对的mutable可变类和immutable不可变类"></a>成对的mutable可变类和immutable不可变类</h3><p>假设一个类，被多线程访问，使用synchronized进行保护，但类中存在setter方法。这样看起来Immutable模式是不成立的。</p><ul><li><p>场景一：<br>如果这个setter方法并未被使用，就可以将字段声明为final并删除setter方法，这样就遵守了不可变性，就成功改造为Immutable模式了。</p></li><li><p>场景二：<br>如果setter方法被使用了，这个类就是mutable可变模式了。<br>我们可以分析该类，如可以分为使用setter方法和不使用的情况，就可以将这个类拆分为mutable类和immutable类，然后设计成可以根据mutable实例创建immutable实例，也可以反过来根据immutable实例创建mutable实例。<br>如：StringBuffer类和String类。<br>StringBuffer类是mutable类，表示的字符能够随便改写，使用了synchronized保护。而String类表示字符串不可以被改写，也没使用synchronized保护，所以性能比较高。<br>但<strong>StringBuffer类中有一个以String为参数的构造函数，而String类中有一个以StringBuffer为参数的构造函数</strong>。也就是，<code>两者的实例是可以互相转换的</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String类的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//StringBuffer类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，<code>如果需要频繁改变字符串内容，就使用StringBuffer类，如果不需要改变，只是引用其内容，就使用String类</code>。<br>但<code>当多个字符串组成新的字符串时，StringBuffer类的速度比String类快</code>。</p></li></ul><p>注意：<br><strong>在Immutable类中调用mutable类时需注意安全性，需要对mutable类进行安全保护，否则，可变类中的值可能会被其他线程使用该类的setter方法改写字段值，导致值发生变化</strong>。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="标准类库中的Immutable模式"><a href="#标准类库中的Immutable模式" class="headerlink" title="标准类库中的Immutable模式"></a>标准类库中的Immutable模式</h3><ul><li><p>表示字符串的<code>java.lang.String类</code>：<br>再创建完实例后，字符串的内容不会发生变化，因为<strong>使用<code>final关键字</code>修饰字符串数组<code>private final char value[];</code>来保存字符串</strong>，并没有修改字符串内容的方法。</p></li><li><p>表示大数字的<code>java.math.BigInteger类</code>和<code>java.math.BigDecimal类</code>：</p></li><li><p>表示正则表达式模式的<code>java.util.regex.Pattern类</code>：<br>Pattern类表示正则表达式的模式，即使在处理模式匹配时，值也不会发生变化。</p></li><li><p><code>java.lang.Integer类等</code>：<br>Integer和Short等<code>基本类型的包装类（wrapper class）</code>都是immutable类型的，创建好实例后，也都不会发生变化。</p></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>创建一个Person类，并启动三个线程来访问该实例，会发现它们都是线程安全的。</p><ul><li><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示人的类：</span></span><br><span class="line"><span class="comment"> * - 线程安全的：</span></span><br><span class="line"><span class="comment"> * 字段值仅可以通过构造函数来设置，没有setXX方法。</span></span><br><span class="line"><span class="comment"> * 所以，Person类的实例一旦创建，其字段的值就不会发生变化。</span></span><br><span class="line"><span class="comment"> * 这时，即使多个线程同时访问同一个实例，该类也是安全的。</span></span><br><span class="line"><span class="comment"> * Person类中的所有方法无需声明为synchronized，就可以允许多个线程同时执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 防止子类修改其字段值：</span></span><br><span class="line"><span class="comment"> * 1、Person声明为final类型。表示我们无法创建其类的子类，也是防止子类修改其字段值的一种措施。</span></span><br><span class="line"><span class="comment"> * 2、字段的可见性都为private。表示这2个字段都只有从该类的内部才可以访问。</span></span><br><span class="line"><span class="comment"> * 3、字段都声明为final类型。表示一旦字段被赋值一次，就不会再被赋值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-31 18:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Person: "</span> + <span class="string">"name = "</span> + name + <span class="string">", address = "</span> + address + <span class="string">']'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PrintPersonThread类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示Person实例的线程的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-31 18:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintPersonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintPersonThread</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// sleep 让各线程可以清晰的交叉打印</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" prints "</span> + person.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Main类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Person类，并启动三个线程来访问该实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"Bubble"</span>, <span class="string">"北京"</span>);</span><br><span class="line">        <span class="keyword">new</span> PrintPersonThread(person).start();</span><br><span class="line">        <span class="keyword">new</span> PrintPersonThread(person).start();</span><br><span class="line">        <span class="keyword">new</span> PrintPersonThread(person).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 prints [Person: name &#x3D; Bubble, address &#x3D; 北京]</span><br><span class="line">Thread-2 prints [Person: name &#x3D; Bubble, address &#x3D; 北京]</span><br><span class="line">Thread-0 prints [Person: name &#x3D; Bubble, address &#x3D; 北京]</span><br><span class="line">Thread-2 prints [Person: name &#x3D; Bubble, address &#x3D; 北京]</span><br><span class="line">Thread-0 prints [Person: name &#x3D; Bubble, address &#x3D; 北京]</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h3><h4 id="Single-Threaded-Execution模式"><a href="#Single-Threaded-Execution模式" class="headerlink" title="Single Threaded Execution模式"></a>Single Threaded Execution模式</h4><p>Immutable模式下，实例的状态不会发生变化，所以无需进行保护。<br>而STE模式，当一个线程正在修改实例状态时，不允许其他的线程来访问该实例。<br>这时会出现下面两种情况之一：</p><ul><li><code>写入与写入的冲突</code>（write-write conflict）：<br>当一个线程正在修改实例状态，而其他线程也试图修改其状态时发生的冲突。</li><li><code>读取和写入的冲突</code>（read-write conflict）：<br>当一个线程正在读取实例状态，而其他线程试图修改其状态时发生的冲突。</li></ul><p>而immutable模式中，只会发生read-read当情况，不会出现conflict。</p><h4 id="Read-Wrire-Lock模式"><a href="#Read-Wrire-Lock模式" class="headerlink" title="Read-Wrire Lock模式"></a>Read-Wrire Lock模式</h4><p>在Read-Write Lock模式中，<code>读取操作和写入操作是分开考虑的。在执行读取操作之前，线程必须获取用于读取的锁；在执行写入操作之前，线程必须获取用于写入的锁</code>。所以：</p><ul><li><strong>当一个线程在读取时，其他线程可以读取，但是不可以写入</strong>。</li><li><strong>当一个线程正在写入时，其他线程不可以读取或写入</strong>。<br>因为执行互斥处理会降低程序的性能，但是如果把写入的互斥处理和读取的互斥处理分开来考虑，就可以提高系统性能。</li></ul><p>Immutable模式中，只会发生read-read当情况，不会出现conflict。所以多线程可以自由的访问实例。<br>而Read-Write Lock模式也利用了read-read不会引起冲突的特点。它执行read的线程和执行write的线程是分开考虑的。能够提高程序的性能。</p><h4 id="Flyweight模式（享元模式）"><a href="#Flyweight模式（享元模式）" class="headerlink" title="Flyweight模式（享元模式）"></a>Flyweight模式（享元模式）</h4><p>享元模式的主要目的是<code>实现对象的共享</code>，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。<br>在Flyweight模式中，为了提高内存的使用效率，会共享实例。所以，Immutable模式和Flyweight模式有时是可以同时使用的。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final类主要用在三个地方：类、方法、变量。</p><p>Java中的final类有多种不同的用途，含义也不同。</p><ul><li><p><code>final类</code>：<br>当final修饰一个类时，表示该类不能被继承，即无法扩展。也就是说无法创建final类的子类，所以final类中声明的方法也就不会被重写。<br>final类中的所有成员方法都会被隐式地指定为final方法；</p></li><li><p><code>final方法</code>：<br>实例方法使用final，表示该方法不会被子类的方法重写。即可以把方法锁定，以防止任何继承类修改它的含义。<br>静态方法使用final，表示该方法不会被子类的方法隐藏，如果试图重写或隐藏编译时会提示错误。<br>类中所有的private方法都被隐式地指定为final。</p></li><li><p><code>final变量</code>：<br>对于一个final变量，如果是基本数据类型的变量，则其数值一旦初始化之后就不能更改；<br>如是引用类型的变量，则对其初始化之后便不能再让它指向另一个对象。</p><blockquote><ul><li><strong>final字段</strong>：<br>final字段只能被赋值一次。<br>对<code>final实例字段赋值</code>的方法有2种：<br>1、一种在字段声明时赋上初始值；<br>2、一种在构造函数中对字段赋值；<br>对<code>final静态字段赋值</code>的方法也有2种：<br>1、一种在字段声明时赋上初始值；<br>2、在static静态代码块中对字段赋值；<br>注意：final字段不可以使用setter方法再次赋值。</li></ul></blockquote></li></ul><blockquote><ul><li><strong>final变量和final参数</strong>：<br>局部变量和方法的参数，也可以声明为final，可以赋值一次。<br>但final参数不可以赋值，因为调用方法时，已经对其赋值了。</li></ul></blockquote><h3 id="集合类和多线程"><a href="#集合类和多线程" class="headerlink" title="集合类和多线程"></a>集合类和多线程</h3><h4 id="非线程安全的ArrayList类"><a href="#非线程安全的ArrayList类" class="headerlink" title="非线程安全的ArrayList类"></a>非线程安全的ArrayList类</h4><p>java.util.ArrayList类用于提供可调整大小的数组，是非线程安全的。</p><h4 id="Collections-synchronizedList同步集合类"><a href="#Collections-synchronizedList同步集合类" class="headerlink" title="Collections.synchronizedList同步集合类"></a>Collections.synchronizedList同步集合类</h4><p>java.util.ArrayList类是非线程安全的类，可以使用Collections.synchronizedList方法对其进行同步，就能得到线程安全的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><h4 id="写时复制（copy-on-write）的CopyOnWriteArrayList类"><a href="#写时复制（copy-on-write）的CopyOnWriteArrayList类" class="headerlink" title="写时复制（copy-on-write）的CopyOnWriteArrayList类"></a>写时复制（copy-on-write）的CopyOnWriteArrayList类</h4><p>java.util.concurrent.CopyOnWriteArrayList类是线程安全的。与使用Collections.synchronizedList不同，它<strong>采用了<code>写时复制Copy-On-Write技术</code>来避免读写冲突</strong>。<br>如果使用Copy-On-Write，当对集合执行写操作时，内部已确保安全的数组就会被整体复制。复制之后，就不需在使用迭代器依次读取元素时担心元素会被修改了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在使用copy-on-write时，每次执行写操作时，都会执行复制，会耗费较多时间。所以该类适合在<code>写少读多，且读操作频率非常高</code>的场景。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发：多线程程序的评价标准</title>
      <link href="/ckd70wo7j0017qlydgj2w1nq3/"/>
      <url>/ckd70wo7j0017qlydgj2w1nq3/</url>
      
        <content type="html"><![CDATA[<p>针对多线程程序，我们不能单纯的来指出是好还是坏，需要遵循一定的评价标准来规范的指出好在哪里、差在哪里？</p><p>其实也就是：</p><ul><li>安全性和生存性：程序的必要条件；</li><li>可复用性和性能：提高程序质量条件；</li></ul><a id="more"></a><h2 id="主要标准"><a href="#主要标准" class="headerlink" title="主要标准"></a>主要标准</h2><p>有下面四个主要标准：</p><h4 id="安全性（Safety）：不损坏对象"><a href="#安全性（Safety）：不损坏对象" class="headerlink" title="安全性（Safety）：不损坏对象"></a>安全性（Safety）：不损坏对象</h4><p>安全性就是不损坏对象，是程序正常执行的必要条件之一。<br>对象损坏是指<strong>对象的状态和设计者的原意不一致，通常是指对象的字段的值并非预期值</strong>。<br>如果一个类即使被多个线程同时使用，也可以确保安全性，那么这个类就是<code>线程安全类</code>（Thread Safe）。如集合类中的Vector类是线程安全的，而ArrayList类则是非线程安全的。</p><h4 id="生存性（Liveness）：必要的处理能够被执行"><a href="#生存性（Liveness）：必要的处理能够被执行" class="headerlink" title="生存性（Liveness）：必要的处理能够被执行"></a>生存性（Liveness）：必要的处理能够被执行</h4><p>生存性是指无论什么时候，必要的处理都一定能够被执行。也是程序正常运行的必要条件之一。</p><p>需注意，即使对象没有损坏，也不一定代表程序一定好。如程序在运行过程中突然停止，而对象的状态未改变，所以对象的状态就不会出现异常，也就是符合了<code>安全性</code>条件，但是程序的执行无任何意义，不符合<code>生存性</code>的条件。</p><p>有时候安全性和生存性会互相制约。有时只重视安全性，生存性就会下降。典型代表就是<code>死锁（deadlook）</code>，<strong>即多个线程互相等待对方释放锁的情形。</strong></p><h4 id="可复用性（Reusability）：类可重复利用"><a href="#可复用性（Reusability）：类可重复利用" class="headerlink" title="可复用性（Reusability）：类可重复利用"></a>可复用性（Reusability）：类可重复利用</h4><p>可复用性是指类能够重复利用。是提高程序质量的必要条件。<br>类如果能作为组件从正常运行的程序中分割出来，那么说明这个类有很高的可复用性。</p><h4 id="性能（Performance）：能快速、大批量地执行处理"><a href="#性能（Performance）：能快速、大批量地执行处理" class="headerlink" title="性能（Performance）：能快速、大批量地执行处理"></a>性能（Performance）：能快速、大批量地执行处理</h4><p>性能是指能快速、大批量地执行处理。也是提高程序质量的必要条件。</p><p>影响性能的因素有多种：</p><ul><li><p>吞吐量（throughpt）：<br>指单位时间内完成的处理数量。能完成的处理越多，表示吞吐量越大。</p></li><li><p>响应性（responsiveness）：<br>指从发出请求到收到响应的时间。响应性好即等待时间（latency）短。</p></li><li><p>容量（capacity）：<br>指可以同时进行的处理数量。如服务器能同时处理的客户端数或文件数等。</p></li><li><p>效率（efficiency）：</p></li><li><p>可伸缩性（scalability）：</p></li><li><p>降级（degradation）：</p></li></ul><p>有时这些要素之间会相互制约，如提高吞吐量，可能会导致程序的响应性下降。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>安全性</code>和<code>生存性</code>是程序必备的条件</strong>。即既不能损坏对象，也一定要执行必要的处理。<br>在此基础之上，还需考虑如何提高程序的高可复用性和性能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手实现：检查程序名称规范的编译器插件</title>
      <link href="/ckd70wo70000bqlyd3k4v9lhx/"/>
      <url>/ckd70wo70000bqlyd3k4v9lhx/</url>
      
        <content type="html"><![CDATA[<p>该案例主要为实现一个检查Java代码规范的编译器插件功能，编码规范遵循下面标准：</p><ul><li>类或接口：符合驼式命名法，首字母大写。</li><li>方法：符合驼式命名法，首字母小写。</li><li>字段：<br>类或实例变量。符合驼式命名法，首字母小写。<br>常量。要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。</li></ul><p>驼式命名法（Camel Case Name）是当前Java语言中主流的命名规范，我们的实战目标就是为Javac编译器添加一个额外的功能，在编译程序时检查程序名是否符合上述对类（或接口）、方法、字段的命名要求。</p><a id="more"></a><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="AbstractProcessor抽象类"><a href="#AbstractProcessor抽象类" class="headerlink" title="AbstractProcessor抽象类"></a>AbstractProcessor抽象类</h3><p>实现注解处理器的代码需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>，这个抽象类中只有一个子类必须实现的抽象方法<code>process()</code>。</p><blockquote><p>它是Javac编译器在执行注解处理器代码时要调用的过程。</p><ul><li>我们可以从这个方法的第一个参数<code>annotations</code>中获取到此注解处理器所要处理的注解集合；</li><li>从第二个参数<code>roundEnv</code>中访问到当前这个轮次（Round）中的抽象语法树节点，每个语法树节点在这里都表示为一个Element。</li></ul></blockquote><p>AbstractProcessor抽象类还有一个很重要的实例变量<code>processingEnv</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Processing environment providing by the tool framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">protected</span> ProcessingEnvironment processingEnv;</span><br></pre></td></tr></table></figure><p>它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init()方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。</p><h3 id="ElementKind枚举类"><a href="#ElementKind枚举类" class="headerlink" title="ElementKind枚举类"></a>ElementKind枚举类</h3><p>在javax.lang.model.ElementKind中定义了17类Element，已经包括了Java代码中可能出现的全部元素。</p><ul><li><code>javax.lang.model.ElementKind</code>枚举类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementKind &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declared types</span></span><br><span class="line">    <span class="comment">/** 枚举 */</span></span><br><span class="line">    ENUM,</span><br><span class="line">    <span class="comment">/** 类 */</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">/** 注解 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INTERFACE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Variables</span></span><br><span class="line">    <span class="comment">/** 枚举值. */</span></span><br><span class="line">    ENUM_CONSTANT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 本地变量. */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 异常. */</span></span><br><span class="line">    EXCEPTION_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executables</span></span><br><span class="line">    <span class="comment">/** 方法. */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 构造函数. */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 静态语句块 即static&#123;&#125;块. */</span></span><br><span class="line">    STATIC_INIT,</span><br><span class="line">    <span class="comment">/** 实例语句块 即&#123;&#125;块. */</span></span><br><span class="line">    INSTANCE_INIT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数化类型：泛型尖括号内的类型. */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未定义的其他语法树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OTHER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源变量：try-resource中定义d变量.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RESOURCE_VARIABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this is a kind of class:</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> CLASS&#125; or &#123;<span class="doctag">@code</span> ENUM&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this is a kind of class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == CLASS || <span class="keyword">this</span> == ENUM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this is a kind of interface:</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> INTERFACE&#125; or &#123;<span class="doctag">@code</span> ANNOTATION_TYPE&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this is a kind of interface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == INTERFACE || <span class="keyword">this</span> == ANNOTATION_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this is a kind of field:</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> FIELD&#125; or &#123;<span class="doctag">@code</span> ENUM_CONSTANT&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this is a kind of field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == FIELD || <span class="keyword">this</span> == ENUM_CONSTANT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="两个注解"><a href="#两个注解" class="headerlink" title="两个注解"></a>两个注解</h3><p>注解处理器除了process()方法及其参数之外，还有两个经常配合着使用的注解，分别是：</p><ul><li><code>@SupportedAnnotationTypes</code>：<br>代表了这个注解处理器对哪些注解感兴趣，可以使用星号 <code>*</code> 作为通配符代表对所有的注解都感兴趣。</li><li><code>@SupportedSourceVersion</code>：<br>指出这个注解处理器可以处理哪些版本的Java代码。</li></ul><p>每一个注解处理器在运行时都是<code>单例的</code>，如果不需要改变或添加抽象语法树中的内容，process()方法就可以返回一个值为false的布尔值，通知编译器这个轮次中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process()方法的返回值一律都是false。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="注解处理器NameCheckProcessor"><a href="#注解处理器NameCheckProcessor" class="headerlink" title="注解处理器NameCheckProcessor"></a>注解处理器NameCheckProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入式注解处理器：对Java程序命名进行检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-28 16:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 表示支持所有的Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK8的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnv 它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init()方法执行的时候）创建，</span></span><br><span class="line"><span class="comment">     *                      继承了AbstractProcessor的注解处理器代码可以直接访问它。</span></span><br><span class="line"><span class="comment">     *                      它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该方法是Javac编译器在执行注解处理器代码时要调用的过程：</span></span><br><span class="line"><span class="comment">     * 每一个注解处理器在运行时都是单例的，如果不需要改变或添加抽象语法树中的内容，</span></span><br><span class="line"><span class="comment">     * process() 方法就可以返回一个值为false的布尔值，通知编译器这个轮次中的代码未发生变化，无须构造新的 JavaCompiler实例。</span></span><br><span class="line"><span class="comment">     * 自定义的此注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process()方法的返回值一律都是false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotations 获取到此注解处理器所要处理的注解集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnv 参数“roundEnv”中访问到当前这个轮次（Round）中的抽象语法树节点，</span></span><br><span class="line"><span class="comment">     *                 每个语法树节点在这里都表示为一个Element。</span></span><br><span class="line"><span class="comment">     *                 在javax.lang.model.ElementKind中定义了18类Element。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            roundEnv.getRootElements().forEach(element -&gt; nameChecker.checkNames(element));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名检查器NameChecker"><a href="#命名检查器NameChecker" class="headerlink" title="命名检查器NameChecker"></a>命名检查器NameChecker</h4><p>它通过一个继承于<code>javax.lang.model.util.ElementScanner8</code>的NameCheckScanner类，以Visitor模式来完成对语法树的遍历，分别执行visitType()、visitVariable()和visitExecutable()方法来访问类、字段和方法，这3个visit*()方法对各自的命名规则做相应的检查，checkCamelCase()与checkAllCaps()方法则用于实现驼式命名法和全大写命名规则的检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner8;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.tools.Diagnostic.Kind.WARNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查程序名称规范的编译器插件：</span></span><br><span class="line"><span class="comment"> * 如果程序命名不符合规范，会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-28 16:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Messager用于向编译器发送信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NameChecker</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     * - 类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * - 方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * - 字段：</span></span><br><span class="line"><span class="comment">     * 类或实例变量。符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * 常量。要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类。</span></span><br><span class="line"><span class="comment">     * 继承了ElementScanner8，会以Visitor模式访问抽象语法树中的元素。</span></span><br><span class="line"><span class="comment">     * 命名规则判断中将不对语法树进行修改，因此全部返回值都为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner8</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ElementKind.METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName())) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法["</span> + name + <span class="string">"]不应当与类名重复，避免与构造函数产生冲突"</span>);</span><br><span class="line">                    checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e)) &#123;</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == ElementKind.INTERFACE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == ElementKind.FIELD || e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="comment">// 前缀首字母大写</span></span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称["</span> + name + <span class="string">"]应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称["</span> + name + <span class="string">"]应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!conventional) &#123;</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称["</span> + name + <span class="string">"]应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional) &#123;</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量["</span> + name + <span class="string">"]应当全部以大写字母或下划线命名，并且以字母开头"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译测试"><a href="#编译测试" class="headerlink" title="编译测试"></a>编译测试</h2><h3 id="命名规范的“反面教材”代码"><a href="#命名规范的“反面教材”代码" class="headerlink" title="命名规范的“反面教材”代码"></a>命名规范的“反面教材”代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.processor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命名规范的“反面教材”代码：</span></span><br><span class="line"><span class="comment"> * 使用：</span></span><br><span class="line"><span class="comment"> * 可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，</span></span><br><span class="line"><span class="comment"> * 如果有多个注解 处理器的话，用逗号分隔。</span></span><br><span class="line"><span class="comment"> * 还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-28 17:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译测试-1"><a href="#编译测试-1" class="headerlink" title="编译测试"></a>编译测试</h3><p>们可以通过<code>Javac</code>命令的<code>-processor参数</code>来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。<br>还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运 作的详细信息。</p><p>编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd code/java/multi-dev/data-structure/src/main/java/</span><br><span class="line">javac com/bubble/processor/NameChecker.java</span><br><span class="line">javac com/bubble/processor/NameCheckProcessor.java</span><br><span class="line"></span><br><span class="line">javac -processor com.bubble.processor.NameCheckProcessor com/bubble/processor/BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F;bubble&#x2F;processor&#x2F;BADLY_NAMED_CODE.java:13: 警告: 名称[BADLY_NAMED_CODE]应当符合驼式命名法（Camel Case Names）</span><br><span class="line">public class BADLY_NAMED_CODE &#123;</span><br><span class="line">       ^</span><br><span class="line">com&#x2F;bubble&#x2F;processor&#x2F;BADLY_NAMED_CODE.java:15: 警告: 名称[colors]应当以大写字母开头</span><br><span class="line">    enum colors &#123;</span><br><span class="line">    ^</span><br><span class="line">警告: 常量[red]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 常量[blue]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 常量[green]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 常量[_FORTY_TWO]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 一个普通方法[BADLY_NAMED_CODE]不应当与类名重复，避免与构造函数产生冲突</span><br><span class="line">com&#x2F;bubble&#x2F;processor&#x2F;BADLY_NAMED_CODE.java:22: 警告: 名称[BADLY_NAMED_CODE]应当以小写字母开头</span><br><span class="line">    protected void BADLY_NAMED_CODE() &#123;</span><br><span class="line">                   ^</span><br><span class="line">8 个警告</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>002 虚拟机对象</title>
      <link href="/ckd70wo7k0018qlyd6k1i1bxu/"/>
      <url>/ckd70wo7k0018qlyd6k1i1bxu/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><a id="more"></a><h1 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="对象的创建流程"><a href="#对象的创建流程" class="headerlink" title="对象的创建流程"></a>对象的创建流程</h3><ul><li>使用new指令来创建对象；</li><li>首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化；</li><li>如果没有，说明是新建，就先执行相应的类加载的过程；</li><li>类加载检查通过后，为虚拟机新生对象分配堆内存；</li><li>堆内存分配成功后，再把分配到的内存空间（不包括对象头）都初始化为零值；</li><li>再执行类文件的<init>()方法，按照Dev的设定来进行构造，把对象进行初始化，得到一个真正的对象。</init></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code>。</p><h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>对象头包括两类信息：一是<code>用于存储对象自身的运行时数据</code>；二是<code>类型指针</code>。</p><h4 id="1、存储对象自身的运行时数据"><a href="#1、存储对象自身的运行时数据" class="headerlink" title="1、存储对象自身的运行时数据"></a>1、存储对象自身的运行时数据</h4><p>如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它为<code>Mark Word</code>。</p><blockquote><p><strong>Mark Word</strong>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p></blockquote><h4 id="2、类型指针"><a href="#2、类型指针" class="headerlink" title="2、类型指针"></a>2、类型指针</h4><p>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><blockquote><p>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身</p></blockquote><blockquote><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数。<br>因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。</p></blockquote><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><p>实例数据是对象真正存储等有效信息。也就是我们所定义的各种类型的字段内容，<br>无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到<strong>虚拟机分配策略参数</strong>(<code>-XX:FieldsAllocationStyle</code>参数)和<strong>字段在Java源码中定义顺序</strong>的影响。</p><blockquote><p>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，<br>由上可知：相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。<br>如果HotSpot虚拟机的 <code>+XX:CompactFields</code>参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p></blockquote><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>对齐填充不是必然存在的，它仅仅起着占位符的作用。<br>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是<code>8字节的整数倍</code>。<br>换句话说就是<strong>任何对象的大小都必须是8字节的整数倍</strong>。<br>对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>创建了对象就需要使用它，Java Dev会通过栈上的reference数据来操作堆上的具体对象。<br>由于<code>reference类型</code>在《Java虚拟机规范》里面只规定了它<strong>是一个指向对象的引用</strong>，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。<br>所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种。</p><h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><h4 id="使用句柄访问对象"><a href="#使用句柄访问对象" class="headerlink" title="使用句柄访问对象"></a>使用句柄访问对象</h4><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是<strong>对象的句柄地址</strong>，而<strong>句柄中包含了对象实例数据与类型数据各自具体的地址信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jubing.png" alt="使用句柄访问对象"></p><h4 id="使用直接指针访问对象"><a href="#使用直接指针访问对象" class="headerlink" title="使用直接指针访问对象"></a>使用直接指针访问对象</h4><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中<strong>存储的直接就是对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/obj-zhizhen.png" alt="使用直接指针访问对象"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li><li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的intern()方法</title>
      <link href="/ckd70wo6w0009qlyd1yu5dnit/"/>
      <url>/ckd70wo6w0009qlyd1yu5dnit/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>String::intern()</code>是一个Native方法，用于返回该对象在常量池中的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>示例1：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 在JDK 6中运行，会得到三个false；</span></span><br><span class="line"><span class="comment"> * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储，</span></span><br><span class="line"><span class="comment"> * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，</span></span><br><span class="line"><span class="comment"> * 所以必然不可能是同一个引用，结果将返回false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 而在JDK 7后中运行，会得到一个true、一个false和一个true；</span></span><br><span class="line"><span class="comment"> * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中，</span></span><br><span class="line"><span class="comment"> * 那只需要在常量池里记录一下首次出现的实例引用即可。</span></span><br><span class="line"><span class="comment"> * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。</span></span><br><span class="line"><span class="comment"> * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的)</span></span><br><span class="line"><span class="comment"> * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。</span></span><br><span class="line"><span class="comment"> * 而str3和str1一样，"JDKJVM"这个字符串则是首次出现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JVM"</span>).append(<span class="string">"调优"</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="comment">// java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参考：https://www.zhihu.com/question/51102308/answer/124441115</span></span><br><span class="line"><span class="comment">     * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化，</span></span><br><span class="line"><span class="comment">     * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化，</span></span><br><span class="line"><span class="comment">     * 此时被 sun.misc.Version.launcher 静态常量字段所引用的"java"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">    <span class="comment">// 而JDKJVM这个字符串则是首次出现</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JDK"</span>).append(<span class="string">"JVM"</span>).toString();</span><br><span class="line">    System.out.println(str3.intern() == str3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。</span></span><br><span class="line"><span class="comment"> * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。</span></span><br><span class="line"><span class="comment"> * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的"JVM"。</span></span><br><span class="line"><span class="comment"> * - b：先将字符串"JVM"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的"JVM"，最后将b指向heap中创建的这个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也就是说，a和b存储的内容是一样的，都是"JVM"，但地址不一样：a中保存的是常量池中"JVM"的地址，b保存的是heap中那个对象的地址，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 双等于号"=="比较的是地址，equals()比较的是内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compareStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"JVM"</span>;</span><br><span class="line">    <span class="comment">// new一个对象</span></span><br><span class="line">    String b = <span class="keyword">new</span> String(<span class="string">"JVM"</span>);</span><br><span class="line">    <span class="comment">// == 比较地址是否相等</span></span><br><span class="line">    <span class="comment">// 都在运行时常量池中</span></span><br><span class="line">    System.out.println(<span class="string">"JVM"</span> == a); <span class="comment">// true</span></span><br><span class="line">    System.out.println(a.intern() == a); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">    System.out.println(a.intern() == b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(a.equals(b));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例2：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         双等号"=="比较的是地址；equals()比较的是内容。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1 == s3.intern()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s3 == s4);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3.intern() == s4.intern());  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Neo4j的时光网电影数据可视化【附源码】</title>
      <link href="/ckd70wo74000fqlydd4c020y6/"/>
      <url>/ckd70wo74000fqlydd4c020y6/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Neo4j的电影数据可视化"><a href="#基于Neo4j的电影数据可视化" class="headerlink" title="基于Neo4j的电影数据可视化"></a>基于Neo4j的电影数据可视化</h1><p>本文主要内容为：</p><ul><li>基于requests + BeautifulSoup抓取时光网电影数据；</li><li>基于电影数据构建电影和关系实体信息；</li><li>数据导入neo4j进行存储分析；</li><li>基于Bottle框架的对neo4j数据进行查询可视化展示。</li></ul><p>效果展示：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/web-demo.png" alt="效果展示"></p><a id="more"></a><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="新建虚拟环境并安装所需包"><a href="#新建虚拟环境并安装所需包" class="headerlink" title="新建虚拟环境并安装所需包"></a>新建虚拟环境并安装所需包</h3><ul><li>新建虚拟环境：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看本机已经安装的python虚拟环境</span><br><span class="line">conda env list</span><br><span class="line"># 新建graph-37环境</span><br><span class="line">conda create -n graph-37 python&#x3D;3.7</span><br><span class="line"># 生效新建的虚拟环境</span><br><span class="line">conda activate graph-37</span><br><span class="line">## 退出</span><br><span class="line">#conda deactivate</span><br></pre></td></tr></table></figure></li><li>安装所需包：<br>根据requirements.txt文件来安装：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>requirements.txt文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">beautifulsoup4&#x3D;&#x3D;4.9.1</span><br><span class="line">bs4&#x3D;&#x3D;0.0.1</span><br><span class="line">certifi&#x3D;&#x3D;2020.4.5.1</span><br><span class="line">chardet&#x3D;&#x3D;3.0.4</span><br><span class="line">Click&#x3D;&#x3D;7.0</span><br><span class="line">colorama&#x3D;&#x3D;0.4.3</span><br><span class="line">et-xmlfile&#x3D;&#x3D;1.0.1</span><br><span class="line">idna&#x3D;&#x3D;2.9</span><br><span class="line">jdcal&#x3D;&#x3D;1.4.1</span><br><span class="line">lxml&#x3D;&#x3D;4.5.1</span><br><span class="line">neobolt&#x3D;&#x3D;1.7.17</span><br><span class="line">neotime&#x3D;&#x3D;1.7.4</span><br><span class="line">numpy&#x3D;&#x3D;1.18.5</span><br><span class="line">openpyxl&#x3D;&#x3D;3.0.3</span><br><span class="line">pandas&#x3D;&#x3D;1.0.4</span><br><span class="line">prompt-toolkit&#x3D;&#x3D;2.0.10</span><br><span class="line">py2neo&#x3D;&#x3D;4.3.0</span><br><span class="line">Pygments&#x3D;&#x3D;2.3.1</span><br><span class="line">python-dateutil&#x3D;&#x3D;2.8.1</span><br><span class="line">pytz&#x3D;&#x3D;2020.1</span><br><span class="line">requests&#x3D;&#x3D;2.23.0</span><br><span class="line">six&#x3D;&#x3D;1.15.0</span><br><span class="line">soupsieve&#x3D;&#x3D;2.0.1</span><br><span class="line">urllib3&#x3D;&#x3D;1.24.3</span><br><span class="line">wcwidth&#x3D;&#x3D;0.2.4</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>本文数据来自<a href="http://www.mtime.com/top/movie/top100/" target="_blank" rel="external nofollow noopener noreferrer">时光网电影Top100</a>。<br>基于python对该源进行数据抓取，并将数据生成相应的实体和关系：<br>可参考：<a href="https://github.com/bubblewu/movie-neo4j/blob/master/mtime/mtime_main.py" target="_blank" rel="external nofollow noopener noreferrer">GitHub：时光网数据抓取处理</a></p><p>实体和关系如下：：</p><ul><li><p>电影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index:ID,rank,src,name,movie_en,year,image,:LABEL</span><br><span class="line">10000,1,http:&#x2F;&#x2F;movie.mtime.com&#x2F;12231&#x2F;,肖申克的救赎,The Shawshank Redemption,1994,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;03&#x2F;07&#x2F;123549.37376649_96X128.jpg,电影表</span><br><span class="line">10001,2,http:&#x2F;&#x2F;movie.mtime.com&#x2F;99547&#x2F;,盗梦空间,Inception,2010,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;01&#x2F;06&#x2F;105446.89493583_96X128.jpg,电影表</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>演员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index:ID,actor,:LABEL</span><br><span class="line">30000,杰伊·巴鲁切尔,演员表</span><br><span class="line">30001,维果·莫腾森,演员表</span><br><span class="line">30002,布拉德·皮特,演员表</span><br><span class="line">30003,李·科布,演员表</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>导演：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index:ID,director,:LABEL</span><br><span class="line">20000,彼得·索恩,导演表</span><br><span class="line">20001,克里斯托弗·诺兰,导演表</span><br><span class="line">20002,朴赞郁,导演表</span><br><span class="line">20003,赛尔乔·莱昂内,导演表</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>关系：</p><ul><li><p>电影与导演关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:START_ID,:END_ID,relation,:TYPE</span><br><span class="line">20069,10000,导演,导演</span><br><span class="line">20001,10001,导演,导演</span><br><span class="line">20010,10002,导演,导演</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>电影与主演关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:START_ID,:END_ID,relation,:TYPE</span><br><span class="line">30156,10000,主演,主演</span><br><span class="line">30026,10000,主演,主演</span><br><span class="line">30063,10001,主演,主演</span><br><span class="line">30031,10001,主演,主演</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>导演和演员关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:START_ID,:END_ID,relation,:TYPE</span><br><span class="line">20069,30156,相关,相关</span><br><span class="line">20069,30026,相关,相关</span><br><span class="line">20001,30063,相关,相关</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="Neo4j存储"><a href="#Neo4j存储" class="headerlink" title="Neo4j存储"></a>Neo4j存储</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。</p><p>通过下面的命令导入定义好的实体和关系数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># 脚本来执行将csv文件（节点和关系）导入neo4j</span><br><span class="line"># 注意：必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。</span><br><span class="line"></span><br><span class="line">db_name&#x3D;MovieMTime.db</span><br><span class="line">neo4j_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4</span><br><span class="line">base_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;code&#x2F;python&#x2F;moive-kg&#x2F;data&#x2F;mtime</span><br><span class="line"></span><br><span class="line">import() &#123;</span><br><span class="line">  cd $&#123;neo4j_path&#125;</span><br><span class="line">  .&#x2F;bin&#x2F;neo4j stop</span><br><span class="line">  rm -rf &#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4&#x2F;data&#x2F;databases&#x2F;$&#123;db_name&#125;</span><br><span class="line">  .&#x2F;bin&#x2F;neo4j-admin import --verbose \</span><br><span class="line">                        --database $&#123;db_name&#125; \</span><br><span class="line">                        --id-type STRING \</span><br><span class="line">                        --input-encoding&#x3D;UTF-8 \</span><br><span class="line">                        --ignore-extra-columns&#x3D;false \</span><br><span class="line">                        --trim-strings&#x3D;true \</span><br><span class="line">                        --delimiter&#x3D;, \</span><br><span class="line">                        --array-delimiter&#x3D;&#39;;&#39; \</span><br><span class="line">                        --processors&#x3D;4 \</span><br><span class="line">                        --nodes $&#123;base_path&#125;&#x2F;mtime_movie_entity.csv \</span><br><span class="line">                        --nodes $&#123;base_path&#125;&#x2F;mtime_actor_entity.csv \</span><br><span class="line">                        --nodes $&#123;base_path&#125;&#x2F;mtime_director_entity.csv \</span><br><span class="line">                        --relationships $&#123;base_path&#125;&#x2F;mtime_director_actor_relationship.csv \</span><br><span class="line">                        --relationships $&#123;base_path&#125;&#x2F;mtime_movie_actor_relationship.csv  \</span><br><span class="line">                        --relationships $&#123;base_path&#125;&#x2F;mtime_movie_director_relationship.csv</span><br><span class="line">  # 需要修改neo4j.conf配置文件中的默认db才能展示新建的db，否则还是默认的。（只能指定一个db）</span><br><span class="line">#  .&#x2F;bin&#x2F;neo4j start</span><br><span class="line">#  .&#x2F;bin&#x2F;neo4j stop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import</span><br></pre></td></tr></table></figure><h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><p>修改配置将默认db改为刚才新建的电影的db，否则还是默认的库。<br>vim conf/neo4j.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbms.active_database&#x3D;MovieMTime.db</span><br></pre></td></tr></table></figure><p>启动neo4j服务（neo4j版本为4.0.3）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;neo4j start</span><br></pre></td></tr></table></figure><p>进入管理界面：<a href="http://127.0.0.1:7474/" target="_blank" rel="external nofollow noopener noreferrer">http://127.0.0.1:7474</a></p><p>查看实体数据：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/neo4j-moviemtime-movie.png" alt="实体数据可视化"></p><p>查看关系数据：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/moviemtime-relationships.png" alt="关系数据可视化"></p><h2 id="数据查询可视化"><a href="#数据查询可视化" class="headerlink" title="数据查询可视化"></a>数据查询可视化</h2><p>查询可视化基于Bottle框架的Web服务。<br>参考：<a href="https://github.com/bubblewu/movie-neo4j/blob/master/mtime/mtime_graph_show.py" target="_blank" rel="external nofollow noopener noreferrer">GitHub: 可视化</a></p><p>效果如下图：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/moviemtime-web.png" alt="电影信息可视化"></p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><ul><li><a href="https://github.com/bubblewu/movie-neo4j" target="_blank" rel="external nofollow noopener noreferrer">movie-neo4j</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neo4j </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>001 运行时数据区域和OutOfMemoryError异常</title>
      <link href="/ckd70wo7m001aqlyd0ltzhlb8/"/>
      <url>/ckd70wo7m001aqlyd0ltzhlb8/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲解JVM运行时数据区域，并通过简单的案例来实现说明各个区域中的常见OOM异常。</p><a id="more"></a><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>运行时数据区域图：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-rda.png" alt="运行时数据区域图"></p><p>Java内存区域：<br>JVM内存区域主要分为<code>线程私有区域</code>【程序计数器、虚拟机栈、本地方法栈】、<code>线程共享区域</code>【Java堆、方法区】、直接内存。<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-mind.png" alt="JVM内存导图"></p><ul><li><p>线程私有区域：<br>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM内,每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p></li><li><p>线程共享区域：<br>线程共享区域随虚拟机的启动/关闭而创建/销毁。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-rda2.png" alt="运行时数据区域图2"></p><h1 id="JVM主要区域溢出异常"><a href="#JVM主要区域溢出异常" class="headerlink" title="JVM主要区域溢出异常"></a>JVM主要区域溢出异常</h1><p>在Java虚拟机规范中规定，除了<code>程序计数器</code>外，虚拟机的其他几个运行时区域都有发生OOM异常的可能，如：<strong>方法区（运行时常量池）、Java堆、虚拟机栈（局部变量表）、本地方法栈和直接内存。</strong></p><p>下面将通过案例来验证各个运行时区域的溢出异常，并分析我们来如何解决和避免这些异常。</p><blockquote><p>注：下面的代码基于<strong>JDK8</strong>进行开发测试；</p></blockquote><h2 id="线程独占区"><a href="#线程独占区" class="headerlink" title="线程独占区"></a>线程独占区</h2><h3 id="程序计数器（无OOM）"><a href="#程序计数器（无OOM）" class="headerlink" title="程序计数器（无OOM）"></a>程序计数器（无OOM）</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为<code>线程私有</code>的内存。</p><ul><li>正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。</li><li>如果是Native方法，则为空（undefined）。</li></ul><p>这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError 情况的区域。</p><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><strong>虚拟机栈描述的是<code>Java方法</code>执行的线程内存模型</strong>。</p><h5 id="栈帧（Stack-Frame）："><a href="#栈帧（Stack-Frame）：" class="headerlink" title="栈帧（Stack Frame）："></a><code>栈帧（Stack Frame）</code>：</h5><p>每个方法被执行的时候，Java虚拟机都会同步创建一个<code>栈帧</code>用于<strong>存储局部变量表、操作数栈、动态连接、方法出口等信息</strong>。<br>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-stack.png" alt="栈帧"></p><h5 id="局部变量表："><a href="#局部变量表：" class="headerlink" title="局部变量表："></a><code>局部变量表</code>：</h5><p>局部变量表存放了编译期可知的：</p><ul><li>各种<code>Java虚拟机基本数据类型</code>：boolean、byte、char、short、int、 float、long、double；</li><li><code>对象引用</code> ：reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置；</li><li><code>returnAddress类型</code>：指向了一条字节码指令的地址。</li></ul><p>这些数据类型在局部变量表中的存储空间以<code>局部变量槽(Slot)</code>来表示。<br><strong>其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个</strong>。<br>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，<strong>在方法运行期间不会改变局部变量表的大小</strong>。</p><h5 id="两种异常：栈-堆溢出"><a href="#两种异常：栈-堆溢出" class="headerlink" title="两种异常：栈/堆溢出"></a>两种异常：栈/堆溢出</h5><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code>；</li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code>。</li></ul><h4 id="虚拟机栈-amp-本地方法栈"><a href="#虚拟机栈-amp-本地方法栈" class="headerlink" title="虚拟机栈&amp;本地方法栈"></a>虚拟机栈&amp;本地方法栈</h4><p>Java虚拟机栈（Java Virtual Machine Stack）和本地方法栈（Native Method Stacks）非常相似，<code>都属于线程独占区</code>，区别是：</p><ul><li>虚拟机栈为虚拟机执行<code>Java方法（也就是字节码）服务</code>；</li><li>本地方法栈为虚拟机使用到的<code>本地方法（Native方法）服务</code>；</li></ul><p><strong>Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p><h4 id="虚拟机栈和本地方法栈溢出案例"><a href="#虚拟机栈和本地方法栈溢出案例" class="headerlink" title="虚拟机栈和本地方法栈溢出案例"></a>虚拟机栈和本地方法栈溢出案例</h4><h5 id="栈容量参数：-Xss"><a href="#栈容量参数：-Xss" class="headerlink" title="栈容量参数：-Xss"></a>栈容量参数：-Xss</h5><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，<code>栈容量只能由-Xss参数来设定</code>。</p><h5 id="栈-堆溢出的场景"><a href="#栈-堆溢出的场景" class="headerlink" title="栈/堆溢出的场景"></a>栈/堆溢出的场景</h5><p>《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展。<br>所以除非<code>在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常</code>，否则<code>在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常</code>。</p><h5 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h5><p>将实验范围限制在<strong>单线程中操作</strong>，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常：</p><ul><li><p>使用<code>-Xss参数减少栈内存容量</code>。<br>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 </p></li><li><p><code>定义大量的本地变量，增大此方法帧中本地变量表的长度</code>。<br>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 </p></li></ul><h6 id="单线程下：使用-Xss参数减少栈内存容量（SOF异常）"><a href="#单线程下：使用-Xss参数减少栈内存容量（SOF异常）" class="headerlink" title="单线程下：使用-Xss参数减少栈内存容量（SOF异常）"></a>单线程下：使用<code>-Xss参数减少栈内存容量</code>（SOF异常）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java虚拟机栈和本地方法机栈异常（单线程操作下）</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss160k（Mac 64Bit要求最低栈内存为160K）</span></span><br><span class="line"><span class="comment"> * 使用-Xss参数减少栈内存容量。</span></span><br><span class="line"><span class="comment"> * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 15:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VMStackSOF stackSOF = <span class="keyword">new</span> VMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackSOF.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + stackSOF.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack length: 773</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.bubble.jvm.error.VMStackSOF.stackLeak(VMStackSOF.java:16)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h6 id="单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）"><a href="#单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）" class="headerlink" title="单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）"></a>单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java虚拟机栈和本地方法机栈异常（单线程操作下）</span></span><br><span class="line"><span class="comment"> * 定义大量的本地变量，增大此方法帧中本地变量表的长度</span></span><br><span class="line"><span class="comment"> * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 15:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStackSOF02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5, unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15, unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25, unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35, unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45, unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55, unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65, unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75, unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85, unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95, unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 = unused6 = unused7 = unused8 = unused9 = unused10 = unused11 =</span><br><span class="line">                unused12 = unused13 = unused14 = unused15 = unused16 = unused17 = unused18 = unused19 = unused20 = unused21 = unused22 = unused23 = unused24 = unused25 = unused26 = unused27 = unused28 = unused29 = unused30 = unused31 = unused32 = unused33 = unused34 = unused35 = unused36 = unused37 = unused38 = unused39 = unused40 = unused41 = unused42 = unused43 = unused44 = unused45 = unused46 = unused47 = unused48 = unused49 = unused50 = unused51 = unused52 = unused53 = unused54 = unused55 = unused56 = unused57 = unused58 = unused59 = unused60 = unused61 = unused62 = unused63 = unused64 = unused65 = unused66 = unused67 = unused68 = unused69 = unused70 = unused71 = unused72 = unused73 = unused74 = unused75 = unused76 = unused77 = unused78 = unused79 = unused80 = unused81 = unused82 = unused83 = unused84 = unused85 = unused86 = unused87 = unused88 = unused89 = unused90 = unused91 = unused92 = unused93 = unused94 = unused95 = unused96 =</span><br><span class="line">                        unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack length: 8121Exception in thread &quot;main&quot; </span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">at com.bubble.jvm.error.VMStackSOF02.test(VMStackSOF02.java:26)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h6 id="多线程下：OOM异常"><a href="#多线程下：OOM异常" class="headerlink" title="多线程下：OOM异常"></a>多线程下：OOM异常</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程下，Java虚拟机栈和本地方法栈OOM异常</span></span><br><span class="line"><span class="comment"> * VM Args:-Xss2M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 16:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; dontStop());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VMStackOOM vmStackOOM = <span class="keyword">new</span> VMStackOOM();</span><br><span class="line">        vmStackOOM.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create native thread</span><br></pre></td></tr></table></figure><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>实验结果表明：</p><ul><li>单线程下：</li></ul><p><strong>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。</strong><br>如果在允许动态扩展栈容量大小的虚拟机上，相同代码则会导致不一样的情况，如第二个代码（定义大量的本地变量，增大此方法帧中本地变量表的长度）示例就会抛出OutOfMemoryError异常。</p><ul><li>多线程下：<br>如果通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的，如第三个代码。<br>但是这样<strong>产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系</strong>，<strong>主要取决于操作系统本身的内存使用状态</strong>。<br>甚至可以说，在这种情况下，<code>给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常</code>。</li></ul><blockquote><p>因为：<strong>操作系统分配给每个进程的内存是有限制的</strong>。<br>如32位Windows的单个进程最大内存限制为2GB。<br>HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，<br>那<code>剩余的内存（由虚拟机栈和本地方法栈来分配的内存）</code>为<strong>2GB(操作系统限制)减去最大堆容量，再减去最大方法区容量</strong>。</p><blockquote><p>注意：由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话。</p></blockquote><p>因此<code>为每个线程分配到的栈内存越大，可以建立的线程数量自 然就越少，建立线程时就越容易把剩下的内存耗尽</code>。</p></blockquote><ul><li>通过<code>减少内存</code>的手段来解决内存溢出的方式：<br>如果是建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，就只<strong>通过<code>减少最大堆</code>和<code>减少栈容量</code>来换取更多的线程</strong>。</li></ul><h2 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Java堆（Java Heap）是虚拟机管理的内存中的最大一块区域，也是垃圾回收的主要区域，它属于<code>线程共享区</code>，用于<code>存储对象实例</code>。</p><h4 id="Java堆时垃圾收集器管理的内存区域"><a href="#Java堆时垃圾收集器管理的内存区域" class="headerlink" title="Java堆时垃圾收集器管理的内存区域"></a>Java堆时垃圾收集器管理的内存区域</h4><p>Java堆也被称为GC堆（Garbage Collected Heap）。</p><ul><li><p>从<strong>回收内存角度</strong>来看：<br>垃圾收集器大部分都是基于<code>分代收集理论</code>设计的，会有 <strong>新生代、老年代、永久代（JDK8改为元空间）、Eden空间、From Survivor空间、To Survivor空间</strong>等名词。<br>这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。</p></li><li><p>从<strong>分配内存角度</strong>来看：<br>所有线程共享的Java堆中可以划分出多个线程私有的<code>分配缓冲区</code>（TLAB, Thread Local Allocation Buffer），可以提升对象分配时的效率。<br>不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，<strong>存储的都只能是对象的实例</strong>，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p></li></ul><h4 id="物理存储空间"><a href="#物理存储空间" class="headerlink" title="物理存储空间"></a>物理存储空间</h4><p>Java堆可以处于<strong>物理上不连续的内存空间</strong>中，但在逻辑上它应该被视为连续的。<br>就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。</p><blockquote><p>注意：但对于<strong>大对象</strong>(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p></blockquote><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><p>Java堆可以设置为固定大小，也可以为可动态扩展的。<br>通过参数<code>-Xmx</code>和<code>-Xms</code>来设定堆的最大和最小内存容量。<strong>将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展</strong>。</p><p>如果<strong>在Java堆中没有内存完成实例分配，并且堆也无法再扩展时</strong>，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p><h4 id="为什么会堆溢出？"><a href="#为什么会堆溢出？" class="headerlink" title="为什么会堆溢出？"></a>为什么会堆溢出？</h4><p>当我们不断地创建新对象时，并且使GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，这时候，对象数量不断增加，总容量超过最大堆的容量限制后，就会发生内存溢出异常。</p><h4 id="OMM的两种情况"><a href="#OMM的两种情况" class="headerlink" title="OMM的两种情况"></a>OMM的两种情况</h4><p>可以通过内存映像分析工具对dump出的堆存储快照进行分析。<br>首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p><h5 id="内存泄露（Memory-Leak）"><a href="#内存泄露（Memory-Leak）" class="headerlink" title="内存泄露（Memory Leak）"></a>内存泄露（Memory Leak）</h5><p>如果是内存泄漏（<code>内存中的对象不是必须存活的，垃圾收集器未收集</code>），可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致<code>垃圾收集器无法回收它们</code>，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</p><h5 id="内存溢出（Memory-Overflow）"><a href="#内存溢出（Memory-Overflow）" class="headerlink" title="内存溢出（Memory Overflow）"></a>内存溢出（Memory Overflow）</h5><p>如果不是内存泄漏，换句话说就是<code>内存中的对象确实都是必须存活的</code>，那就应当：</p><ul><li>检查Java虚拟机的堆参数(-Xmx与-Xms)设置，与机器的内存对比，看看是否还有向上调整的空间。</li><li>再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</li></ul><h4 id="溢出案例和dump快照分析"><a href="#溢出案例和dump快照分析" class="headerlink" title="溢出案例和dump快照分析"></a>溢出案例和dump快照分析</h4><p>使用虚拟机参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>限制Java堆的大小为20M B，不可扩展。<br>通过参数<code>-XX:+HeapDumpOnOutOf-MemoryError</code>可以<strong>让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照</strong>，以便进行事后分析。(文件存储在该项目父目录下，如：java_pid80802.hprof)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java堆内存异常测试</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid80802.hprof ...</span><br><span class="line">Heap dump file created [27964242 bytes in 0.193 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:265)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:462)</span><br><span class="line">at com.bubble.jvm.error.JavaHeapOOM.main(JavaHeapOOM.java:23)</span><br></pre></td></tr></table></figure><p>可以在目录/Users/wugang/code/java/multi-dev下看到java_pid80802.hprof文件。</p><ul><li>分析dump文件：<br>可以通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出来的堆转储快照进行分析，也可以通过JDK自带的工具jvisualvm来可视化分析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 控制行执行命令</span><br><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>会打开下面的窗口，打开对应的堆dump文件：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvisualvm-01.png" alt="jvisualvm-起始页"></li></ul><p>主要内容为：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvisualvm-02.png" alt="jvisualvm-概要"><br>由上图可知：导致 OutOfMemoryError 异常错误的线程是 main</p><p>查看dump的类信息：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvisualvm-03.png" alt="jvisualvm-类信息"><br>由上图可知：dump文件记录的堆中的实例总大小约19M，指定的堆的固定大小为20M。</p><blockquote><p>用第一行的实例大小除以百分比就能算出来：<br>堆中实例大小：12965216B/1024/1024=12.36M，占了总大小的65%。<br>堆中实例总大小：12.36M/0.65=19.02M</p></blockquote><p>说明：dump文件中的实例列表其实是<strong>反映了使用的堆的情况</strong>，而使用的堆内存并没有达到预先设置的最大堆内存，只是在申请堆内存的过程中超出了预先设置的最大堆内存，然后内存溢出。</p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p><code>方法区</code>与Java堆一样，属于<code>线程共享区</code>，它用于<strong>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样<strong>不需要连续的内存</strong>和<strong>可以选择固定大小</strong>或者<strong>可扩展</strong>外，甚至<strong>还可以选择不实现垃圾收集</strong>。</p><blockquote><p>注意：</p><ul><li><code>关于方法区和永久代（元空间）</code>：<br>在JDK8以前，很多人把方法区称呼为<code>永久代（Permanent Generation</code>，或将两者混为一谈。<br>本质上这两者并不是等价的，<strong>仅因为HotSpot使用永久代来实现方法区而已</strong>，使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。<br>到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；<br>而到了JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的<code>元空间(Metaspace)</code>来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</li></ul></blockquote><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><h6 id="JDK8之前：老年代（Permanent-Gennration）"><a href="#JDK8之前：老年代（Permanent-Gennration）" class="headerlink" title="JDK8之前：老年代（Permanent Gennration）"></a>JDK8之前：老年代（Permanent Gennration）</h6><ul><li>如：<code>-XX:PermSize=10M</code> 指定老年代的初始空间大小（10M），以字节为单位。</li><li>如：<code>-XX:MaxPermSize=10M</code> 设置老年代最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</li></ul><h6 id="JDK8始：元空间（Metaspace）"><a href="#JDK8始：元空间（Metaspace）" class="headerlink" title="JDK8始：元空间（Metaspace）"></a><code>JDK8始：元空间（Metaspace）</code></h6><p><strong>Metaspace使用的是本地内存，而不是堆内存</strong>，也就是说在<code>默认情况下Metaspace的大小只与本地内存大小有关</code>。</p><ul><li><code>-XX:MetaspaceSize</code>：指定<strong>元空间的初始空间大小</strong>，以字节为单位。</li></ul><p><strong>达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</strong>：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下，适当提高该值。</p><blockquote><p>该值越大触发Metaspace GC的时机就越晚。<br>随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加上限也可能降低。<br>在默认情况下，这个值大小根据不同的平台在12M到20M浮动。<br>使用<code>java -XX:+PrintFlagsInitial</code>命令查看本机的初始化参数，-XX:Metaspacesize为21810376B（大约20.8M） 。</p></blockquote><ul><li><p><code>-XX:MaxMetaspaceSize</code>：设置<strong>元空间最大值</strong>，默认是-1，即不限制，或者说只受限于本地内存大小。</p><blockquote><p>防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。<br>在本机上该参数的默认值为4294967295B（大约4096MB）。</p></blockquote></li><li><p><code>-XX:MinMetaspaceFreeRatio</code>：作用是在Metaspace GC收集之后，控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</p><blockquote><p>当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比。<br>如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。<br>在本机该参数的默认值为40，也就是40%。<br>设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。</p></blockquote></li><li><p><code>-XX:MaxMetaspaceFreeRatio</code>：用于控制大的元空间剩余容量的百分比。</p><blockquote><p>当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。在本机该参数的默认值为70，也就是70%。</p></blockquote></li><li><p><code>-XX:MaxMetaspaceExpansion</code>： Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。</p></li><li><p><code>-XX:MinMetaspaceExpansion</code>： Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。</p></li></ul><h5 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h5><p><strong>运行时常量池是方法区的一部分</strong>。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<code>常量池表(Constant Pool Table)</code>，用于<strong>存放编译期生成的各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，在运行期间也可以将新的常量放入池中，如使用<code>String类的intern()方法</code>。</p><h5 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h5><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8中完全<strong>使用<code>元空间</code>来代替永久代</strong>。</p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法区的OOM异常：</span></span><br><span class="line"><span class="comment"> * - JDK8之前：指定老年代（方法区的大小固定为10M，不能进行自动扩展）</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - JDK8：完全废除了老年代，用元空间代替。</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 18:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 借助CGLib使得方法区出现内存溢出异常：</span></span><br><span class="line"><span class="comment">     * 方法区的主要职责是用于存放类型的相关信息：如类名、访问修饰符、常量池、字段描述、方法描述等。</span></span><br><span class="line"><span class="comment">     * 对于这部分区域的测试，基本的思路是：运行时产生大量的类去填满方法区，直到溢出为止。</span></span><br><span class="line"><span class="comment">     * 所以：可以借助CGLib直接操作字节码，运行时生成了大量的动态类。</span></span><br><span class="line"><span class="comment">     * 注意：</span></span><br><span class="line"><span class="comment">     * 当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到 CGLib这类字节码技术，</span></span><br><span class="line"><span class="comment">     * 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class="line">at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117)</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class="line">at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)</span><br><span class="line">at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)</span><br><span class="line">at com.bubble.jvm.error.JavaMethodAreaOOM.main(JavaMethodAreaOOM.java:39)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459)</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:339)</span><br><span class="line">... 6 more</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">... 11 more</span><br></pre></td></tr></table></figure><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法区（运行时常量池）的OOM异常，（方法区在JDK8后开始废除，之前也被称为永久代）</span></span><br><span class="line"><span class="comment"> * - 在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，</span></span><br><span class="line"><span class="comment"> * 我们可以通过-XX:PermSize和-XX:M axPermSize限制永久代的大小，即可间接限制其中常量池的容量。</span></span><br><span class="line"><span class="comment"> * 如：VM Args:-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 17:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK6来运行代码，抛出异常：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError: PermGen space</span></span><br><span class="line"><span class="comment">     * at java.lang.String.intern(Native Method)</span></span><br><span class="line"><span class="comment">     * 说明运行时常量池是属于方法区(即JDK 6的HotSpot虚拟机中的永久代)的一部分。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：</span></span><br><span class="line"><span class="comment">     * 无论是在JDK7中继续使用-XX:MaxPermSize参数或者在JDK8及以上版本使用-XX:MaxMeta-spaceSize参数</span></span><br><span class="line"><span class="comment">     * 把方法区容量同样限制在6MB，也都不会重现JDK6中的溢出异常，循环将一直进行下去，永不停歇。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为自JDK7起，原本存放在永久代的字符串常量池被移至Java堆之中，</span></span><br><span class="line"><span class="comment">     * 所以在JDK7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 但使用-Xmx参数限制最大堆到6MB就能够看到下面两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</span></span><br><span class="line"><span class="comment">     * - OOM异常一：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">     * at java.base/java.lang.Integer.toString(Integer.java:440)</span></span><br><span class="line"><span class="comment">     * at java.base/java.lang.String.valueOf(String.java:3058)</span></span><br><span class="line"><span class="comment">     * - OOM异常二：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashMap.resize(HashMap.java:699)</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashMap.putVal(HashMap.java:658)</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashMap.put(HashMap.java:607)</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashSet.add(HashSet.java:220)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runByJDK6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        runByJDK6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String::intern()方法"></a><code>String::intern()方法</code></h5><p><code>String::intern()</code>是一个Native方法，返回该对象在常量池中的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 在JDK 6中运行，会得到三个false；</span></span><br><span class="line"><span class="comment"> * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储，</span></span><br><span class="line"><span class="comment"> * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，</span></span><br><span class="line"><span class="comment"> * 所以必然不可能是同一个引用，结果将返回false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 而在JDK 7后中运行，会得到一个true、一个false和一个true；</span></span><br><span class="line"><span class="comment"> * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中，</span></span><br><span class="line"><span class="comment"> * 那只需要在常量池里记录一下首次出现的实例引用即可。</span></span><br><span class="line"><span class="comment"> * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。</span></span><br><span class="line"><span class="comment"> * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的)</span></span><br><span class="line"><span class="comment"> * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。</span></span><br><span class="line"><span class="comment"> * 而str3和str1一样，"JDKJVM"这个字符串则是首次出现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JVM"</span>).append(<span class="string">"调优"</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="comment">// java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参考：https://www.zhihu.com/question/51102308/answer/124441115</span></span><br><span class="line"><span class="comment">     * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化，</span></span><br><span class="line"><span class="comment">     * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化，</span></span><br><span class="line"><span class="comment">     * 此时被 sun.misc.Version.launcher 静态常量字段所引用的"java"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">    <span class="comment">// 而JDKJVM这个字符串则是首次出现</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JDK"</span>).append(<span class="string">"JVM"</span>).toString();</span><br><span class="line">    System.out.println(str3.intern() == str3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。</span></span><br><span class="line"><span class="comment"> * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。</span></span><br><span class="line"><span class="comment"> * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的"JVM"。</span></span><br><span class="line"><span class="comment"> * - b：先将字符串"JVM"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的"JVM"，最后将b指向heap中创建的这个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也就是说，a和b存储的内容是一样的，都是"JVM"，但地址不一样：a中保存的是常量池中"JVM"的地址，b保存的是heap中那个对象的地址，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 双等于号"=="比较的是地址，equals()比较的是内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compareStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"JVM"</span>;</span><br><span class="line">    <span class="comment">// new一个对象</span></span><br><span class="line">    String b = <span class="keyword">new</span> String(<span class="string">"JVM"</span>);</span><br><span class="line">    <span class="comment">// == 比较地址是否相等</span></span><br><span class="line">    <span class="comment">// 都在运行时常量池中</span></span><br><span class="line">    System.out.println(<span class="string">"JVM"</span> == a); <span class="comment">// true</span></span><br><span class="line">    System.out.println(a.intern() == a); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">    System.out.println(a.intern() == b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(a.equals(b));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他（不受JVM-GC管理区域）"><a href="#其他（不受JVM-GC管理区域）" class="headerlink" title="其他（不受JVM GC管理区域）"></a>其他（不受JVM GC管理区域）</h2><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><h4 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>容量大小可通过<code>-XX:MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致。</p><h5 id="NIO-New-Input-Output-类"><a href="#NIO-New-Input-Output-类" class="headerlink" title="NIO(New Input/Output)类"></a>NIO(New Input/Output)类</h5><p>NIO引入了一种<code>基于通道(Channel)</code>与<code>缓冲区 (Buffer)</code>的I/O方式，它可以<strong>使用Native函数库直接分配堆外内存</strong>，然后<strong>通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用</strong>进行操作。<br>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h5 id="OOM异常-1"><a href="#OOM异常-1" class="headerlink" title="OOM异常"></a>OOM异常</h5><p>当各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存OOM异常：使用unsafe分配本机内存</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 19:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配。</span></span><br><span class="line"><span class="comment">     * （Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用）</span></span><br><span class="line"><span class="comment">     * 因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，</span></span><br><span class="line"><span class="comment">     * 而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory ()。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 抛出异常：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment">     * at sun.misc.Unsafe.allocateMemory(Native Method)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况。<br>如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory(典型的间接使用就是NIO)，那就可以考虑重点检查一下直接内存方面的原因了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者-消费者案例</title>
      <link href="/ckd70wo77000jqlyd8qx0g49p/"/>
      <url>/ckd70wo77000jqlyd8qx0g49p/</url>
      
        <content type="html"><![CDATA[<p>基于Java的生产者-消费者模式代码实现，可以此为Demo来用于具体的实际业务。</p><a id="more"></a><ul><li>生产者-消费者demo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.Instant;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 推荐服务：生产者-消费者模式</span><br><span class="line"> *</span><br><span class="line"> * @author bubble</span><br><span class="line"> * date: 2018-10-22 15:03</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Deprecated</span><br><span class="line">public class RecService &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(RecService.class);</span><br><span class="line">    &#x2F;&#x2F; 日志打印间隔</span><br><span class="line">    private static int DEFAULT_LOG_INTERVAL &#x3D; 1000 * 10;</span><br><span class="line">    &#x2F;&#x2F; 队列默认处理容量，为避免队列扩容造成额外性能损耗，默认不扩容，达到当前大小，进入等待，消费者处理一部分数据之后，生产者继续生产</span><br><span class="line">    private static int DEFAULT_QUEUE_DISPOSE_SIZE &#x3D; 1000 * 10;</span><br><span class="line">    &#x2F;&#x2F; 队列默认容量</span><br><span class="line">    private static int DEFAULT_QUEUE_SIZE &#x3D; DEFAULT_QUEUE_DISPOSE_SIZE + 200;</span><br><span class="line">    &#x2F;&#x2F; 每个队列满时默认休眠时间</span><br><span class="line">    private static int DEFAULT_SLEEP_TIME &#x3D; 1000;</span><br><span class="line">    &#x2F;&#x2F; 线程池默认消费者数量</span><br><span class="line">    private static int DEFAULT_CONSUMER_NUM &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F; 用户的phoneId队列</span><br><span class="line">    private LinkedBlockingQueue&lt;Long&gt; phoneIdQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(DEFAULT_QUEUE_SIZE);</span><br><span class="line">    private Long STOP_FLAG &#x3D; -1L;</span><br><span class="line">    private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap; &#x2F;&#x2F; 用户航班信息</span><br><span class="line"></span><br><span class="line">    private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; getFlightInfoMap() &#123;</span><br><span class="line">        return flightInfoMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setFlightInfoMap(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap) &#123;</span><br><span class="line">        this.flightInfoMap &#x3D; flightInfoMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RecJobBean recJob;</span><br><span class="line">    private TipRecService tipRecService;</span><br><span class="line">    private CarRecService carRecService;</span><br><span class="line">    private HotelRecService hotelRecService;</span><br><span class="line"></span><br><span class="line">    public RecService(RecJobBean recJob) &#123;</span><br><span class="line">        this.recJob &#x3D; recJob;</span><br><span class="line">        switch (recJob) &#123;</span><br><span class="line">            case TIP:</span><br><span class="line">                tipRecService &#x3D; Optional.ofNullable(tipRecService).orElse(new TipRecService());</span><br><span class="line">                break;</span><br><span class="line">            case CAR:</span><br><span class="line">                carRecService &#x3D; Optional.ofNullable(carRecService).orElse(new CarRecService());</span><br><span class="line">                break;</span><br><span class="line">            case HOTEL:</span><br><span class="line">                hotelRecService &#x3D; Optional.ofNullable(hotelRecService).orElse(new HotelRecService());</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType());</span><br><span class="line">                System.exit(0);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void rec(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; userFlightMap, int top) &#123;</span><br><span class="line">        LOGGER.info(&quot;start &#123;&#125; rec job.&quot;, recJob.getType());</span><br><span class="line">        if (userFlightMap &#x3D;&#x3D; null || userFlightMap.isEmpty()) &#123;</span><br><span class="line">            LOGGER.error(&quot;user flight is empty, rec job for &#123;&#125; exit.&quot;, recJob.getType());</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        setFlightInfoMap(userFlightMap);</span><br><span class="line">        UserProducer userProducer &#x3D; new UserProducer();</span><br><span class="line">        userProducer.setName(&quot;producer&quot;);</span><br><span class="line">        userProducer.start();</span><br><span class="line">        UserConsumer userConsumer &#x3D; new UserConsumer(recJob, top);</span><br><span class="line">        ThreadPoolExecutor poolExecutor &#x3D; userConsumer.consumerAndRec();</span><br><span class="line">        threadMonitor(poolExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 监控ThreadPoolExecutor线程池，无活动线程就关闭线程池连接；</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void threadMonitor(ThreadPoolExecutor executor) &#123;</span><br><span class="line">        Runnable runnable &#x3D; () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                while (executor.getActiveCount() &gt; 0) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125;</span><br><span class="line">                executor.shutdown();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(&quot;thread monitor error.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生产者: 可用phoneId集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class UserProducer extends Thread &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            addUser();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 给每个线程都在队列（FIFO）末尾添加标识</span><br><span class="line">                phoneIdQueue.put(STOP_FLAG);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(&quot;save phoneId error.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(&quot;[&#123;&#125;] thread altogether produces &#123;&#125; data&quot;, this.getName(), i);</span><br><span class="line">            LOGGER.info(&quot;[&#123;&#125;] thread produces done.&quot;, this.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void addUser() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int step &#x3D; 0;</span><br><span class="line">                LOGGER.info(&quot;add &#123;&#125; user in producer queue.&quot;, getFlightInfoMap().size());</span><br><span class="line">                Iterator iter &#x3D; getFlightInfoMap().entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while (iter.hasNext()) &#123;</span><br><span class="line">                    Map.Entry entry &#x3D; (Map.Entry) iter.next();</span><br><span class="line">                    long uid &#x3D; (long) entry.getKey();</span><br><span class="line">                    phoneIdQueue.put(uid);</span><br><span class="line">                    step++;</span><br><span class="line">                    while (phoneIdQueue.size() &gt; DEFAULT_QUEUE_DISPOSE_SIZE) &#123;</span><br><span class="line">                        Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123;</span><br><span class="line">                        i +&#x3D; step;</span><br><span class="line">                        step &#x3D; 0;</span><br><span class="line">                        LOGGER.info(&quot;[&#123;&#125;] thread has produced &#123;&#125; pieces of data&quot;, this.getName(), i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i +&#x3D; step;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(&quot;save phoneId error.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消费者：取phoneId并进行推荐</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class UserConsumer &#123;</span><br><span class="line">        private int top;</span><br><span class="line">        private RecJobBean recJob;</span><br><span class="line"></span><br><span class="line">        public UserConsumer(RecJobBean recJob, int top) &#123;</span><br><span class="line">            this.recJob &#x3D; recJob;</span><br><span class="line">            this.top &#x3D; top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ThreadPoolExecutor consumerAndRec() &#123;</span><br><span class="line">            ThreadPoolExecutor poolExecutor &#x3D; new ThreadPoolExecutor(DEFAULT_CONSUMER_NUM,</span><br><span class="line">                    DEFAULT_CONSUMER_NUM &lt;&lt; 1,</span><br><span class="line">                    60 * 60 * 4,</span><br><span class="line">                    TimeUnit.SECONDS,</span><br><span class="line">                    new ArrayBlockingQueue&lt;&gt;(50),</span><br><span class="line">                    new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">            LOGGER.info(&quot;Consumer start.&quot;);</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; DEFAULT_CONSUMER_NUM; i++) &#123;</span><br><span class="line">                Thread t &#x3D; new Thread() &#123;</span><br><span class="line">                    int step &#x3D; 0;</span><br><span class="line">                    int consumerNum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        while (!this.isInterrupted()) &#123;</span><br><span class="line">                            Long phoneId;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                phoneId &#x3D; phoneIdQueue.take();</span><br><span class="line">                                if (phoneId.equals(STOP_FLAG)) &#123;</span><br><span class="line">                                    &#x2F;&#x2F; 该线程取到-1，说明产品队列中已无产品，可以结束线程，但是可能还有其他线程存活，需要通知其他线程已无数据</span><br><span class="line">                                    &#x2F;&#x2F; 因此，插入-1，同时跳出循环，线程归还线程池，等待监控线程发现其处于非活动状态，将其销毁，最终销毁线程池</span><br><span class="line">                                    phoneIdQueue.put(STOP_FLAG);</span><br><span class="line">                                    LOGGER.info(&quot;[&#123;&#125;] thread consumes done.&quot;, this.getName());</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                recOneUser(recJob, phoneId, top);</span><br><span class="line"></span><br><span class="line">                                consumerNum++;</span><br><span class="line">                                step++;</span><br><span class="line">                                if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123;</span><br><span class="line">                                    step &#x3D; 0;</span><br><span class="line">                                    LOGGER.info(&quot;[&#123;&#125;] thread has consumed &#123;&#125; pieces of data&quot;, this.getName(), consumerNum);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                LOGGER.error(&quot;read data from phoneIdQueue error.&quot;, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOGGER.info(&quot;[&#123;&#125;] thread altogether consumes &#123;&#125; user data&quot;, this.getName(), consumerNum);</span><br><span class="line">                        LOGGER.info(&quot;RecConsumer end.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                t.setName(&quot;RecConsumer-&quot; + i);</span><br><span class="line">                poolExecutor.execute(t);</span><br><span class="line">            &#125;</span><br><span class="line">            return poolExecutor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void recOneUser(RecJobBean recJob, long uid, int top) &#123;</span><br><span class="line">        Instant begin &#x3D; Instant.now();</span><br><span class="line">        List&lt;FlightInfoBean&gt; userFlightInfoList &#x3D; getFlightInfoMap().get(uid);</span><br><span class="line">        if (userFlightInfoList !&#x3D; null &amp;&amp; !userFlightInfoList.isEmpty()) &#123;</span><br><span class="line">            List&lt;TipsUserLinkBean&gt; recItems &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            switch (recJob) &#123;</span><br><span class="line">                case TIP:</span><br><span class="line">                    recItems &#x3D; tipRecService.rec(uid, userFlightInfoList, top);</span><br><span class="line">                    break;</span><br><span class="line">                case CAR:</span><br><span class="line">                    recItems &#x3D; carRecService.rec(uid, userFlightInfoList);</span><br><span class="line">                    break;</span><br><span class="line">                case HOTEL:</span><br><span class="line">                    recItems &#x3D; hotelRecService.rec(uid, userFlightInfoList, top);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(begin, Instant.now()).toMillis());</span><br><span class="line">            Instant saveStart &#x3D; Instant.now();</span><br><span class="line">            try &#123;</span><br><span class="line">                DataService.saveTipsUserLink(recItems, recJob);</span><br><span class="line">            &#125; catch (java.lang.NullPointerException np) &#123;</span><br><span class="line">                LOGGER.error(&quot;user [&#123;&#125;] saveTipsUserLink error.&quot;, uid, np);</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, save costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(saveStart, Instant.now()).toMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bubble Sort</title>
      <link href="/ckd70wo75000hqlydauhj1t6k/"/>
      <url>/ckd70wo75000hqlydauhj1t6k/</url>
      
        <content type="html"><![CDATA[<p>经典面试题---进阶版冒泡排序</p><a id="more"></a><h2 id="常规版"><a href="#常规版" class="headerlink" title="常规版"></a>常规版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""常规版"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(data)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>]:</span><br><span class="line">                data[j], data[j + <span class="number">1</span>] = data[j + <span class="number">1</span>], data[j]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">    print(data)</span><br><span class="line">    print(foo(data))</span><br></pre></td></tr></table></figure><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    进阶版</span></span><br><span class="line"><span class="string">    最坏情况 时间复杂度 O(n**2)</span></span><br><span class="line"><span class="string">    最好情况 时间复杂度 O(n)</span></span><br><span class="line"><span class="string">    稳定排序法</span></span><br><span class="line"><span class="string">    空间复杂度最佳 只需要一个额外空间</span></span><br><span class="line"><span class="string">    适用于数据量小或有部分数据已经排过序的情况</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># i 倒序循环列表排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># flag判断是否执行了交换操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):  <span class="comment"># i 为倒序循环，所以j的最大值即是i 0～i</span></span><br><span class="line">            <span class="keyword">if</span> data[j] &gt; data[j + <span class="number">1</span>]:</span><br><span class="line">                data[j], data[j + <span class="number">1</span>] = data[j + <span class="number">1</span>], data[j]</span><br><span class="line">                flag = <span class="literal">True</span>  <span class="comment"># 执行过交换操作，把flag置为True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:  <span class="comment"># 执行完一次扫描后，判断是否执行过交换操作，如果没有交换过数据，就表示此时数组已完成排序，故直接跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'第&#123;0&#125;次排序: &#123;1&#125;'</span>.format(len(data)-i, data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">    print(data)</span><br><span class="line">    print(bubble_sort(data))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
