<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动手实现：检查程序名称规范的编译器插件</title>
      <link href="/ckd5snfe30000anydb3v99he8/"/>
      <url>/ckd5snfe30000anydb3v99he8/</url>
      
        <content type="html"><![CDATA[<p>该案例主要为实现一个检查Java代码规范的编译器插件功能，编码规范遵循下面标准：</p><ul><li>类或接口：符合驼式命名法，首字母大写。</li><li>方法：符合驼式命名法，首字母小写。</li><li>字段：<br>类或实例变量。符合驼式命名法，首字母小写。<br>常量。要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。</li></ul><p>驼式命名法（Camel Case Name）是当前Java语言中主流的命名规范，我们的实战目标就是为Javac编译器添加一个额外的功能，在编译程序时检查程序名是否符合上述对类（或接口）、方法、字段的命名要求。</p><a id="more"></a><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="AbstractProcessor抽象类"><a href="#AbstractProcessor抽象类" class="headerlink" title="AbstractProcessor抽象类"></a>AbstractProcessor抽象类</h3><p>实现注解处理器的代码需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>，这个抽象类中只有一个子类必须实现的抽象方法<code>process()</code>。</p><blockquote><p>它是Javac编译器在执行注解处理器代码时要调用的过程。</p><ul><li>我们可以从这个方法的第一个参数<code>annotations</code>中获取到此注解处理器所要处理的注解集合；</li><li>从第二个参数<code>roundEnv</code>中访问到当前这个轮次（Round）中的抽象语法树节点，每个语法树节点在这里都表示为一个Element。</li></ul></blockquote><p>AbstractProcessor抽象类还有一个很重要的实例变量<code>processingEnv</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Processing environment providing by the tool framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">protected</span> ProcessingEnvironment processingEnv;</span><br></pre></td></tr></table></figure><p>它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init()方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。</p><h3 id="ElementKind枚举类"><a href="#ElementKind枚举类" class="headerlink" title="ElementKind枚举类"></a>ElementKind枚举类</h3><p>在javax.lang.model.ElementKind中定义了17类Element，已经包括了Java代码中可能出现的全部元素。</p><ul><li><code>javax.lang.model.ElementKind</code>枚举类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementKind &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declared types</span></span><br><span class="line">    <span class="comment">/** 枚举 */</span></span><br><span class="line">    ENUM,</span><br><span class="line">    <span class="comment">/** 类 */</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">/** 注解 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INTERFACE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Variables</span></span><br><span class="line">    <span class="comment">/** 枚举值. */</span></span><br><span class="line">    ENUM_CONSTANT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 本地变量. */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 异常. */</span></span><br><span class="line">    EXCEPTION_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executables</span></span><br><span class="line">    <span class="comment">/** 方法. */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 构造函数. */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 静态语句块 即static&#123;&#125;块. */</span></span><br><span class="line">    STATIC_INIT,</span><br><span class="line">    <span class="comment">/** 实例语句块 即&#123;&#125;块. */</span></span><br><span class="line">    INSTANCE_INIT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数化类型：泛型尖括号内的类型. */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未定义的其他语法树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OTHER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源变量：try-resource中定义d变量.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RESOURCE_VARIABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this is a kind of class:</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> CLASS&#125; or &#123;<span class="doctag">@code</span> ENUM&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this is a kind of class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == CLASS || <span class="keyword">this</span> == ENUM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this is a kind of interface:</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> INTERFACE&#125; or &#123;<span class="doctag">@code</span> ANNOTATION_TYPE&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this is a kind of interface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == INTERFACE || <span class="keyword">this</span> == ANNOTATION_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this is a kind of field:</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> FIELD&#125; or &#123;<span class="doctag">@code</span> ENUM_CONSTANT&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this is a kind of field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == FIELD || <span class="keyword">this</span> == ENUM_CONSTANT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="两个注解"><a href="#两个注解" class="headerlink" title="两个注解"></a>两个注解</h3><p>注解处理器除了process()方法及其参数之外，还有两个经常配合着使用的注解，分别是：</p><ul><li><code>@SupportedAnnotationTypes</code>：<br>代表了这个注解处理器对哪些注解感兴趣，可以使用星号 <code>*</code> 作为通配符代表对所有的注解都感兴趣。</li><li><code>@SupportedSourceVersion</code>：<br>指出这个注解处理器可以处理哪些版本的Java代码。</li></ul><p>每一个注解处理器在运行时都是<code>单例的</code>，如果不需要改变或添加抽象语法树中的内容，process()方法就可以返回一个值为false的布尔值，通知编译器这个轮次中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process()方法的返回值一律都是false。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="注解处理器NameCheckProcessor"><a href="#注解处理器NameCheckProcessor" class="headerlink" title="注解处理器NameCheckProcessor"></a>注解处理器NameCheckProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入式注解处理器：对Java程序命名进行检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-28 16:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 表示支持所有的Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK8的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnv 它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init()方法执行的时候）创建，</span></span><br><span class="line"><span class="comment">     *                      继承了AbstractProcessor的注解处理器代码可以直接访问它。</span></span><br><span class="line"><span class="comment">     *                      它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该方法是Javac编译器在执行注解处理器代码时要调用的过程：</span></span><br><span class="line"><span class="comment">     * 每一个注解处理器在运行时都是单例的，如果不需要改变或添加抽象语法树中的内容，</span></span><br><span class="line"><span class="comment">     * process() 方法就可以返回一个值为false的布尔值，通知编译器这个轮次中的代码未发生变化，无须构造新的 JavaCompiler实例。</span></span><br><span class="line"><span class="comment">     * 自定义的此注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process()方法的返回值一律都是false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotations 获取到此注解处理器所要处理的注解集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnv 参数“roundEnv”中访问到当前这个轮次（Round）中的抽象语法树节点，</span></span><br><span class="line"><span class="comment">     *                 每个语法树节点在这里都表示为一个Element。</span></span><br><span class="line"><span class="comment">     *                 在javax.lang.model.ElementKind中定义了18类Element。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            roundEnv.getRootElements().forEach(element -&gt; nameChecker.checkNames(element));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名检查器NameChecker"><a href="#命名检查器NameChecker" class="headerlink" title="命名检查器NameChecker"></a>命名检查器NameChecker</h4><p>它通过一个继承于<code>javax.lang.model.util.ElementScanner8</code>的NameCheckScanner类，以Visitor模式来完成对语法树的遍历，分别执行visitType()、visitVariable()和visitExecutable()方法来访问类、字段和方法，这3个visit*()方法对各自的命名规则做相应的检查，checkCamelCase()与checkAllCaps()方法则用于实现驼式命名法和全大写命名规则的检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner8;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.tools.Diagnostic.Kind.WARNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查程序名称规范的编译器插件：</span></span><br><span class="line"><span class="comment"> * 如果程序命名不符合规范，会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-28 16:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Messager用于向编译器发送信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NameChecker</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     * - 类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * - 方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * - 字段：</span></span><br><span class="line"><span class="comment">     * 类或实例变量。符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * 常量。要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类。</span></span><br><span class="line"><span class="comment">     * 继承了ElementScanner8，会以Visitor模式访问抽象语法树中的元素。</span></span><br><span class="line"><span class="comment">     * 命名规则判断中将不对语法树进行修改，因此全部返回值都为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner8</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ElementKind.METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName())) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法["</span> + name + <span class="string">"]不应当与类名重复，避免与构造函数产生冲突"</span>);</span><br><span class="line">                    checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e)) &#123;</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == ElementKind.INTERFACE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == ElementKind.FIELD || e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="comment">// 前缀首字母大写</span></span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称["</span> + name + <span class="string">"]应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称["</span> + name + <span class="string">"]应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!conventional) &#123;</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称["</span> + name + <span class="string">"]应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional) &#123;</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量["</span> + name + <span class="string">"]应当全部以大写字母或下划线命名，并且以字母开头"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译测试"><a href="#编译测试" class="headerlink" title="编译测试"></a>编译测试</h2><h3 id="命名规范的“反面教材”代码"><a href="#命名规范的“反面教材”代码" class="headerlink" title="命名规范的“反面教材”代码"></a>命名规范的“反面教材”代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bubble.processor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命名规范的“反面教材”代码：</span></span><br><span class="line"><span class="comment"> * 使用：</span></span><br><span class="line"><span class="comment"> * 可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，</span></span><br><span class="line"><span class="comment"> * 如果有多个注解 处理器的话，用逗号分隔。</span></span><br><span class="line"><span class="comment"> * 还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-07-28 17:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译测试-1"><a href="#编译测试-1" class="headerlink" title="编译测试"></a>编译测试</h3><p>们可以通过<code>Javac</code>命令的<code>-processor参数</code>来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。<br>还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运 作的详细信息。</p><p>编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd code/java/multi-dev/data-structure/src/main/java/</span><br><span class="line">javac com/bubble/processor/NameChecker.java</span><br><span class="line">javac com/bubble/processor/NameCheckProcessor.java</span><br><span class="line"></span><br><span class="line">javac -processor com.bubble.processor.NameCheckProcessor com/bubble/processor/BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F;bubble&#x2F;processor&#x2F;BADLY_NAMED_CODE.java:13: 警告: 名称[BADLY_NAMED_CODE]应当符合驼式命名法（Camel Case Names）</span><br><span class="line">public class BADLY_NAMED_CODE &#123;</span><br><span class="line">       ^</span><br><span class="line">com&#x2F;bubble&#x2F;processor&#x2F;BADLY_NAMED_CODE.java:15: 警告: 名称[colors]应当以大写字母开头</span><br><span class="line">    enum colors &#123;</span><br><span class="line">    ^</span><br><span class="line">警告: 常量[red]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 常量[blue]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 常量[green]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 常量[_FORTY_TWO]应当全部以大写字母或下划线命名，并且以字母开头</span><br><span class="line">警告: 一个普通方法[BADLY_NAMED_CODE]不应当与类名重复，避免与构造函数产生冲突</span><br><span class="line">com&#x2F;bubble&#x2F;processor&#x2F;BADLY_NAMED_CODE.java:22: 警告: 名称[BADLY_NAMED_CODE]应当以小写字母开头</span><br><span class="line">    protected void BADLY_NAMED_CODE() &#123;</span><br><span class="line">                   ^</span><br><span class="line">8 个警告</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>002 虚拟机对象</title>
      <link href="/ckc0d6ptv0000qyydegky1iwy/"/>
      <url>/ckc0d6ptv0000qyydegky1iwy/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><a id="more"></a><h1 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="对象的创建流程"><a href="#对象的创建流程" class="headerlink" title="对象的创建流程"></a>对象的创建流程</h3><ul><li>使用new指令来创建对象；</li><li>首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化；</li><li>如果没有，说明是新建，就先执行相应的类加载的过程；</li><li>类加载检查通过后，为虚拟机新生对象分配堆内存；</li><li>堆内存分配成功后，再把分配到的内存空间（不包括对象头）都初始化为零值；</li><li>再执行类文件的<init>()方法，按照Dev的设定来进行构造，把对象进行初始化，得到一个真正的对象。</init></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code>。</p><h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>对象头包括两类信息：一是<code>用于存储对象自身的运行时数据</code>；二是<code>类型指针</code>。</p><h4 id="1、存储对象自身的运行时数据"><a href="#1、存储对象自身的运行时数据" class="headerlink" title="1、存储对象自身的运行时数据"></a>1、存储对象自身的运行时数据</h4><p>如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它为<code>Mark Word</code>。</p><blockquote><p><strong>Mark Word</strong>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p></blockquote><h4 id="2、类型指针"><a href="#2、类型指针" class="headerlink" title="2、类型指针"></a>2、类型指针</h4><p>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><blockquote><p>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身</p></blockquote><blockquote><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数。<br>因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。</p></blockquote><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><p>实例数据是对象真正存储等有效信息。也就是我们所定义的各种类型的字段内容，<br>无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到<strong>虚拟机分配策略参数</strong>(<code>-XX:FieldsAllocationStyle</code>参数)和<strong>字段在Java源码中定义顺序</strong>的影响。</p><blockquote><p>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，<br>由上可知：相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。<br>如果HotSpot虚拟机的 <code>+XX:CompactFields</code>参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p></blockquote><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>对齐填充不是必然存在的，它仅仅起着占位符的作用。<br>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是<code>8字节的整数倍</code>。<br>换句话说就是<strong>任何对象的大小都必须是8字节的整数倍</strong>。<br>对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>创建了对象就需要使用它，Java Dev会通过栈上的reference数据来操作堆上的具体对象。<br>由于<code>reference类型</code>在《Java虚拟机规范》里面只规定了它<strong>是一个指向对象的引用</strong>，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。<br>所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种。</p><h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><h4 id="使用句柄访问对象"><a href="#使用句柄访问对象" class="headerlink" title="使用句柄访问对象"></a>使用句柄访问对象</h4><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是<strong>对象的句柄地址</strong>，而<strong>句柄中包含了对象实例数据与类型数据各自具体的地址信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jubing.png" alt="使用句柄访问对象"></p><h4 id="使用直接指针访问对象"><a href="#使用直接指针访问对象" class="headerlink" title="使用直接指针访问对象"></a>使用直接指针访问对象</h4><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中<strong>存储的直接就是对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/obj-zhizhen.png" alt="使用直接指针访问对象"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li><li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的intern()方法</title>
      <link href="/ckbesij6t000029s67j9p5x9z/"/>
      <url>/ckbesij6t000029s67j9p5x9z/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>String::intern()</code>是一个Native方法，用于返回该对象在常量池中的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>示例1：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 在JDK 6中运行，会得到三个false；</span></span><br><span class="line"><span class="comment"> * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储，</span></span><br><span class="line"><span class="comment"> * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，</span></span><br><span class="line"><span class="comment"> * 所以必然不可能是同一个引用，结果将返回false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 而在JDK 7后中运行，会得到一个true、一个false和一个true；</span></span><br><span class="line"><span class="comment"> * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中，</span></span><br><span class="line"><span class="comment"> * 那只需要在常量池里记录一下首次出现的实例引用即可。</span></span><br><span class="line"><span class="comment"> * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。</span></span><br><span class="line"><span class="comment"> * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的)</span></span><br><span class="line"><span class="comment"> * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。</span></span><br><span class="line"><span class="comment"> * 而str3和str1一样，"JDKJVM"这个字符串则是首次出现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JVM"</span>).append(<span class="string">"调优"</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="comment">// java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参考：https://www.zhihu.com/question/51102308/answer/124441115</span></span><br><span class="line"><span class="comment">     * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化，</span></span><br><span class="line"><span class="comment">     * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化，</span></span><br><span class="line"><span class="comment">     * 此时被 sun.misc.Version.launcher 静态常量字段所引用的"java"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">    <span class="comment">// 而JDKJVM这个字符串则是首次出现</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JDK"</span>).append(<span class="string">"JVM"</span>).toString();</span><br><span class="line">    System.out.println(str3.intern() == str3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。</span></span><br><span class="line"><span class="comment"> * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。</span></span><br><span class="line"><span class="comment"> * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的"JVM"。</span></span><br><span class="line"><span class="comment"> * - b：先将字符串"JVM"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的"JVM"，最后将b指向heap中创建的这个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也就是说，a和b存储的内容是一样的，都是"JVM"，但地址不一样：a中保存的是常量池中"JVM"的地址，b保存的是heap中那个对象的地址，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 双等于号"=="比较的是地址，equals()比较的是内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compareStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"JVM"</span>;</span><br><span class="line">    <span class="comment">// new一个对象</span></span><br><span class="line">    String b = <span class="keyword">new</span> String(<span class="string">"JVM"</span>);</span><br><span class="line">    <span class="comment">// == 比较地址是否相等</span></span><br><span class="line">    <span class="comment">// 都在运行时常量池中</span></span><br><span class="line">    System.out.println(<span class="string">"JVM"</span> == a); <span class="comment">// true</span></span><br><span class="line">    System.out.println(a.intern() == a); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">    System.out.println(a.intern() == b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(a.equals(b));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例2：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         双等号"=="比较的是地址；equals()比较的是内容。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1 == s3.intern()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s3 == s4);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3.intern() == s4.intern());  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Neo4j的时光网电影数据可视化【附源码】</title>
      <link href="/ckbarwdyc0000z5yd8tl0cjqn/"/>
      <url>/ckbarwdyc0000z5yd8tl0cjqn/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Neo4j的电影数据可视化"><a href="#基于Neo4j的电影数据可视化" class="headerlink" title="基于Neo4j的电影数据可视化"></a>基于Neo4j的电影数据可视化</h1><p>本文主要内容为：</p><ul><li>基于requests + BeautifulSoup抓取时光网电影数据；</li><li>基于电影数据构建电影和关系实体信息；</li><li>数据导入neo4j进行存储分析；</li><li>基于Bottle框架的对neo4j数据进行查询可视化展示。</li></ul><p>效果展示：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/web-demo.png" alt="效果展示"></p><a id="more"></a><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="新建虚拟环境并安装所需包"><a href="#新建虚拟环境并安装所需包" class="headerlink" title="新建虚拟环境并安装所需包"></a>新建虚拟环境并安装所需包</h3><ul><li>新建虚拟环境：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看本机已经安装的python虚拟环境</span><br><span class="line">conda env list</span><br><span class="line"># 新建graph-37环境</span><br><span class="line">conda create -n graph-37 python&#x3D;3.7</span><br><span class="line"># 生效新建的虚拟环境</span><br><span class="line">conda activate graph-37</span><br><span class="line">## 退出</span><br><span class="line">#conda deactivate</span><br></pre></td></tr></table></figure></li><li>安装所需包：<br>根据requirements.txt文件来安装：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>requirements.txt文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">beautifulsoup4&#x3D;&#x3D;4.9.1</span><br><span class="line">bs4&#x3D;&#x3D;0.0.1</span><br><span class="line">certifi&#x3D;&#x3D;2020.4.5.1</span><br><span class="line">chardet&#x3D;&#x3D;3.0.4</span><br><span class="line">Click&#x3D;&#x3D;7.0</span><br><span class="line">colorama&#x3D;&#x3D;0.4.3</span><br><span class="line">et-xmlfile&#x3D;&#x3D;1.0.1</span><br><span class="line">idna&#x3D;&#x3D;2.9</span><br><span class="line">jdcal&#x3D;&#x3D;1.4.1</span><br><span class="line">lxml&#x3D;&#x3D;4.5.1</span><br><span class="line">neobolt&#x3D;&#x3D;1.7.17</span><br><span class="line">neotime&#x3D;&#x3D;1.7.4</span><br><span class="line">numpy&#x3D;&#x3D;1.18.5</span><br><span class="line">openpyxl&#x3D;&#x3D;3.0.3</span><br><span class="line">pandas&#x3D;&#x3D;1.0.4</span><br><span class="line">prompt-toolkit&#x3D;&#x3D;2.0.10</span><br><span class="line">py2neo&#x3D;&#x3D;4.3.0</span><br><span class="line">Pygments&#x3D;&#x3D;2.3.1</span><br><span class="line">python-dateutil&#x3D;&#x3D;2.8.1</span><br><span class="line">pytz&#x3D;&#x3D;2020.1</span><br><span class="line">requests&#x3D;&#x3D;2.23.0</span><br><span class="line">six&#x3D;&#x3D;1.15.0</span><br><span class="line">soupsieve&#x3D;&#x3D;2.0.1</span><br><span class="line">urllib3&#x3D;&#x3D;1.24.3</span><br><span class="line">wcwidth&#x3D;&#x3D;0.2.4</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>本文数据来自<a href="http://www.mtime.com/top/movie/top100/" target="_blank" rel="external nofollow noopener noreferrer">时光网电影Top100</a>。<br>基于python对该源进行数据抓取，并将数据生成相应的实体和关系：<br>可参考：<a href="https://github.com/bubblewu/movie-neo4j/blob/master/mtime/mtime_main.py" target="_blank" rel="external nofollow noopener noreferrer">GitHub：时光网数据抓取处理</a></p><p>实体和关系如下：：</p><ul><li><p>电影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index:ID,rank,src,name,movie_en,year,image,:LABEL</span><br><span class="line">10000,1,http:&#x2F;&#x2F;movie.mtime.com&#x2F;12231&#x2F;,肖申克的救赎,The Shawshank Redemption,1994,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;03&#x2F;07&#x2F;123549.37376649_96X128.jpg,电影表</span><br><span class="line">10001,2,http:&#x2F;&#x2F;movie.mtime.com&#x2F;99547&#x2F;,盗梦空间,Inception,2010,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;01&#x2F;06&#x2F;105446.89493583_96X128.jpg,电影表</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>演员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index:ID,actor,:LABEL</span><br><span class="line">30000,杰伊·巴鲁切尔,演员表</span><br><span class="line">30001,维果·莫腾森,演员表</span><br><span class="line">30002,布拉德·皮特,演员表</span><br><span class="line">30003,李·科布,演员表</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>导演：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index:ID,director,:LABEL</span><br><span class="line">20000,彼得·索恩,导演表</span><br><span class="line">20001,克里斯托弗·诺兰,导演表</span><br><span class="line">20002,朴赞郁,导演表</span><br><span class="line">20003,赛尔乔·莱昂内,导演表</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>关系：</p><ul><li><p>电影与导演关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:START_ID,:END_ID,relation,:TYPE</span><br><span class="line">20069,10000,导演,导演</span><br><span class="line">20001,10001,导演,导演</span><br><span class="line">20010,10002,导演,导演</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>电影与主演关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:START_ID,:END_ID,relation,:TYPE</span><br><span class="line">30156,10000,主演,主演</span><br><span class="line">30026,10000,主演,主演</span><br><span class="line">30063,10001,主演,主演</span><br><span class="line">30031,10001,主演,主演</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>导演和演员关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:START_ID,:END_ID,relation,:TYPE</span><br><span class="line">20069,30156,相关,相关</span><br><span class="line">20069,30026,相关,相关</span><br><span class="line">20001,30063,相关,相关</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="Neo4j存储"><a href="#Neo4j存储" class="headerlink" title="Neo4j存储"></a>Neo4j存储</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。</p><p>通过下面的命令导入定义好的实体和关系数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># 脚本来执行将csv文件（节点和关系）导入neo4j</span><br><span class="line"># 注意：必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。</span><br><span class="line"></span><br><span class="line">db_name&#x3D;MovieMTime.db</span><br><span class="line">neo4j_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4</span><br><span class="line">base_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;code&#x2F;python&#x2F;moive-kg&#x2F;data&#x2F;mtime</span><br><span class="line"></span><br><span class="line">import() &#123;</span><br><span class="line">  cd $&#123;neo4j_path&#125;</span><br><span class="line">  .&#x2F;bin&#x2F;neo4j stop</span><br><span class="line">  rm -rf &#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4&#x2F;data&#x2F;databases&#x2F;$&#123;db_name&#125;</span><br><span class="line">  .&#x2F;bin&#x2F;neo4j-admin import --verbose \</span><br><span class="line">                        --database $&#123;db_name&#125; \</span><br><span class="line">                        --id-type STRING \</span><br><span class="line">                        --input-encoding&#x3D;UTF-8 \</span><br><span class="line">                        --ignore-extra-columns&#x3D;false \</span><br><span class="line">                        --trim-strings&#x3D;true \</span><br><span class="line">                        --delimiter&#x3D;, \</span><br><span class="line">                        --array-delimiter&#x3D;&#39;;&#39; \</span><br><span class="line">                        --processors&#x3D;4 \</span><br><span class="line">                        --nodes $&#123;base_path&#125;&#x2F;mtime_movie_entity.csv \</span><br><span class="line">                        --nodes $&#123;base_path&#125;&#x2F;mtime_actor_entity.csv \</span><br><span class="line">                        --nodes $&#123;base_path&#125;&#x2F;mtime_director_entity.csv \</span><br><span class="line">                        --relationships $&#123;base_path&#125;&#x2F;mtime_director_actor_relationship.csv \</span><br><span class="line">                        --relationships $&#123;base_path&#125;&#x2F;mtime_movie_actor_relationship.csv  \</span><br><span class="line">                        --relationships $&#123;base_path&#125;&#x2F;mtime_movie_director_relationship.csv</span><br><span class="line">  # 需要修改neo4j.conf配置文件中的默认db才能展示新建的db，否则还是默认的。（只能指定一个db）</span><br><span class="line">#  .&#x2F;bin&#x2F;neo4j start</span><br><span class="line">#  .&#x2F;bin&#x2F;neo4j stop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import</span><br></pre></td></tr></table></figure><h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><p>修改配置将默认db改为刚才新建的电影的db，否则还是默认的库。<br>vim conf/neo4j.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbms.active_database&#x3D;MovieMTime.db</span><br></pre></td></tr></table></figure><p>启动neo4j服务（neo4j版本为4.0.3）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;neo4j start</span><br></pre></td></tr></table></figure><p>进入管理界面：<a href="http://127.0.0.1:7474/" target="_blank" rel="external nofollow noopener noreferrer">http://127.0.0.1:7474</a></p><p>查看实体数据：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/neo4j-moviemtime-movie.png" alt="实体数据可视化"></p><p>查看关系数据：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/moviemtime-relationships.png" alt="关系数据可视化"></p><h2 id="数据查询可视化"><a href="#数据查询可视化" class="headerlink" title="数据查询可视化"></a>数据查询可视化</h2><p>查询可视化基于Bottle框架的Web服务。<br>参考：<a href="https://github.com/bubblewu/movie-neo4j/blob/master/mtime/mtime_graph_show.py" target="_blank" rel="external nofollow noopener noreferrer">GitHub: 可视化</a></p><p>效果如下图：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/neo4j/moviemtime-web.png" alt="电影信息可视化"></p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><ul><li><a href="https://github.com/bubblewu/movie-neo4j" target="_blank" rel="external nofollow noopener noreferrer">movie-neo4j</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neo4j </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>001 运行时数据区域和OutOfMemoryError异常</title>
      <link href="/ckbarvw2z0045yayd50uf5v6u/"/>
      <url>/ckbarvw2z0045yayd50uf5v6u/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲解JVM运行时数据区域，并通过简单的案例来实现说明各个区域中的常见OOM异常。</p><a id="more"></a><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>运行时数据区域图：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-rda.png" alt="运行时数据区域图"></p><p>Java内存区域：<br>JVM内存区域主要分为<code>线程私有区域</code>【程序计数器、虚拟机栈、本地方法栈】、<code>线程共享区域</code>【Java堆、方法区】、直接内存。<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-mind.png" alt="JVM内存导图"></p><ul><li><p>线程私有区域：<br>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM内,每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p></li><li><p>线程共享区域：<br>线程共享区域随虚拟机的启动/关闭而创建/销毁。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-rda2.png" alt="运行时数据区域图2"></p><h1 id="JVM主要区域溢出异常"><a href="#JVM主要区域溢出异常" class="headerlink" title="JVM主要区域溢出异常"></a>JVM主要区域溢出异常</h1><p>在Java虚拟机规范中规定，除了<code>程序计数器</code>外，虚拟机的其他几个运行时区域都有发生OOM异常的可能，如：<strong>方法区（运行时常量池）、Java堆、虚拟机栈（局部变量表）、本地方法栈和直接内存。</strong></p><p>下面将通过案例来验证各个运行时区域的溢出异常，并分析我们来如何解决和避免这些异常。</p><blockquote><p>注：下面的代码基于<strong>JDK8</strong>进行开发测试；</p></blockquote><h2 id="线程独占区"><a href="#线程独占区" class="headerlink" title="线程独占区"></a>线程独占区</h2><h3 id="程序计数器（无OOM）"><a href="#程序计数器（无OOM）" class="headerlink" title="程序计数器（无OOM）"></a>程序计数器（无OOM）</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为<code>线程私有</code>的内存。</p><ul><li>正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。</li><li>如果是Native方法，则为空（undefined）。</li></ul><p>这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError 情况的区域。</p><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><strong>虚拟机栈描述的是<code>Java方法</code>执行的线程内存模型</strong>。</p><h5 id="栈帧（Stack-Frame）："><a href="#栈帧（Stack-Frame）：" class="headerlink" title="栈帧（Stack Frame）："></a><code>栈帧（Stack Frame）</code>：</h5><p>每个方法被执行的时候，Java虚拟机都会同步创建一个<code>栈帧</code>用于<strong>存储局部变量表、操作数栈、动态连接、方法出口等信息</strong>。<br>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvm-stack.png" alt="栈帧"></p><h5 id="局部变量表："><a href="#局部变量表：" class="headerlink" title="局部变量表："></a><code>局部变量表</code>：</h5><p>局部变量表存放了编译期可知的：</p><ul><li>各种<code>Java虚拟机基本数据类型</code>：boolean、byte、char、short、int、 float、long、double；</li><li><code>对象引用</code> ：reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置；</li><li><code>returnAddress类型</code>：指向了一条字节码指令的地址。</li></ul><p>这些数据类型在局部变量表中的存储空间以<code>局部变量槽(Slot)</code>来表示。<br><strong>其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个</strong>。<br>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，<strong>在方法运行期间不会改变局部变量表的大小</strong>。</p><h5 id="两种异常：栈-堆溢出"><a href="#两种异常：栈-堆溢出" class="headerlink" title="两种异常：栈/堆溢出"></a>两种异常：栈/堆溢出</h5><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code>；</li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code>。</li></ul><h4 id="虚拟机栈-amp-本地方法栈"><a href="#虚拟机栈-amp-本地方法栈" class="headerlink" title="虚拟机栈&amp;本地方法栈"></a>虚拟机栈&amp;本地方法栈</h4><p>Java虚拟机栈（Java Virtual Machine Stack）和本地方法栈（Native Method Stacks）非常相似，<code>都属于线程独占区</code>，区别是：</p><ul><li>虚拟机栈为虚拟机执行<code>Java方法（也就是字节码）服务</code>；</li><li>本地方法栈为虚拟机使用到的<code>本地方法（Native方法）服务</code>；</li></ul><p><strong>Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p><h4 id="虚拟机栈和本地方法栈溢出案例"><a href="#虚拟机栈和本地方法栈溢出案例" class="headerlink" title="虚拟机栈和本地方法栈溢出案例"></a>虚拟机栈和本地方法栈溢出案例</h4><h5 id="栈容量参数：-Xss"><a href="#栈容量参数：-Xss" class="headerlink" title="栈容量参数：-Xss"></a>栈容量参数：-Xss</h5><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，<code>栈容量只能由-Xss参数来设定</code>。</p><h5 id="栈-堆溢出的场景"><a href="#栈-堆溢出的场景" class="headerlink" title="栈/堆溢出的场景"></a>栈/堆溢出的场景</h5><p>《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展。<br>所以除非<code>在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常</code>，否则<code>在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常</code>。</p><h5 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h5><p>将实验范围限制在<strong>单线程中操作</strong>，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常：</p><ul><li><p>使用<code>-Xss参数减少栈内存容量</code>。<br>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 </p></li><li><p><code>定义大量的本地变量，增大此方法帧中本地变量表的长度</code>。<br>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 </p></li></ul><h6 id="单线程下：使用-Xss参数减少栈内存容量（SOF异常）"><a href="#单线程下：使用-Xss参数减少栈内存容量（SOF异常）" class="headerlink" title="单线程下：使用-Xss参数减少栈内存容量（SOF异常）"></a>单线程下：使用<code>-Xss参数减少栈内存容量</code>（SOF异常）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java虚拟机栈和本地方法机栈异常（单线程操作下）</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss160k（Mac 64Bit要求最低栈内存为160K）</span></span><br><span class="line"><span class="comment"> * 使用-Xss参数减少栈内存容量。</span></span><br><span class="line"><span class="comment"> * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 15:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VMStackSOF stackSOF = <span class="keyword">new</span> VMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackSOF.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + stackSOF.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack length: 773</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.bubble.jvm.error.VMStackSOF.stackLeak(VMStackSOF.java:16)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h6 id="单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）"><a href="#单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）" class="headerlink" title="单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）"></a>单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java虚拟机栈和本地方法机栈异常（单线程操作下）</span></span><br><span class="line"><span class="comment"> * 定义大量的本地变量，增大此方法帧中本地变量表的长度</span></span><br><span class="line"><span class="comment"> * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 15:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStackSOF02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5, unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15, unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25, unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35, unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45, unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55, unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65, unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75, unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85, unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95, unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 = unused6 = unused7 = unused8 = unused9 = unused10 = unused11 =</span><br><span class="line">                unused12 = unused13 = unused14 = unused15 = unused16 = unused17 = unused18 = unused19 = unused20 = unused21 = unused22 = unused23 = unused24 = unused25 = unused26 = unused27 = unused28 = unused29 = unused30 = unused31 = unused32 = unused33 = unused34 = unused35 = unused36 = unused37 = unused38 = unused39 = unused40 = unused41 = unused42 = unused43 = unused44 = unused45 = unused46 = unused47 = unused48 = unused49 = unused50 = unused51 = unused52 = unused53 = unused54 = unused55 = unused56 = unused57 = unused58 = unused59 = unused60 = unused61 = unused62 = unused63 = unused64 = unused65 = unused66 = unused67 = unused68 = unused69 = unused70 = unused71 = unused72 = unused73 = unused74 = unused75 = unused76 = unused77 = unused78 = unused79 = unused80 = unused81 = unused82 = unused83 = unused84 = unused85 = unused86 = unused87 = unused88 = unused89 = unused90 = unused91 = unused92 = unused93 = unused94 = unused95 = unused96 =</span><br><span class="line">                        unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack length: 8121Exception in thread &quot;main&quot; </span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">at com.bubble.jvm.error.VMStackSOF02.test(VMStackSOF02.java:26)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h6 id="多线程下：OOM异常"><a href="#多线程下：OOM异常" class="headerlink" title="多线程下：OOM异常"></a>多线程下：OOM异常</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程下，Java虚拟机栈和本地方法栈OOM异常</span></span><br><span class="line"><span class="comment"> * VM Args:-Xss2M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 16:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; dontStop());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VMStackOOM vmStackOOM = <span class="keyword">new</span> VMStackOOM();</span><br><span class="line">        vmStackOOM.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create native thread</span><br></pre></td></tr></table></figure><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>实验结果表明：</p><ul><li>单线程下：</li></ul><p><strong>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。</strong><br>如果在允许动态扩展栈容量大小的虚拟机上，相同代码则会导致不一样的情况，如第二个代码（定义大量的本地变量，增大此方法帧中本地变量表的长度）示例就会抛出OutOfMemoryError异常。</p><ul><li>多线程下：<br>如果通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的，如第三个代码。<br>但是这样<strong>产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系</strong>，<strong>主要取决于操作系统本身的内存使用状态</strong>。<br>甚至可以说，在这种情况下，<code>给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常</code>。</li></ul><blockquote><p>因为：<strong>操作系统分配给每个进程的内存是有限制的</strong>。<br>如32位Windows的单个进程最大内存限制为2GB。<br>HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，<br>那<code>剩余的内存（由虚拟机栈和本地方法栈来分配的内存）</code>为<strong>2GB(操作系统限制)减去最大堆容量，再减去最大方法区容量</strong>。</p><blockquote><p>注意：由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话。</p></blockquote><p>因此<code>为每个线程分配到的栈内存越大，可以建立的线程数量自 然就越少，建立线程时就越容易把剩下的内存耗尽</code>。</p></blockquote><ul><li>通过<code>减少内存</code>的手段来解决内存溢出的方式：<br>如果是建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，就只<strong>通过<code>减少最大堆</code>和<code>减少栈容量</code>来换取更多的线程</strong>。</li></ul><h2 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Java堆（Java Heap）是虚拟机管理的内存中的最大一块区域，也是垃圾回收的主要区域，它属于<code>线程共享区</code>，用于<code>存储对象实例</code>。</p><h4 id="Java堆时垃圾收集器管理的内存区域"><a href="#Java堆时垃圾收集器管理的内存区域" class="headerlink" title="Java堆时垃圾收集器管理的内存区域"></a>Java堆时垃圾收集器管理的内存区域</h4><p>Java堆也被称为GC堆（Garbage Collected Heap）。</p><ul><li><p>从<strong>回收内存角度</strong>来看：<br>垃圾收集器大部分都是基于<code>分代收集理论</code>设计的，会有 <strong>新生代、老年代、永久代（JDK8改为元空间）、Eden空间、From Survivor空间、To Survivor空间</strong>等名词。<br>这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。</p></li><li><p>从<strong>分配内存角度</strong>来看：<br>所有线程共享的Java堆中可以划分出多个线程私有的<code>分配缓冲区</code>（TLAB, Thread Local Allocation Buffer），可以提升对象分配时的效率。<br>不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，<strong>存储的都只能是对象的实例</strong>，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p></li></ul><h4 id="物理存储空间"><a href="#物理存储空间" class="headerlink" title="物理存储空间"></a>物理存储空间</h4><p>Java堆可以处于<strong>物理上不连续的内存空间</strong>中，但在逻辑上它应该被视为连续的。<br>就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。</p><blockquote><p>注意：但对于<strong>大对象</strong>(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p></blockquote><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><p>Java堆可以设置为固定大小，也可以为可动态扩展的。<br>通过参数<code>-Xmx</code>和<code>-Xms</code>来设定堆的最大和最小内存容量。<strong>将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展</strong>。</p><p>如果<strong>在Java堆中没有内存完成实例分配，并且堆也无法再扩展时</strong>，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p><h4 id="为什么会堆溢出？"><a href="#为什么会堆溢出？" class="headerlink" title="为什么会堆溢出？"></a>为什么会堆溢出？</h4><p>当我们不断地创建新对象时，并且使GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，这时候，对象数量不断增加，总容量超过最大堆的容量限制后，就会发生内存溢出异常。</p><h4 id="OMM的两种情况"><a href="#OMM的两种情况" class="headerlink" title="OMM的两种情况"></a>OMM的两种情况</h4><p>可以通过内存映像分析工具对dump出的堆存储快照进行分析。<br>首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p><h5 id="内存泄露（Memory-Leak）"><a href="#内存泄露（Memory-Leak）" class="headerlink" title="内存泄露（Memory Leak）"></a>内存泄露（Memory Leak）</h5><p>如果是内存泄漏（<code>内存中的对象不是必须存活的，垃圾收集器未收集</code>），可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致<code>垃圾收集器无法回收它们</code>，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</p><h5 id="内存溢出（Memory-Overflow）"><a href="#内存溢出（Memory-Overflow）" class="headerlink" title="内存溢出（Memory Overflow）"></a>内存溢出（Memory Overflow）</h5><p>如果不是内存泄漏，换句话说就是<code>内存中的对象确实都是必须存活的</code>，那就应当：</p><ul><li>检查Java虚拟机的堆参数(-Xmx与-Xms)设置，与机器的内存对比，看看是否还有向上调整的空间。</li><li>再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</li></ul><h4 id="溢出案例和dump快照分析"><a href="#溢出案例和dump快照分析" class="headerlink" title="溢出案例和dump快照分析"></a>溢出案例和dump快照分析</h4><p>使用虚拟机参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>限制Java堆的大小为20M B，不可扩展。<br>通过参数<code>-XX:+HeapDumpOnOutOf-MemoryError</code>可以<strong>让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照</strong>，以便进行事后分析。(文件存储在该项目父目录下，如：java_pid80802.hprof)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java堆内存异常测试</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid80802.hprof ...</span><br><span class="line">Heap dump file created [27964242 bytes in 0.193 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:265)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:462)</span><br><span class="line">at com.bubble.jvm.error.JavaHeapOOM.main(JavaHeapOOM.java:23)</span><br></pre></td></tr></table></figure><p>可以在目录/Users/wugang/code/java/multi-dev下看到java_pid80802.hprof文件。</p><ul><li>分析dump文件：<br>可以通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出来的堆转储快照进行分析，也可以通过JDK自带的工具jvisualvm来可视化分析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 控制行执行命令</span><br><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>会打开下面的窗口，打开对应的堆dump文件：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvisualvm-01.png" alt="jvisualvm-起始页"></li></ul><p>主要内容为：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvisualvm-02.png" alt="jvisualvm-概要"><br>由上图可知：导致 OutOfMemoryError 异常错误的线程是 main</p><p>查看dump的类信息：<br><img src="https://cdn.jsdelivr.net/gh/bubblewu/cdn/images/jvm/jvisualvm-03.png" alt="jvisualvm-类信息"><br>由上图可知：dump文件记录的堆中的实例总大小约19M，指定的堆的固定大小为20M。</p><blockquote><p>用第一行的实例大小除以百分比就能算出来：<br>堆中实例大小：12965216B/1024/1024=12.36M，占了总大小的65%。<br>堆中实例总大小：12.36M/0.65=19.02M</p></blockquote><p>说明：dump文件中的实例列表其实是<strong>反映了使用的堆的情况</strong>，而使用的堆内存并没有达到预先设置的最大堆内存，只是在申请堆内存的过程中超出了预先设置的最大堆内存，然后内存溢出。</p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p><code>方法区</code>与Java堆一样，属于<code>线程共享区</code>，它用于<strong>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样<strong>不需要连续的内存</strong>和<strong>可以选择固定大小</strong>或者<strong>可扩展</strong>外，甚至<strong>还可以选择不实现垃圾收集</strong>。</p><blockquote><p>注意：</p><ul><li><code>关于方法区和永久代（元空间）</code>：<br>在JDK8以前，很多人把方法区称呼为<code>永久代（Permanent Generation</code>，或将两者混为一谈。<br>本质上这两者并不是等价的，<strong>仅因为HotSpot使用永久代来实现方法区而已</strong>，使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。<br>到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；<br>而到了JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的<code>元空间(Metaspace)</code>来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</li></ul></blockquote><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><h6 id="JDK8之前：老年代（Permanent-Gennration）"><a href="#JDK8之前：老年代（Permanent-Gennration）" class="headerlink" title="JDK8之前：老年代（Permanent Gennration）"></a>JDK8之前：老年代（Permanent Gennration）</h6><ul><li>如：<code>-XX:PermSize=10M</code> 指定老年代的初始空间大小（10M），以字节为单位。</li><li>如：<code>-XX:MaxPermSize=10M</code> 设置老年代最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</li></ul><h6 id="JDK8始：元空间（Metaspace）"><a href="#JDK8始：元空间（Metaspace）" class="headerlink" title="JDK8始：元空间（Metaspace）"></a><code>JDK8始：元空间（Metaspace）</code></h6><p><strong>Metaspace使用的是本地内存，而不是堆内存</strong>，也就是说在<code>默认情况下Metaspace的大小只与本地内存大小有关</code>。</p><ul><li><code>-XX:MetaspaceSize</code>：指定<strong>元空间的初始空间大小</strong>，以字节为单位。</li></ul><p><strong>达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</strong>：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下，适当提高该值。</p><blockquote><p>该值越大触发Metaspace GC的时机就越晚。<br>随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加上限也可能降低。<br>在默认情况下，这个值大小根据不同的平台在12M到20M浮动。<br>使用<code>java -XX:+PrintFlagsInitial</code>命令查看本机的初始化参数，-XX:Metaspacesize为21810376B（大约20.8M） 。</p></blockquote><ul><li><p><code>-XX:MaxMetaspaceSize</code>：设置<strong>元空间最大值</strong>，默认是-1，即不限制，或者说只受限于本地内存大小。</p><blockquote><p>防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。<br>在本机上该参数的默认值为4294967295B（大约4096MB）。</p></blockquote></li><li><p><code>-XX:MinMetaspaceFreeRatio</code>：作用是在Metaspace GC收集之后，控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</p><blockquote><p>当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比。<br>如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。<br>在本机该参数的默认值为40，也就是40%。<br>设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。</p></blockquote></li><li><p><code>-XX:MaxMetaspaceFreeRatio</code>：用于控制大的元空间剩余容量的百分比。</p><blockquote><p>当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。在本机该参数的默认值为70，也就是70%。</p></blockquote></li><li><p><code>-XX:MaxMetaspaceExpansion</code>： Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。</p></li><li><p><code>-XX:MinMetaspaceExpansion</code>： Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。</p></li></ul><h5 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h5><p><strong>运行时常量池是方法区的一部分</strong>。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<code>常量池表(Constant Pool Table)</code>，用于<strong>存放编译期生成的各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，在运行期间也可以将新的常量放入池中，如使用<code>String类的intern()方法</code>。</p><h5 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h5><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8中完全<strong>使用<code>元空间</code>来代替永久代</strong>。</p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法区的OOM异常：</span></span><br><span class="line"><span class="comment"> * - JDK8之前：指定老年代（方法区的大小固定为10M，不能进行自动扩展）</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - JDK8：完全废除了老年代，用元空间代替。</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 18:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 借助CGLib使得方法区出现内存溢出异常：</span></span><br><span class="line"><span class="comment">     * 方法区的主要职责是用于存放类型的相关信息：如类名、访问修饰符、常量池、字段描述、方法描述等。</span></span><br><span class="line"><span class="comment">     * 对于这部分区域的测试，基本的思路是：运行时产生大量的类去填满方法区，直到溢出为止。</span></span><br><span class="line"><span class="comment">     * 所以：可以借助CGLib直接操作字节码，运行时生成了大量的动态类。</span></span><br><span class="line"><span class="comment">     * 注意：</span></span><br><span class="line"><span class="comment">     * 当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到 CGLib这类字节码技术，</span></span><br><span class="line"><span class="comment">     * 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class="line">at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117)</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class="line">at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)</span><br><span class="line">at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)</span><br><span class="line">at com.bubble.jvm.error.JavaMethodAreaOOM.main(JavaMethodAreaOOM.java:39)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459)</span><br><span class="line">at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:339)</span><br><span class="line">... 6 more</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">... 11 more</span><br></pre></td></tr></table></figure><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法区（运行时常量池）的OOM异常，（方法区在JDK8后开始废除，之前也被称为永久代）</span></span><br><span class="line"><span class="comment"> * - 在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，</span></span><br><span class="line"><span class="comment"> * 我们可以通过-XX:PermSize和-XX:M axPermSize限制永久代的大小，即可间接限制其中常量池的容量。</span></span><br><span class="line"><span class="comment"> * 如：VM Args:-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 17:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK6来运行代码，抛出异常：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError: PermGen space</span></span><br><span class="line"><span class="comment">     * at java.lang.String.intern(Native Method)</span></span><br><span class="line"><span class="comment">     * 说明运行时常量池是属于方法区(即JDK 6的HotSpot虚拟机中的永久代)的一部分。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：</span></span><br><span class="line"><span class="comment">     * 无论是在JDK7中继续使用-XX:MaxPermSize参数或者在JDK8及以上版本使用-XX:MaxMeta-spaceSize参数</span></span><br><span class="line"><span class="comment">     * 把方法区容量同样限制在6MB，也都不会重现JDK6中的溢出异常，循环将一直进行下去，永不停歇。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为自JDK7起，原本存放在永久代的字符串常量池被移至Java堆之中，</span></span><br><span class="line"><span class="comment">     * 所以在JDK7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 但使用-Xmx参数限制最大堆到6MB就能够看到下面两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</span></span><br><span class="line"><span class="comment">     * - OOM异常一：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">     * at java.base/java.lang.Integer.toString(Integer.java:440)</span></span><br><span class="line"><span class="comment">     * at java.base/java.lang.String.valueOf(String.java:3058)</span></span><br><span class="line"><span class="comment">     * - OOM异常二：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashMap.resize(HashMap.java:699)</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashMap.putVal(HashMap.java:658)</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashMap.put(HashMap.java:607)</span></span><br><span class="line"><span class="comment">     * at java.base/java.util.HashSet.add(HashSet.java:220)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runByJDK6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        runByJDK6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String::intern()方法"></a><code>String::intern()方法</code></h5><p><code>String::intern()</code>是一个Native方法，返回该对象在常量池中的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 在JDK 6中运行，会得到三个false；</span></span><br><span class="line"><span class="comment"> * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储，</span></span><br><span class="line"><span class="comment"> * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，</span></span><br><span class="line"><span class="comment"> * 所以必然不可能是同一个引用，结果将返回false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 而在JDK 7后中运行，会得到一个true、一个false和一个true；</span></span><br><span class="line"><span class="comment"> * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中，</span></span><br><span class="line"><span class="comment"> * 那只需要在常量池里记录一下首次出现的实例引用即可。</span></span><br><span class="line"><span class="comment"> * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。</span></span><br><span class="line"><span class="comment"> * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的)</span></span><br><span class="line"><span class="comment"> * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。</span></span><br><span class="line"><span class="comment"> * 而str3和str1一样，"JDKJVM"这个字符串则是首次出现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JVM"</span>).append(<span class="string">"调优"</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="comment">// java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参考：https://www.zhihu.com/question/51102308/answer/124441115</span></span><br><span class="line"><span class="comment">     * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化，</span></span><br><span class="line"><span class="comment">     * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化，</span></span><br><span class="line"><span class="comment">     * 此时被 sun.misc.Version.launcher 静态常量字段所引用的"java"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">    <span class="comment">// 而JDKJVM这个字符串则是首次出现</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> StringBuilder().append(<span class="string">"JDK"</span>).append(<span class="string">"JVM"</span>).toString();</span><br><span class="line">    System.out.println(str3.intern() == str3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。</span></span><br><span class="line"><span class="comment"> * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。</span></span><br><span class="line"><span class="comment"> * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的"JVM"。</span></span><br><span class="line"><span class="comment"> * - b：先将字符串"JVM"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的"JVM"，最后将b指向heap中创建的这个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也就是说，a和b存储的内容是一样的，都是"JVM"，但地址不一样：a中保存的是常量池中"JVM"的地址，b保存的是heap中那个对象的地址，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 双等于号"=="比较的是地址，equals()比较的是内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compareStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"JVM"</span>;</span><br><span class="line">    <span class="comment">// new一个对象</span></span><br><span class="line">    String b = <span class="keyword">new</span> String(<span class="string">"JVM"</span>);</span><br><span class="line">    <span class="comment">// == 比较地址是否相等</span></span><br><span class="line">    <span class="comment">// 都在运行时常量池中</span></span><br><span class="line">    System.out.println(<span class="string">"JVM"</span> == a); <span class="comment">// true</span></span><br><span class="line">    System.out.println(a.intern() == a); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。</span></span><br><span class="line">    System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">    System.out.println(a.intern() == b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(a.equals(b));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他（不受JVM-GC管理区域）"><a href="#其他（不受JVM-GC管理区域）" class="headerlink" title="其他（不受JVM GC管理区域）"></a>其他（不受JVM GC管理区域）</h2><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><h4 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>容量大小可通过<code>-XX:MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致。</p><h5 id="NIO-New-Input-Output-类"><a href="#NIO-New-Input-Output-类" class="headerlink" title="NIO(New Input/Output)类"></a>NIO(New Input/Output)类</h5><p>NIO引入了一种<code>基于通道(Channel)</code>与<code>缓冲区 (Buffer)</code>的I/O方式，它可以<strong>使用Native函数库直接分配堆外内存</strong>，然后<strong>通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用</strong>进行操作。<br>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h5 id="OOM异常-1"><a href="#OOM异常-1" class="headerlink" title="OOM异常"></a>OOM异常</h5><p>当各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存OOM异常：使用unsafe分配本机内存</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wugang</span></span><br><span class="line"><span class="comment"> * date: 2020-06-04 19:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配。</span></span><br><span class="line"><span class="comment">     * （Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用）</span></span><br><span class="line"><span class="comment">     * 因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，</span></span><br><span class="line"><span class="comment">     * 而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory ()。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 抛出异常：</span></span><br><span class="line"><span class="comment">     * Exception in thread "main" java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment">     * at sun.misc.Unsafe.allocateMemory(Native Method)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况。<br>如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory(典型的间接使用就是NIO)，那就可以考虑重点检查一下直接内存方面的原因了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者-消费者案例</title>
      <link href="/ckbarvw0y000fyayd2z9y58tz/"/>
      <url>/ckbarvw0y000fyayd2z9y58tz/</url>
      
        <content type="html"><![CDATA[<p>基于Java的生产者-消费者模式代码实现，可以此为Demo来用于具体的实际业务。</p><a id="more"></a><ul><li>生产者-消费者demo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.Instant;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 推荐服务：生产者-消费者模式</span><br><span class="line"> *</span><br><span class="line"> * @author bubble</span><br><span class="line"> * date: 2018-10-22 15:03</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Deprecated</span><br><span class="line">public class RecService &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(RecService.class);</span><br><span class="line">    &#x2F;&#x2F; 日志打印间隔</span><br><span class="line">    private static int DEFAULT_LOG_INTERVAL &#x3D; 1000 * 10;</span><br><span class="line">    &#x2F;&#x2F; 队列默认处理容量，为避免队列扩容造成额外性能损耗，默认不扩容，达到当前大小，进入等待，消费者处理一部分数据之后，生产者继续生产</span><br><span class="line">    private static int DEFAULT_QUEUE_DISPOSE_SIZE &#x3D; 1000 * 10;</span><br><span class="line">    &#x2F;&#x2F; 队列默认容量</span><br><span class="line">    private static int DEFAULT_QUEUE_SIZE &#x3D; DEFAULT_QUEUE_DISPOSE_SIZE + 200;</span><br><span class="line">    &#x2F;&#x2F; 每个队列满时默认休眠时间</span><br><span class="line">    private static int DEFAULT_SLEEP_TIME &#x3D; 1000;</span><br><span class="line">    &#x2F;&#x2F; 线程池默认消费者数量</span><br><span class="line">    private static int DEFAULT_CONSUMER_NUM &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F; 用户的phoneId队列</span><br><span class="line">    private LinkedBlockingQueue&lt;Long&gt; phoneIdQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(DEFAULT_QUEUE_SIZE);</span><br><span class="line">    private Long STOP_FLAG &#x3D; -1L;</span><br><span class="line">    private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap; &#x2F;&#x2F; 用户航班信息</span><br><span class="line"></span><br><span class="line">    private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; getFlightInfoMap() &#123;</span><br><span class="line">        return flightInfoMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setFlightInfoMap(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap) &#123;</span><br><span class="line">        this.flightInfoMap &#x3D; flightInfoMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RecJobBean recJob;</span><br><span class="line">    private TipRecService tipRecService;</span><br><span class="line">    private CarRecService carRecService;</span><br><span class="line">    private HotelRecService hotelRecService;</span><br><span class="line"></span><br><span class="line">    public RecService(RecJobBean recJob) &#123;</span><br><span class="line">        this.recJob &#x3D; recJob;</span><br><span class="line">        switch (recJob) &#123;</span><br><span class="line">            case TIP:</span><br><span class="line">                tipRecService &#x3D; Optional.ofNullable(tipRecService).orElse(new TipRecService());</span><br><span class="line">                break;</span><br><span class="line">            case CAR:</span><br><span class="line">                carRecService &#x3D; Optional.ofNullable(carRecService).orElse(new CarRecService());</span><br><span class="line">                break;</span><br><span class="line">            case HOTEL:</span><br><span class="line">                hotelRecService &#x3D; Optional.ofNullable(hotelRecService).orElse(new HotelRecService());</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType());</span><br><span class="line">                System.exit(0);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void rec(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; userFlightMap, int top) &#123;</span><br><span class="line">        LOGGER.info(&quot;start &#123;&#125; rec job.&quot;, recJob.getType());</span><br><span class="line">        if (userFlightMap &#x3D;&#x3D; null || userFlightMap.isEmpty()) &#123;</span><br><span class="line">            LOGGER.error(&quot;user flight is empty, rec job for &#123;&#125; exit.&quot;, recJob.getType());</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        setFlightInfoMap(userFlightMap);</span><br><span class="line">        UserProducer userProducer &#x3D; new UserProducer();</span><br><span class="line">        userProducer.setName(&quot;producer&quot;);</span><br><span class="line">        userProducer.start();</span><br><span class="line">        UserConsumer userConsumer &#x3D; new UserConsumer(recJob, top);</span><br><span class="line">        ThreadPoolExecutor poolExecutor &#x3D; userConsumer.consumerAndRec();</span><br><span class="line">        threadMonitor(poolExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 监控ThreadPoolExecutor线程池，无活动线程就关闭线程池连接；</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void threadMonitor(ThreadPoolExecutor executor) &#123;</span><br><span class="line">        Runnable runnable &#x3D; () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                while (executor.getActiveCount() &gt; 0) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125;</span><br><span class="line">                executor.shutdown();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(&quot;thread monitor error.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生产者: 可用phoneId集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class UserProducer extends Thread &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            addUser();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 给每个线程都在队列（FIFO）末尾添加标识</span><br><span class="line">                phoneIdQueue.put(STOP_FLAG);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(&quot;save phoneId error.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(&quot;[&#123;&#125;] thread altogether produces &#123;&#125; data&quot;, this.getName(), i);</span><br><span class="line">            LOGGER.info(&quot;[&#123;&#125;] thread produces done.&quot;, this.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void addUser() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int step &#x3D; 0;</span><br><span class="line">                LOGGER.info(&quot;add &#123;&#125; user in producer queue.&quot;, getFlightInfoMap().size());</span><br><span class="line">                Iterator iter &#x3D; getFlightInfoMap().entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while (iter.hasNext()) &#123;</span><br><span class="line">                    Map.Entry entry &#x3D; (Map.Entry) iter.next();</span><br><span class="line">                    long uid &#x3D; (long) entry.getKey();</span><br><span class="line">                    phoneIdQueue.put(uid);</span><br><span class="line">                    step++;</span><br><span class="line">                    while (phoneIdQueue.size() &gt; DEFAULT_QUEUE_DISPOSE_SIZE) &#123;</span><br><span class="line">                        Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123;</span><br><span class="line">                        i +&#x3D; step;</span><br><span class="line">                        step &#x3D; 0;</span><br><span class="line">                        LOGGER.info(&quot;[&#123;&#125;] thread has produced &#123;&#125; pieces of data&quot;, this.getName(), i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i +&#x3D; step;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                LOGGER.error(&quot;save phoneId error.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消费者：取phoneId并进行推荐</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class UserConsumer &#123;</span><br><span class="line">        private int top;</span><br><span class="line">        private RecJobBean recJob;</span><br><span class="line"></span><br><span class="line">        public UserConsumer(RecJobBean recJob, int top) &#123;</span><br><span class="line">            this.recJob &#x3D; recJob;</span><br><span class="line">            this.top &#x3D; top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ThreadPoolExecutor consumerAndRec() &#123;</span><br><span class="line">            ThreadPoolExecutor poolExecutor &#x3D; new ThreadPoolExecutor(DEFAULT_CONSUMER_NUM,</span><br><span class="line">                    DEFAULT_CONSUMER_NUM &lt;&lt; 1,</span><br><span class="line">                    60 * 60 * 4,</span><br><span class="line">                    TimeUnit.SECONDS,</span><br><span class="line">                    new ArrayBlockingQueue&lt;&gt;(50),</span><br><span class="line">                    new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">            LOGGER.info(&quot;Consumer start.&quot;);</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; DEFAULT_CONSUMER_NUM; i++) &#123;</span><br><span class="line">                Thread t &#x3D; new Thread() &#123;</span><br><span class="line">                    int step &#x3D; 0;</span><br><span class="line">                    int consumerNum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        while (!this.isInterrupted()) &#123;</span><br><span class="line">                            Long phoneId;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                phoneId &#x3D; phoneIdQueue.take();</span><br><span class="line">                                if (phoneId.equals(STOP_FLAG)) &#123;</span><br><span class="line">                                    &#x2F;&#x2F; 该线程取到-1，说明产品队列中已无产品，可以结束线程，但是可能还有其他线程存活，需要通知其他线程已无数据</span><br><span class="line">                                    &#x2F;&#x2F; 因此，插入-1，同时跳出循环，线程归还线程池，等待监控线程发现其处于非活动状态，将其销毁，最终销毁线程池</span><br><span class="line">                                    phoneIdQueue.put(STOP_FLAG);</span><br><span class="line">                                    LOGGER.info(&quot;[&#123;&#125;] thread consumes done.&quot;, this.getName());</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                recOneUser(recJob, phoneId, top);</span><br><span class="line"></span><br><span class="line">                                consumerNum++;</span><br><span class="line">                                step++;</span><br><span class="line">                                if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123;</span><br><span class="line">                                    step &#x3D; 0;</span><br><span class="line">                                    LOGGER.info(&quot;[&#123;&#125;] thread has consumed &#123;&#125; pieces of data&quot;, this.getName(), consumerNum);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                LOGGER.error(&quot;read data from phoneIdQueue error.&quot;, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOGGER.info(&quot;[&#123;&#125;] thread altogether consumes &#123;&#125; user data&quot;, this.getName(), consumerNum);</span><br><span class="line">                        LOGGER.info(&quot;RecConsumer end.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                t.setName(&quot;RecConsumer-&quot; + i);</span><br><span class="line">                poolExecutor.execute(t);</span><br><span class="line">            &#125;</span><br><span class="line">            return poolExecutor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void recOneUser(RecJobBean recJob, long uid, int top) &#123;</span><br><span class="line">        Instant begin &#x3D; Instant.now();</span><br><span class="line">        List&lt;FlightInfoBean&gt; userFlightInfoList &#x3D; getFlightInfoMap().get(uid);</span><br><span class="line">        if (userFlightInfoList !&#x3D; null &amp;&amp; !userFlightInfoList.isEmpty()) &#123;</span><br><span class="line">            List&lt;TipsUserLinkBean&gt; recItems &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            switch (recJob) &#123;</span><br><span class="line">                case TIP:</span><br><span class="line">                    recItems &#x3D; tipRecService.rec(uid, userFlightInfoList, top);</span><br><span class="line">                    break;</span><br><span class="line">                case CAR:</span><br><span class="line">                    recItems &#x3D; carRecService.rec(uid, userFlightInfoList);</span><br><span class="line">                    break;</span><br><span class="line">                case HOTEL:</span><br><span class="line">                    recItems &#x3D; hotelRecService.rec(uid, userFlightInfoList, top);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(begin, Instant.now()).toMillis());</span><br><span class="line">            Instant saveStart &#x3D; Instant.now();</span><br><span class="line">            try &#123;</span><br><span class="line">                DataService.saveTipsUserLink(recItems, recJob);</span><br><span class="line">            &#125; catch (java.lang.NullPointerException np) &#123;</span><br><span class="line">                LOGGER.error(&quot;user [&#123;&#125;] saveTipsUserLink error.&quot;, uid, np);</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, save costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(saveStart, Instant.now()).toMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bubble Sort</title>
      <link href="/ckbarvw1m001ryayd2tq6599d/"/>
      <url>/ckbarvw1m001ryayd2tq6599d/</url>
      
        <content type="html"><![CDATA[<p>经典面试题---进阶版冒泡排序</p><a id="more"></a><h2 id="常规版"><a href="#常规版" class="headerlink" title="常规版"></a>常规版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""常规版"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(data)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>]:</span><br><span class="line">                data[j], data[j + <span class="number">1</span>] = data[j + <span class="number">1</span>], data[j]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">    print(data)</span><br><span class="line">    print(foo(data))</span><br></pre></td></tr></table></figure><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    进阶版</span></span><br><span class="line"><span class="string">    最坏情况 时间复杂度 O(n**2)</span></span><br><span class="line"><span class="string">    最好情况 时间复杂度 O(n)</span></span><br><span class="line"><span class="string">    稳定排序法</span></span><br><span class="line"><span class="string">    空间复杂度最佳 只需要一个额外空间</span></span><br><span class="line"><span class="string">    适用于数据量小或有部分数据已经排过序的情况</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># i 倒序循环列表排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># flag判断是否执行了交换操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):  <span class="comment"># i 为倒序循环，所以j的最大值即是i 0～i</span></span><br><span class="line">            <span class="keyword">if</span> data[j] &gt; data[j + <span class="number">1</span>]:</span><br><span class="line">                data[j], data[j + <span class="number">1</span>] = data[j + <span class="number">1</span>], data[j]</span><br><span class="line">                flag = <span class="literal">True</span>  <span class="comment"># 执行过交换操作，把flag置为True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:  <span class="comment"># 执行完一次扫描后，判断是否执行过交换操作，如果没有交换过数据，就表示此时数组已完成排序，故直接跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'第&#123;0&#125;次排序: &#123;1&#125;'</span>.format(len(data)-i, data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">    print(data)</span><br><span class="line">    print(bubble_sort(data))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
