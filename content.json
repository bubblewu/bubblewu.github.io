{"meta":{"title":"大泡泡的笔记","subtitle":"记录平时工作过程中的学习点滴","description":"Java、Python、机器学习、深度学习、推荐系统、自然语言处理","author":"Bubble","url":"https://bubblewu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-06-08T06:59:37.716Z","updated":"2020-06-08T03:32:03.119Z","comments":true,"path":"404.html","permalink":"https://bubblewu.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 向博主反馈问题"},{"title":"个人简介","date":"2020-06-08T09:17:17.877Z","updated":"2020-06-08T09:17:17.868Z","comments":true,"path":"about/index.html","permalink":"https://bubblewu.github.io/about/index.html","excerpt":"记录工作过程中的点滴！","text":"记录工作过程中的点滴！ 本Blog主要用来记录工作过程中的点滴！ 联系博主"},{"title":"我的朋友们","date":"2020-06-08T06:59:37.720Z","updated":"2020-06-08T03:32:03.130Z","comments":false,"path":"friends/index.html","permalink":"https://bubblewu.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"Android SDK","date":"2020-06-08T09:11:17.985Z","updated":"2020-06-08T03:32:03.128Z","comments":true,"path":"adb/index.html","permalink":"https://bubblewu.github.io/adb/index.html","excerpt":"","text":"Android SDK SDK:(software development kit) &nbsp;&nbsp;&nbsp;&nbsp;被软件开发工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。因此，Android SDK 指的是Android专属的软件开发工具包。 Start Learning"},{"title":"","date":"2020-06-08T06:59:37.715Z","updated":"2020-06-08T03:32:03.130Z","comments":true,"path":"list/index.html","permalink":"https://bubblewu.github.io/list/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-08T06:59:37.709Z","updated":"2020-06-08T03:32:03.131Z","comments":true,"path":"tags/index.html","permalink":"https://bubblewu.github.io/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-05-20T15:25:38.000Z","updated":"2020-06-08T03:32:03.131Z","comments":true,"path":"msgboard/index.html","permalink":"https://bubblewu.github.io/msgboard/index.html","excerpt":"","text":""},{"title":"Contributors「鸣谢」","date":"2020-06-09T02:16:51.775Z","updated":"2020-06-08T03:32:03.130Z","comments":true,"path":"contributors/index.html","permalink":"https://bubblewu.github.io/contributors/index.html","excerpt":"","text":"特别鸣谢 hexo 开发者和 volantis 开发者！ Hexo volantis"},{"title":"所有分类","date":"2020-06-09T02:28:09.039Z","updated":"2020-06-08T03:32:03.130Z","comments":true,"path":"categories/index.html","permalink":"https://bubblewu.github.io/categories/index.html","excerpt":"","text":""},{"title":"2. 连接调试","date":"2020-05-17T08:02:45.000Z","updated":"2020-06-08T03:32:03.128Z","comments":true,"path":"adb/debug/index.html","permalink":"https://bubblewu.github.io/adb/debug/index.html","excerpt":"","text":"win12345678910# 什么进程占用了 5037netstat -ano | findstr \"5037\"# 结果显示进程PID 21152（示例）# 查看进程是哪个程序启动的这个进程（21152为进程PID）tasklist | findstr \"21152\"#结果显示 某个服务# 杀进程taskkill /f /pid 21152 mac1234567891011# 什么进程占用了 5037netstat -an|grep 5037# 查看进程是哪个程序启动的这个进程（21152为进程PID）lsof -i :5037# 杀进程(PID为53067的进程)kill -9 53067# psps -ef | grep 5037"},{"title":"4. 玩转pm命令","date":"2020-05-17T13:05:23.000Z","updated":"2020-06-08T03:32:03.129Z","comments":true,"path":"adb/pm/index.html","permalink":"https://bubblewu.github.io/adb/pm/index.html","excerpt":"","text":"获取设备app包名称列表1adb shell pm list package # 列出安装在设备上应用的包名 获取设备app包名称列表, 只显示系统应用1adb shell pm list package -s # 列出安装在设备上应用的包名 获取设备app包名称列表, 只显示三方应用1adb shell pm list package -3 # 列出安装在设备上应用的包名 列出应用包名及对应的apk名及存放位置1adb shell pm list package -f # 列出安装在设备上应用的包名 列出应用包名及其安装来源1adb shell pm list package -i 查看APP详细信息1adb shell pm dump &lt;package_name&gt; # 例如：com.jd.xxxx 安装apk1adb shell pm install &lt;apk_path&gt; # 目标 apk 存放于 Android 设备上(，请用 pm install 安装) 卸载apk1adb shell pm uninstall &lt;package_name&gt; 清除APP数据和缓存1adb shell pm clear &lt;package_name&gt; 重置所有APP权限1adb shell pm reset 查看帮助文档1adb shell pm"},{"title":"3. apk安装&卸载","date":"2020-05-17T12:35:53.000Z","updated":"2020-06-08T03:32:03.129Z","comments":true,"path":"adb/installapk/index.html","permalink":"https://bubblewu.github.io/adb/installapk/index.html","excerpt":"","text":"安装(adb install)1234567891011121314# 普通安装adb install &lt;apk_path&gt;# 覆盖安装adb install -r &lt;apk_path&gt;# 安装debug包adb install -t &lt;apk_path&gt;# 降级安装adb install -d &lt;apk_path&gt; # 只针对debug包，对release包无效# 针对特定设备安装(多设备同时连接电脑时)adb -s &lt;devices_id&gt; install &lt;apk_path&gt; 卸载(adb uninstall)12345# 普通卸载adb uninstall &lt;package_name&gt; # 例如: com.jd.xxx# 针对特定设备卸载(多设备同时连接电脑时)adb -s &lt;devices_id&gt; uninstall &lt;package_name&gt; # 例如: com.jd.xxx 自动化下的安装卸载(pm命令)12345# 安装apkpm install &lt;device_apk_path&gt; # device_apk_path为手机路径 /sdcard# 卸载apkpm install &lt;package_name&gt; # 例如: com.jd.xxx pm 更多用法"},{"title":"1. SDK下载安装","date":"2020-05-17T06:59:42.000Z","updated":"2020-06-08T03:32:03.129Z","comments":true,"path":"adb/sdk/index.html","permalink":"https://bubblewu.github.io/adb/sdk/index.html","excerpt":"","text":"下载Android SDK下载地址：https://www.androiddevtools.cn官方地址：http://developer.android.com/sdk点击Android SDK工具，选择SDK，按不同系统下载对应版本 安装Android SDK打开Android SDK文件夹，点击SDK Manager，只勾选platform-tools、build-tools、tools三个工具安装即可 环境变量配置1234567# win 编辑环境变量ANDROID_HOME=&lt;android-sdk的path目录路径&gt; # 新增ANDROID_HOMEPATH=$ANDROID_HOME/bin;$ANDROID_HOME/platform-tools;$ANDROID_HOME/build-tools;$ANDROID_HOME/tools# mac 修改.bashrc或.zshrc(zsh使用者)export ANDROID_HOME=&lt;android-sdk的path目录路径&gt;export CLASSPATH=.:$ANDROID_HOME/bin;$ANDROID_HOME/platform-tools;$ANDROID_HOME/build-tools;$ANDROID_HOME/tools"}],"posts":[{"title":"002 虚拟机对象","slug":"Java/JVM/002 虚拟机对象","date":"2020-06-29T10:32:19.000Z","updated":"2020-06-29T10:32:36.692Z","comments":true,"path":"ckc0d6ptv0000qyydegky1iwy/","link":"","permalink":"https://bubblewu.github.io/ckc0d6ptv0000qyydegky1iwy/","excerpt":"本文主要讲述HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。","text":"本文主要讲述HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。 虚拟机对象对象的创建对象的创建流程 使用new指令来创建对象； 首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化； 如果没有，说明是新建，就先执行相应的类加载的过程； 类加载检查通过后，为虚拟机新生对象分配堆内存； 堆内存分配成功后，再把分配到的内存空间（不包括对象头）都初始化为零值； 再执行类文件的()方法，按照Dev的设定来进行构造，把对象进行初始化，得到一个真正的对象。 对象的内存布局在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header)、实例 数据(Instance Data)和对齐填充(Padding)。 对象头（Header）对象头包括两类信息：一是用于存储对象自身的运行时数据；二是类型指针。 1、存储对象自身的运行时数据如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它为Mark Word。 Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。 2、类型指针对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数。因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。 实例数据（Instance Data）实例数据是对象真正存储等有效信息。也就是我们所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数(-XX:FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers，OOPs)，由上可知：相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的 +XX:CompactFields参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。 对齐填充（Padding）对齐填充不是必然存在的，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 对象的访问定位创建了对象就需要使用它，Java Dev会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种。 两种方式使用句柄访问对象如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 使用直接指针访问对象如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。 对比 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。","categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://bubblewu.github.io/categories/Java/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://bubblewu.github.io/tags/JVM/"}]},{"title":"String类的intern()方法","slug":"Java/String类的intern()方法","date":"2020-06-14T07:52:19.000Z","updated":"2020-06-14T08:15:44.917Z","comments":true,"path":"ckbesij6t000029s67j9p5x9z/","link":"","permalink":"https://bubblewu.github.io/ckbesij6t000029s67j9p5x9z/","excerpt":"概述String::intern()是一个Native方法，用于返回该对象在常量池中的引用。 1public native String intern(); 作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。","text":"概述String::intern()是一个Native方法，用于返回该对象在常量池中的引用。 1public native String intern(); 作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。 案例 示例1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * - 在JDK 6中运行，会得到三个false； * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储， * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上， * 所以必然不可能是同一个引用，结果将返回false。 * * - 而在JDK 7后中运行，会得到一个true、一个false和一个true； * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中， * 那只需要在常量池里记录一下首次出现的实例引用即可。 * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。 * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的) * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。 * 而str3和str1一样，\"JDKJVM\"这个字符串则是首次出现。 * */private static void compare() &#123; String str1 = new StringBuilder().append(\"JVM\").append(\"调优\").toString(); System.out.println(str1.intern() == str1); // java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。 /* * 参考：https://www.zhihu.com/question/51102308/answer/124441115 * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化， * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化， * 此时被 sun.misc.Version.launcher 静态常量字段所引用的\"java\"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。 */ String str2 = new StringBuilder().append(\"ja\").append(\"va\").toString(); System.out.println(str2.intern() == str2); // 而JDKJVM这个字符串则是首次出现 String str3 = new StringBuilder().append(\"JDK\").append(\"JVM\").toString(); System.out.println(str3.intern() == str3);&#125;/** * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。 * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。 * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的\"JVM\"。 * - b：先将字符串\"JVM\"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的\"JVM\"，最后将b指向heap中创建的这个对象。 * * 也就是说，a和b存储的内容是一样的，都是\"JVM\"，但地址不一样：a中保存的是常量池中\"JVM\"的地址，b保存的是heap中那个对象的地址， * * 双等于号\"==\"比较的是地址，equals()比较的是内容。 */private static void compareStr() &#123; String a = \"JVM\"; // new一个对象 String b = new String(\"JVM\"); // == 比较地址是否相等 // 都在运行时常量池中 System.out.println(\"JVM\" == a); // true System.out.println(a.intern() == a); // true // a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。 System.out.println(a == b); // false System.out.println(a.intern() == b); // false System.out.println(a.equals(b)); // true&#125; 示例2：123456789101112131415161718public static void main(String[] args) &#123; /* 双等号\"==\"比较的是地址；equals()比较的是内容。 */ String s1 = \"abc\"; String s2 = \"abc\"; System.out.println(s1 == s2); // true System.out.println(s1.equals(s2)); // true String s3 = new String(\"abc\"); System.out.println(s1 == s3); // false System.out.println(s1.equals(s3)); // true System.out.println(s1 == s3.intern()); // true String s4 = new String(\"abc\"); System.out.println(s3 == s4); // false System.out.println(s3.intern() == s4.intern()); // true &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"}]},{"title":"基于Neo4j的时光网电影数据可视化【附源码】","slug":"Neo4j/基于Neo4j的时光网电影数据可视化【附源码】","date":"2020-06-11T12:32:19.000Z","updated":"2020-06-11T12:51:42.655Z","comments":true,"path":"ckbarwdyc0000z5yd8tl0cjqn/","link":"","permalink":"https://bubblewu.github.io/ckbarwdyc0000z5yd8tl0cjqn/","excerpt":"基于Neo4j的电影数据可视化本文主要内容为： 基于requests + BeautifulSoup抓取时光网电影数据； 基于电影数据构建电影和关系实体信息； 数据导入neo4j进行存储分析； 基于Bottle框架的对neo4j数据进行查询可视化展示。 效果展示：","text":"基于Neo4j的电影数据可视化本文主要内容为： 基于requests + BeautifulSoup抓取时光网电影数据； 基于电影数据构建电影和关系实体信息； 数据导入neo4j进行存储分析； 基于Bottle框架的对neo4j数据进行查询可视化展示。 效果展示： 环境配置新建虚拟环境并安装所需包 新建虚拟环境：12345678# 查看本机已经安装的python虚拟环境conda env list# 新建graph-37环境conda create -n graph-37 python&#x3D;3.7# 生效新建的虚拟环境conda activate graph-37## 退出#conda deactivate 安装所需包：根据requirements.txt文件来安装：1pip install -r requirements.txt requirements.txt文件：12345678910111213141516171819202122232425beautifulsoup4&#x3D;&#x3D;4.9.1bs4&#x3D;&#x3D;0.0.1certifi&#x3D;&#x3D;2020.4.5.1chardet&#x3D;&#x3D;3.0.4Click&#x3D;&#x3D;7.0colorama&#x3D;&#x3D;0.4.3et-xmlfile&#x3D;&#x3D;1.0.1idna&#x3D;&#x3D;2.9jdcal&#x3D;&#x3D;1.4.1lxml&#x3D;&#x3D;4.5.1neobolt&#x3D;&#x3D;1.7.17neotime&#x3D;&#x3D;1.7.4numpy&#x3D;&#x3D;1.18.5openpyxl&#x3D;&#x3D;3.0.3pandas&#x3D;&#x3D;1.0.4prompt-toolkit&#x3D;&#x3D;2.0.10py2neo&#x3D;&#x3D;4.3.0Pygments&#x3D;&#x3D;2.3.1python-dateutil&#x3D;&#x3D;2.8.1pytz&#x3D;&#x3D;2020.1requests&#x3D;&#x3D;2.23.0six&#x3D;&#x3D;1.15.0soupsieve&#x3D;&#x3D;2.0.1urllib3&#x3D;&#x3D;1.24.3wcwidth&#x3D;&#x3D;0.2.4 数据获取本文数据来自时光网电影Top100。基于python对该源进行数据抓取，并将数据生成相应的实体和关系：可参考：GitHub：时光网数据抓取处理 实体和关系如下：： 电影： 1234index:ID,rank,src,name,movie_en,year,image,:LABEL10000,1,http:&#x2F;&#x2F;movie.mtime.com&#x2F;12231&#x2F;,肖申克的救赎,The Shawshank Redemption,1994,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;03&#x2F;07&#x2F;123549.37376649_96X128.jpg,电影表10001,2,http:&#x2F;&#x2F;movie.mtime.com&#x2F;99547&#x2F;,盗梦空间,Inception,2010,http:&#x2F;&#x2F;img31.mtime.cn&#x2F;mt&#x2F;2014&#x2F;01&#x2F;06&#x2F;105446.89493583_96X128.jpg,电影表... 演员： 123456index:ID,actor,:LABEL30000,杰伊·巴鲁切尔,演员表30001,维果·莫腾森,演员表30002,布拉德·皮特,演员表30003,李·科布,演员表... 导演： 123456index:ID,director,:LABEL20000,彼得·索恩,导演表20001,克里斯托弗·诺兰,导演表20002,朴赞郁,导演表20003,赛尔乔·莱昂内,导演表... 关系： 电影与导演关系： 12345:START_ID,:END_ID,relation,:TYPE20069,10000,导演,导演20001,10001,导演,导演20010,10002,导演,导演... 电影与主演关系： 123456:START_ID,:END_ID,relation,:TYPE30156,10000,主演,主演30026,10000,主演,主演30063,10001,主演,主演30031,10001,主演,主演... 导演和演员关系： 12345:START_ID,:END_ID,relation,:TYPE20069,30156,相关,相关20069,30026,相关,相关20001,30063,相关,相关... Neo4j存储数据导入必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。 通过下面的命令导入定义好的实体和关系数据： 123456789101112131415161718192021222324252627282930313233#!&#x2F;bin&#x2F;sh# 脚本来执行将csv文件（节点和关系）导入neo4j# 注意：必须停止neo4j；只能生成新的数据库，而不能在已存在的数据库中插入数据。db_name&#x3D;MovieMTime.dbneo4j_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4base_path&#x3D;&#x2F;Users&#x2F;wugang&#x2F;code&#x2F;python&#x2F;moive-kg&#x2F;data&#x2F;mtimeimport() &#123; cd $&#123;neo4j_path&#125; .&#x2F;bin&#x2F;neo4j stop rm -rf &#x2F;Users&#x2F;wugang&#x2F;env&#x2F;neo4j-community-4.0.4&#x2F;data&#x2F;databases&#x2F;$&#123;db_name&#125; .&#x2F;bin&#x2F;neo4j-admin import --verbose \\ --database $&#123;db_name&#125; \\ --id-type STRING \\ --input-encoding&#x3D;UTF-8 \\ --ignore-extra-columns&#x3D;false \\ --trim-strings&#x3D;true \\ --delimiter&#x3D;, \\ --array-delimiter&#x3D;&#39;;&#39; \\ --processors&#x3D;4 \\ --nodes $&#123;base_path&#125;&#x2F;mtime_movie_entity.csv \\ --nodes $&#123;base_path&#125;&#x2F;mtime_actor_entity.csv \\ --nodes $&#123;base_path&#125;&#x2F;mtime_director_entity.csv \\ --relationships $&#123;base_path&#125;&#x2F;mtime_director_actor_relationship.csv \\ --relationships $&#123;base_path&#125;&#x2F;mtime_movie_actor_relationship.csv \\ --relationships $&#123;base_path&#125;&#x2F;mtime_movie_director_relationship.csv # 需要修改neo4j.conf配置文件中的默认db才能展示新建的db，否则还是默认的。（只能指定一个db）# .&#x2F;bin&#x2F;neo4j start# .&#x2F;bin&#x2F;neo4j stop&#125;import 数据查看修改配置将默认db改为刚才新建的电影的db，否则还是默认的库。vim conf/neo4j.conf 1dbms.active_database&#x3D;MovieMTime.db 启动neo4j服务（neo4j版本为4.0.3）: 1.&#x2F;bin&#x2F;neo4j start 进入管理界面：http://127.0.0.1:7474 查看实体数据： 查看关系数据： 数据查询可视化查询可视化基于Bottle框架的Web服务。参考：GitHub: 可视化 效果如下图： 源码地址 movie-neo4j","categories":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/categories/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/categories/Python/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/tags/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/tags/Python/"}]},{"title":"001 运行时数据区域和OutOfMemoryError异常","slug":"Java/JVM/001 运行时数据区域和OutOfMemoryError异常","date":"2020-06-09T02:52:19.000Z","updated":"2020-06-14T08:16:13.196Z","comments":true,"path":"ckbarvw2z0045yayd50uf5v6u/","link":"","permalink":"https://bubblewu.github.io/ckbarvw2z0045yayd50uf5v6u/","excerpt":"本文主要讲解JVM运行时数据区域，并通过简单的案例来实现说明各个区域中的常见OOM异常。","text":"本文主要讲解JVM运行时数据区域，并通过简单的案例来实现说明各个区域中的常见OOM异常。 运行时数据区域运行时数据区域图： Java内存区域：JVM内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法栈】、线程共享区域【Java堆、方法区】、直接内存。 线程私有区域：线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在Hotspot VM内,每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 线程共享区域：线程共享区域随虚拟机的启动/关闭而创建/销毁。 JVM主要区域溢出异常在Java虚拟机规范中规定，除了程序计数器外，虚拟机的其他几个运行时区域都有发生OOM异常的可能，如：方法区（运行时常量池）、Java堆、虚拟机栈（局部变量表）、本地方法栈和直接内存。 下面将通过案例来验证各个运行时区域的溢出异常，并分析我们来如何解决和避免这些异常。 注：下面的代码基于JDK8进行开发测试； 线程独占区程序计数器（无OOM）程序计数器（Program Counter Register）是一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为线程私有的内存。 正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。 如果是Native方法，则为空（undefined）。 这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError 情况的区域。 虚拟机栈和本地方法栈溢出虚拟机栈虚拟机栈描述的是Java方法执行的线程内存模型。 栈帧（Stack Frame）：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：局部变量表存放了编译期可知的： 各种Java虚拟机基本数据类型：boolean、byte、char、short、int、 float、long、double； 对象引用 ：reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置； returnAddress类型：指向了一条字节码指令的地址。 这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示。其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。 两种异常：栈/堆溢出 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 虚拟机栈&amp;本地方法栈Java虚拟机栈（Java Virtual Machine Stack）和本地方法栈（Native Method Stacks）非常相似，都属于线程独占区，区别是： 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务； 本地方法栈为虚拟机使用到的本地方法（Native方法）服务； Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 虚拟机栈和本地方法栈溢出案例栈容量参数：-XssHotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。 栈/堆溢出的场景《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展。所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。 测试案例将实验范围限制在单线程中操作，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常： 使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 定义大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 单线程下：使用-Xss参数减少栈内存容量（SOF异常）12345678910111213141516171819202122232425262728/** * Java虚拟机栈和本地方法机栈异常（单线程操作下） * VM Args: -Xss160k（Mac 64Bit要求最低栈内存为160K） * 使用-Xss参数减少栈内存容量。 * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 * * @author wugang * date: 2020-06-04 15:23 **/public class VMStackSOF &#123; private int stackLength = 1; private void stackLeak() &#123; stackLength++; stackLeak(); &#125; public static void main(String[] args) &#123; VMStackSOF stackSOF = new VMStackSOF(); try &#123; stackSOF.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println(\"stack length: \" + stackSOF.stackLength); throw e; &#125; &#125;&#125; 输出： 1234stack length: 773Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.bubble.jvm.error.VMStackSOF.stackLeak(VMStackSOF.java:16)... 单线程下：定义大量的本地变量，增大此方法帧中本地变量表的长度（SOF异常）1234567891011121314151617181920212223242526272829303132333435363738/** * Java虚拟机栈和本地方法机栈异常（单线程操作下） * 定义大量的本地变量，增大此方法帧中本地变量表的长度 * 结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 * * @author wugang * date: 2020-06-04 15:23 **/public class VMStackSOF02 &#123; private static int stackLength = 1; public static void test() &#123; long unused1, unused2, unused3, unused4, unused5, unused6, unused7, unused8, unused9, unused10, unused11, unused12, unused13, unused14, unused15, unused16, unused17, unused18, unused19, unused20, unused21, unused22, unused23, unused24, unused25, unused26, unused27, unused28, unused29, unused30, unused31, unused32, unused33, unused34, unused35, unused36, unused37, unused38, unused39, unused40, unused41, unused42, unused43, unused44, unused45, unused46, unused47, unused48, unused49, unused50, unused51, unused52, unused53, unused54, unused55, unused56, unused57, unused58, unused59, unused60, unused61, unused62, unused63, unused64, unused65, unused66, unused67, unused68, unused69, unused70, unused71, unused72, unused73, unused74, unused75, unused76, unused77, unused78, unused79, unused80, unused81, unused82, unused83, unused84, unused85, unused86, unused87, unused88, unused89, unused90, unused91, unused92, unused93, unused94, unused95, unused96, unused97, unused98, unused99, unused100; stackLength++; test(); unused1 = unused2 = unused3 = unused4 = unused5 = unused6 = unused7 = unused8 = unused9 = unused10 = unused11 = unused12 = unused13 = unused14 = unused15 = unused16 = unused17 = unused18 = unused19 = unused20 = unused21 = unused22 = unused23 = unused24 = unused25 = unused26 = unused27 = unused28 = unused29 = unused30 = unused31 = unused32 = unused33 = unused34 = unused35 = unused36 = unused37 = unused38 = unused39 = unused40 = unused41 = unused42 = unused43 = unused44 = unused45 = unused46 = unused47 = unused48 = unused49 = unused50 = unused51 = unused52 = unused53 = unused54 = unused55 = unused56 = unused57 = unused58 = unused59 = unused60 = unused61 = unused62 = unused63 = unused64 = unused65 = unused66 = unused67 = unused68 = unused69 = unused70 = unused71 = unused72 = unused73 = unused74 = unused75 = unused76 = unused77 = unused78 = unused79 = unused80 = unused81 = unused82 = unused83 = unused84 = unused85 = unused86 = unused87 = unused88 = unused89 = unused90 = unused91 = unused92 = unused93 = unused94 = unused95 = unused96 = unused97 = unused98 = unused99 = unused100 = 0; &#125; public static void main(String[] args) &#123; try &#123; test(); &#125; catch (Throwable e) &#123; System.out.println(\"stack length: \" + stackLength); throw e; &#125; &#125;&#125; 输出： 1234stack length: 8121Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.bubble.jvm.error.VMStackSOF02.test(VMStackSOF02.java:26)... 多线程下：OOM异常12345678910111213141516171819202122232425262728/** * 多线程下，Java虚拟机栈和本地方法栈OOM异常 * VM Args:-Xss2M * * @author wugang * date: 2020-06-04 16:38 **/public class VMStackOOM &#123; private void dontStop() &#123; while (true) &#123; &#125; &#125; public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(() -&gt; dontStop()); thread.start(); &#125; &#125; public static void main(String[] args) &#123; VMStackOOM vmStackOOM = new VMStackOOM(); vmStackOOM.stackLeakByThread(); &#125;&#125; 输出： 1Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create native thread 结论实验结果表明： 单线程下： 无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。如果在允许动态扩展栈容量大小的虚拟机上，相同代码则会导致不一样的情况，如第二个代码（定义大量的本地变量，增大此方法帧中本地变量表的长度）示例就会抛出OutOfMemoryError异常。 多线程下：如果通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的，如第三个代码。但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态。甚至可以说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 因为：操作系统分配给每个进程的内存是有限制的。如32位Windows的单个进程最大内存限制为2GB。HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，那剩余的内存（由虚拟机栈和本地方法栈来分配的内存）为2GB(操作系统限制)减去最大堆容量，再减去最大方法区容量。 注意：由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话。 因此为每个线程分配到的栈内存越大，可以建立的线程数量自 然就越少，建立线程时就越容易把剩下的内存耗尽。 通过减少内存的手段来解决内存溢出的方式：如果是建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，就只通过减少最大堆和减少栈容量来换取更多的线程。 线程共享区Java堆溢出概念Java堆（Java Heap）是虚拟机管理的内存中的最大一块区域，也是垃圾回收的主要区域，它属于线程共享区，用于存储对象实例。 Java堆时垃圾收集器管理的内存区域Java堆也被称为GC堆（Garbage Collected Heap）。 从回收内存角度来看：垃圾收集器大部分都是基于分代收集理论设计的，会有 新生代、老年代、永久代（JDK8改为元空间）、Eden空间、From Survivor空间、To Survivor空间等名词。这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。 从分配内存角度来看：所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB, Thread Local Allocation Buffer），可以提升对象分配时的效率。不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。 物理存储空间Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。 注意：但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。 配置参数Java堆可以设置为固定大小，也可以为可动态扩展的。通过参数-Xmx和-Xms来设定堆的最大和最小内存容量。将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展。 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 为什么会堆溢出？当我们不断地创建新对象时，并且使GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，这时候，对象数量不断增加，总容量超过最大堆的容量限制后，就会发生内存溢出异常。 OMM的两种情况可以通过内存映像分析工具对dump出的堆存储快照进行分析。首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。 内存泄露（Memory Leak）如果是内存泄漏（内存中的对象不是必须存活的，垃圾收集器未收集），可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。 内存溢出（Memory Overflow）如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当： 检查Java虚拟机的堆参数(-Xmx与-Xms)设置，与机器的内存对比，看看是否还有向上调整的空间。 再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。 溢出案例和dump快照分析使用虚拟机参数： 1VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError 限制Java堆的大小为20M B，不可扩展。通过参数-XX:+HeapDumpOnOutOf-MemoryError可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照，以便进行事后分析。(文件存储在该项目父目录下，如：java_pid80802.hprof) 12345678910111213141516/** * Java堆内存异常测试 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError **/public class JavaHeapOOM &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = Lists.newArrayList(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 输出： 1234567891011java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid80802.hprof ...Heap dump file created [27964242 bytes in 0.193 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:265) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231) at java.util.ArrayList.add(ArrayList.java:462) at com.bubble.jvm.error.JavaHeapOOM.main(JavaHeapOOM.java:23) 可以在目录/Users/wugang/code/java/multi-dev下看到java_pid80802.hprof文件。 分析dump文件：可以通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出来的堆转储快照进行分析，也可以通过JDK自带的工具jvisualvm来可视化分析。12# 控制行执行命令jvisualvm 会打开下面的窗口，打开对应的堆dump文件： 主要内容为：由上图可知：导致 OutOfMemoryError 异常错误的线程是 main 查看dump的类信息：由上图可知：dump文件记录的堆中的实例总大小约19M，指定的堆的固定大小为20M。 用第一行的实例大小除以百分比就能算出来：堆中实例大小：12965216B/1024/1024=12.36M，占了总大小的65%。堆中实例总大小：12.36M/0.65=19.02M 说明：dump文件中的实例列表其实是反映了使用的堆的情况，而使用的堆内存并没有达到预先设置的最大堆内存，只是在申请堆内存的过程中超出了预先设置的最大堆内存，然后内存溢出。 方法区和运行时常量池溢出方法区（Method Area）方法区与Java堆一样，属于线程共享区，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。 注意： 关于方法区和永久代（元空间）：在JDK8以前，很多人把方法区称呼为永久代（Permanent Generation，或将两者混为一谈。本质上这两者并不是等价的，仅因为HotSpot使用永久代来实现方法区而已，使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；而到了JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Metaspace)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。 参数JDK8之前：老年代（Permanent Gennration） 如：-XX:PermSize=10M 指定老年代的初始空间大小（10M），以字节为单位。 如：-XX:MaxPermSize=10M 设置老年代最大值，默认是-1，即不限制，或者说只受限于本地内存大小。 JDK8始：元空间（Metaspace）Metaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。 -XX:MetaspaceSize：指定元空间的初始空间大小，以字节为单位。 达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下，适当提高该值。 该值越大触发Metaspace GC的时机就越晚。随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加上限也可能降低。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:Metaspacesize为21810376B（大约20.8M） 。 -XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。 防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。 -XX:MinMetaspaceFreeRatio：作用是在Metaspace GC收集之后，控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比。如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。在本机该参数的默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。 -XX:MaxMetaspaceFreeRatio：用于控制大的元空间剩余容量的百分比。 当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。在本机该参数的默认值为70，也就是70%。 -XX:MaxMetaspaceExpansion： Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。 -XX:MinMetaspaceExpansion： Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。 运行时常量池（Runtime Constant Pool）运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，在运行期间也可以将新的常量放入池中，如使用String类的intern()方法。 OOM异常运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 案例HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8中完全使用元空间来代替永久代。 方法区12345678910111213141516171819202122232425262728293031323334353637383940/** * 方法区的OOM异常： * - JDK8之前：指定老年代（方法区的大小固定为10M，不能进行自动扩展） * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M * * - JDK8：完全废除了老年代，用元空间代替。 * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M * * @author wugang * date: 2020-06-04 18:44 **/public class JavaMethodAreaOOM &#123; static class OOMObject &#123;&#125; /** * 借助CGLib使得方法区出现内存溢出异常： * 方法区的主要职责是用于存放类型的相关信息：如类名、访问修饰符、常量池、字段描述、方法描述等。 * 对于这部分区域的测试，基本的思路是：运行时产生大量的类去填满方法区，直到溢出为止。 * 所以：可以借助CGLib直接操作字节码，运行时生成了大量的动态类。 * 注意： * 当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到 CGLib这类字节码技术， * 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。 */ public static void main(String[] args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o, args); &#125; &#125;); enhancer.create(); &#125; &#125;&#125; 输出： 12345678910111213141516171819Exception in thread &quot;main&quot; net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348) at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492) at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305) at com.bubble.jvm.error.JavaMethodAreaOOM.main(JavaMethodAreaOOM.java:39)Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459) at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:339) ... 6 moreCaused by: java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ... 11 more 运行时常量池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.HashSet;import java.util.Set;/** * 方法区（运行时常量池）的OOM异常，（方法区在JDK8后开始废除，之前也被称为永久代） * - 在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中， * 我们可以通过-XX:PermSize和-XX:M axPermSize限制永久代的大小，即可间接限制其中常量池的容量。 * 如：VM Args:-XX:PermSize=6M -XX:MaxPermSize=6M * * @author wugang * date: 2020-06-04 17:36 **/public class RuntimeConstantPoolOOM &#123; /** * JDK6来运行代码，抛出异常： * Exception in thread \"main\" java.lang.OutOfMemoryError: PermGen space * at java.lang.String.intern(Native Method) * 说明运行时常量池是属于方法区(即JDK 6的HotSpot虚拟机中的永久代)的一部分。 * * 注意： * 无论是在JDK7中继续使用-XX:MaxPermSize参数或者在JDK8及以上版本使用-XX:MaxMeta-spaceSize参数 * 把方法区容量同样限制在6MB，也都不会重现JDK6中的溢出异常，循环将一直进行下去，永不停歇。 * * 因为自JDK7起，原本存放在永久代的字符串常量池被移至Java堆之中， * 所以在JDK7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。 * * 但使用-Xmx参数限制最大堆到6MB就能够看到下面两种运行结果之一，具体取决于哪里的对象分配时产生了溢出： * - OOM异常一： * Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space * at java.base/java.lang.Integer.toString(Integer.java:440) * at java.base/java.lang.String.valueOf(String.java:3058) * - OOM异常二： * Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space * at java.base/java.util.HashMap.resize(HashMap.java:699) * at java.base/java.util.HashMap.putVal(HashMap.java:658) * at java.base/java.util.HashMap.put(HashMap.java:607) * at java.base/java.util.HashSet.add(HashSet.java:220) * */ private static void runByJDK6() &#123; // 使用Set保持着常量池引用，避免Full GC回收常量池行为 Set&lt;String&gt; set = new HashSet&lt;&gt;(); // 在short范围内足以让6MB的PermSize产生OOM了 short i = 0; while (true) &#123; set.add(String.valueOf(i++).intern()); &#125; &#125; public static void main(String[] args) &#123; runByJDK6(); &#125;&#125; String::intern()方法String::intern()是一个Native方法，返回该对象在常量池中的引用。 1public native String intern(); 作用：如果字符串常量池中已经包含一个等于该String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * - 在JDK 6中运行，会得到三个false； * 在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代（方法区）的字符串常量池中存储， * 返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上， * 所以必然不可能是同一个引用，结果将返回false。 * * - 而在JDK 7后中运行，会得到一个true、一个false和一个true； * 因为JDK7中，intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中， * 那只需要在常量池里记录一下首次出现的实例引用即可。 * 因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。 * 而对str2比较返回false，这是因为java这个字符串在执行StringBuilder()之前就已经出现过了，(在加载sun.misc.Version这个类的时候进入常量池的) * 字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“JVM调优”这个字符串则是首次出现的，因此结果返回true。 * 而str3和str1一样，\"JDKJVM\"这个字符串则是首次出现。 * */private static void compare() &#123; String str1 = new StringBuilder().append(\"JVM\").append(\"调优\").toString(); System.out.println(str1.intern() == str1); // java这个字符串在执行StringBuilder()之前就已经出现过了，在加载sun.misc.Version这个类的时候进入常量池的。 /* * 参考：https://www.zhihu.com/question/51102308/answer/124441115 * sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化， * 而在初始化时它需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化， * 此时被 sun.misc.Version.launcher 静态常量字段所引用的\"java\"字符串字面量就被intern到HotSpot VM的字符串常量池StringTable里了。 */ String str2 = new StringBuilder().append(\"ja\").append(\"va\").toString(); System.out.println(str2.intern() == str2); // 而JDKJVM这个字符串则是首次出现 String str3 = new StringBuilder().append(\"JDK\").append(\"JVM\").toString(); System.out.println(str3.intern() == str3);&#125;/** * java中的String是引用类型。创建的String对象，实际上存储的是一个地址。 * 所以下面a和b都是引用类型，其存储的是字符串的地址。它们本身存储在Java虚拟机栈的局部变量表中。 * - a：直接将字符串存储在常量池中，然后将a指向常量池种中的\"JVM\"。 * - b：先将字符串\"JVM\"存储在常量池中，然后在heap中创建一个对象，该对象指向常量池中的\"JVM\"，最后将b指向heap中创建的这个对象。 * * 也就是说，a和b存储的内容是一样的，都是\"JVM\"，但地址不一样：a中保存的是常量池中\"JVM\"的地址，b保存的是heap中那个对象的地址， * * 双等于号\"==\"比较的是地址，equals()比较的是内容。 */private static void compareStr() &#123; String a = \"JVM\"; // new一个对象 String b = new String(\"JVM\"); // == 比较地址是否相等 // 都在运行时常量池中 System.out.println(\"JVM\" == a); // true System.out.println(a.intern() == a); // true // a为字符字面量（存储在运行时常量池中），b为对象（存储在堆中），所以不等。 System.out.println(a == b); // false System.out.println(a.intern() == b); // false System.out.println(a.equals(b)); // true&#125; 其他（不受JVM GC管理区域）本机直接内存溢出直接内存（Direct Memory）直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 容量大小可通过-XX:MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致。 NIO(New Input/Output)类NIO引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 OOM异常当各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。 1234567891011121314151617181920212223242526272829303132333435import sun.misc.Unsafe;import java.lang.reflect.Field;/** * 直接内存OOM异常：使用unsafe分配本机内存 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M * * @author wugang * date: 2020-06-04 19:43 **/public class DirectMemoryOOM &#123; private static final int _1MB = 1024 * 1024; /** * 越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配。 * （Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用） * 因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存， * 而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory ()。 * * 抛出异常： * Exception in thread \"main\" java.lang.OutOfMemoryError * at sun.misc.Unsafe.allocateMemory(Native Method) */ public static void main(String[] args) throws IllegalAccessException &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况。如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory(典型的间接使用就是NIO)，那就可以考虑重点检查一下直接内存方面的原因了。","categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://bubblewu.github.io/categories/Java/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://bubblewu.github.io/tags/JVM/"}]},{"title":"生产者-消费者案例","slug":"Java/生产者-消费者案例","date":"2020-06-05T06:52:19.000Z","updated":"2020-06-14T08:15:51.867Z","comments":true,"path":"ckbarvw0y000fyayd2z9y58tz/","link":"","permalink":"https://bubblewu.github.io/ckbarvw0y000fyayd2z9y58tz/","excerpt":"基于Java的生产者-消费者模式代码实现，可以此为Demo来用于具体的实际业务。","text":"基于Java的生产者-消费者模式代码实现，可以此为Demo来用于具体的实际业务。 生产者-消费者demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.time.Duration;import java.time.Instant;import java.util.*;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;&#x2F;** * 推荐服务：生产者-消费者模式 * * @author bubble * date: 2018-10-22 15:03 **&#x2F;@Deprecatedpublic class RecService &#123; private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(RecService.class); &#x2F;&#x2F; 日志打印间隔 private static int DEFAULT_LOG_INTERVAL &#x3D; 1000 * 10; &#x2F;&#x2F; 队列默认处理容量，为避免队列扩容造成额外性能损耗，默认不扩容，达到当前大小，进入等待，消费者处理一部分数据之后，生产者继续生产 private static int DEFAULT_QUEUE_DISPOSE_SIZE &#x3D; 1000 * 10; &#x2F;&#x2F; 队列默认容量 private static int DEFAULT_QUEUE_SIZE &#x3D; DEFAULT_QUEUE_DISPOSE_SIZE + 200; &#x2F;&#x2F; 每个队列满时默认休眠时间 private static int DEFAULT_SLEEP_TIME &#x3D; 1000; &#x2F;&#x2F; 线程池默认消费者数量 private static int DEFAULT_CONSUMER_NUM &#x3D; 2; &#x2F;&#x2F; 用户的phoneId队列 private LinkedBlockingQueue&lt;Long&gt; phoneIdQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(DEFAULT_QUEUE_SIZE); private Long STOP_FLAG &#x3D; -1L; private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap; &#x2F;&#x2F; 用户航班信息 private Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; getFlightInfoMap() &#123; return flightInfoMap; &#125; private void setFlightInfoMap(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; flightInfoMap) &#123; this.flightInfoMap &#x3D; flightInfoMap; &#125; private RecJobBean recJob; private TipRecService tipRecService; private CarRecService carRecService; private HotelRecService hotelRecService; public RecService(RecJobBean recJob) &#123; this.recJob &#x3D; recJob; switch (recJob) &#123; case TIP: tipRecService &#x3D; Optional.ofNullable(tipRecService).orElse(new TipRecService()); break; case CAR: carRecService &#x3D; Optional.ofNullable(carRecService).orElse(new CarRecService()); break; case HOTEL: hotelRecService &#x3D; Optional.ofNullable(hotelRecService).orElse(new HotelRecService()); break; default: LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType()); System.exit(0); break; &#125; &#125; public void rec(Map&lt;Long, List&lt;FlightInfoBean&gt;&gt; userFlightMap, int top) &#123; LOGGER.info(&quot;start &#123;&#125; rec job.&quot;, recJob.getType()); if (userFlightMap &#x3D;&#x3D; null || userFlightMap.isEmpty()) &#123; LOGGER.error(&quot;user flight is empty, rec job for &#123;&#125; exit.&quot;, recJob.getType()); System.exit(0); &#125; setFlightInfoMap(userFlightMap); UserProducer userProducer &#x3D; new UserProducer(); userProducer.setName(&quot;producer&quot;); userProducer.start(); UserConsumer userConsumer &#x3D; new UserConsumer(recJob, top); ThreadPoolExecutor poolExecutor &#x3D; userConsumer.consumerAndRec(); threadMonitor(poolExecutor); &#125; &#x2F;** * 监控ThreadPoolExecutor线程池，无活动线程就关闭线程池连接； *&#x2F; private void threadMonitor(ThreadPoolExecutor executor) &#123; Runnable runnable &#x3D; () -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(2); while (executor.getActiveCount() &gt; 0) &#123; TimeUnit.SECONDS.sleep(1); &#125; executor.shutdown(); &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;thread monitor error.&quot;, e); &#125; &#125;; new Thread(runnable).start(); &#125; &#x2F;** * 生产者: 可用phoneId集合 *&#x2F; class UserProducer extends Thread &#123; int i &#x3D; 0; @Override public void run() &#123; addUser(); try &#123; &#x2F;&#x2F; 给每个线程都在队列（FIFO）末尾添加标识 phoneIdQueue.put(STOP_FLAG); &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;save phoneId error.&quot;, e); &#125; LOGGER.info(&quot;[&#123;&#125;] thread altogether produces &#123;&#125; data&quot;, this.getName(), i); LOGGER.info(&quot;[&#123;&#125;] thread produces done.&quot;, this.getName()); &#125; private void addUser() &#123; try &#123; int step &#x3D; 0; LOGGER.info(&quot;add &#123;&#125; user in producer queue.&quot;, getFlightInfoMap().size()); Iterator iter &#x3D; getFlightInfoMap().entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry &#x3D; (Map.Entry) iter.next(); long uid &#x3D; (long) entry.getKey(); phoneIdQueue.put(uid); step++; while (phoneIdQueue.size() &gt; DEFAULT_QUEUE_DISPOSE_SIZE) &#123; Thread.sleep(DEFAULT_SLEEP_TIME); &#125; if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123; i +&#x3D; step; step &#x3D; 0; LOGGER.info(&quot;[&#123;&#125;] thread has produced &#123;&#125; pieces of data&quot;, this.getName(), i); &#125; &#125; i +&#x3D; step; &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;save phoneId error.&quot;, e); &#125; &#125; &#125; &#x2F;** * 消费者：取phoneId并进行推荐 *&#x2F; class UserConsumer &#123; private int top; private RecJobBean recJob; public UserConsumer(RecJobBean recJob, int top) &#123; this.recJob &#x3D; recJob; this.top &#x3D; top; &#125; public ThreadPoolExecutor consumerAndRec() &#123; ThreadPoolExecutor poolExecutor &#x3D; new ThreadPoolExecutor(DEFAULT_CONSUMER_NUM, DEFAULT_CONSUMER_NUM &lt;&lt; 1, 60 * 60 * 4, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(50), new ThreadPoolExecutor.CallerRunsPolicy()); LOGGER.info(&quot;Consumer start.&quot;); for (int i &#x3D; 0; i &lt; DEFAULT_CONSUMER_NUM; i++) &#123; Thread t &#x3D; new Thread() &#123; int step &#x3D; 0; int consumerNum &#x3D; 0; @Override public void run() &#123; while (!this.isInterrupted()) &#123; Long phoneId; try &#123; phoneId &#x3D; phoneIdQueue.take(); if (phoneId.equals(STOP_FLAG)) &#123; &#x2F;&#x2F; 该线程取到-1，说明产品队列中已无产品，可以结束线程，但是可能还有其他线程存活，需要通知其他线程已无数据 &#x2F;&#x2F; 因此，插入-1，同时跳出循环，线程归还线程池，等待监控线程发现其处于非活动状态，将其销毁，最终销毁线程池 phoneIdQueue.put(STOP_FLAG); LOGGER.info(&quot;[&#123;&#125;] thread consumes done.&quot;, this.getName()); break; &#125; recOneUser(recJob, phoneId, top); consumerNum++; step++; if (step &#x3D;&#x3D; DEFAULT_LOG_INTERVAL) &#123; step &#x3D; 0; LOGGER.info(&quot;[&#123;&#125;] thread has consumed &#123;&#125; pieces of data&quot;, this.getName(), consumerNum); &#125; &#125; catch (InterruptedException e) &#123; LOGGER.error(&quot;read data from phoneIdQueue error.&quot;, e); &#125; &#125; LOGGER.info(&quot;[&#123;&#125;] thread altogether consumes &#123;&#125; user data&quot;, this.getName(), consumerNum); LOGGER.info(&quot;RecConsumer end.&quot;); &#125; &#125;; t.setName(&quot;RecConsumer-&quot; + i); poolExecutor.execute(t); &#125; return poolExecutor; &#125; &#125; private void recOneUser(RecJobBean recJob, long uid, int top) &#123; Instant begin &#x3D; Instant.now(); List&lt;FlightInfoBean&gt; userFlightInfoList &#x3D; getFlightInfoMap().get(uid); if (userFlightInfoList !&#x3D; null &amp;&amp; !userFlightInfoList.isEmpty()) &#123; List&lt;TipsUserLinkBean&gt; recItems &#x3D; new ArrayList&lt;&gt;(); switch (recJob) &#123; case TIP: recItems &#x3D; tipRecService.rec(uid, userFlightInfoList, top); break; case CAR: recItems &#x3D; carRecService.rec(uid, userFlightInfoList); break; case HOTEL: recItems &#x3D; hotelRecService.rec(uid, userFlightInfoList, top); break; default: LOGGER.error(&quot;please enter the correct rec type, error type: &#123;&#125; &quot;, recJob.getType()); break; &#125; LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(begin, Instant.now()).toMillis()); Instant saveStart &#x3D; Instant.now(); try &#123; DataService.saveTipsUserLink(recItems, recJob); &#125; catch (java.lang.NullPointerException np) &#123; LOGGER.error(&quot;user [&#123;&#125;] saveTipsUserLink error.&quot;, uid, np); &#125; LOGGER.info(&quot;&#123;&#125; rec for user [&#123;&#125;] count is &#123;&#125;, save costs &#123;&#125; ms&quot;, recJob.getType(), uid, recItems.size(), Duration.between(saveStart, Instant.now()).toMillis()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"}]},{"title":"Bubble Sort","slug":"Python/冒泡排序","date":"2020-05-11T15:08:10.000Z","updated":"2020-06-14T08:23:06.061Z","comments":true,"path":"ckbarvw1m001ryayd2tq6599d/","link":"","permalink":"https://bubblewu.github.io/ckbarvw1m001ryayd2tq6599d/","excerpt":"经典面试题---进阶版冒泡排序","text":"经典面试题---进阶版冒泡排序 常规版1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-def foo(data): \"\"\"常规版\"\"\" for i in range(len(data)): for j in range(len(data)-i-1): if data[j] &gt; data[j+1]: data[j], data[j + 1] = data[j + 1], data[j] return dataif __name__ == '__main__': data = [3, 0, 5, 4, 2, 6, 8, 1, 9, 7] print(data) print(foo(data)) 进阶版1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# -*- coding: utf-8 -*-def bubble_sort(data): \"\"\" 进阶版 最坏情况 时间复杂度 O(n**2) 最好情况 时间复杂度 O(n) 稳定排序法 空间复杂度最佳 只需要一个额外空间 适用于数据量小或有部分数据已经排过序的情况 :param data: :return: \"\"\" # i 倒序循环列表排序 for i in range(len(data)-1, -1, -1): flag = False # flag判断是否执行了交换操作 for j in range(i): # i 为倒序循环，所以j的最大值即是i 0～i if data[j] &gt; data[j + 1]: data[j], data[j + 1] = data[j + 1], data[j] flag = True # 执行过交换操作，把flag置为True if not flag: # 执行完一次扫描后，判断是否执行过交换操作，如果没有交换过数据，就表示此时数组已完成排序，故直接跳出循环 break print('第&#123;0&#125;次排序: &#123;1&#125;'.format(len(data)-i, data)) return dataif __name__ == '__main__': data = [3, 0, 5, 4, 2, 6, 8, 1, 9, 7] print(data) print(bubble_sort(data))","categories":[{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/categories/Python/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://bubblewu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://bubblewu.github.io/categories/Java/JVM/"},{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/categories/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/categories/Python/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bubblewu.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://bubblewu.github.io/tags/JVM/"},{"name":"Neo4j","slug":"Neo4j","permalink":"https://bubblewu.github.io/tags/Neo4j/"},{"name":"Python","slug":"Python","permalink":"https://bubblewu.github.io/tags/Python/"},{"name":"面试","slug":"面试","permalink":"https://bubblewu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]}